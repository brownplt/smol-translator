// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Js_string from "rescript/lib/es6/js_string.js";
import * as Core__List from "@rescript/core/src/Core__List.mjs";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.mjs";
import * as Core__Float from "@rescript/core/src/Core__Float.mjs";
import * as SExpression from "@brownplt/s-expression/src/SExpression.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.mjs";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Caml_splice_call from "rescript/lib/es6/caml_splice_call.js";
import * as Belt_HashMapString from "rescript/lib/es6/belt_HashMapString.js";
import * as Belt_HashSetString from "rescript/lib/es6/belt_HashSetString.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function mapAnn(f) {
  return function (param) {
    return {
            it: f(param.it),
            ann: param.ann
          };
  };
}

function toSourceMap(t, stringOfKey) {
  var hMap = new Map();
  var ln = {
    contents: 0
  };
  var ch = {
    contents: 0
  };
  var f = function (param) {
    var it = param.it;
    var begin_ln = ln.contents;
    var begin_ch = ch.contents;
    var begin = {
      ln: begin_ln,
      ch: begin_ch
    };
    if (it.TAG === "Plain") {
      it._0.split("").forEach(function (c) {
            if (c !== "\n") {
              ch.contents = ch.contents + 1 | 0;
              return ;
            }
            ln.contents = ln.contents + 1 | 0;
            ch.contents = 0;
          });
    } else {
      Core__List.forEach(it._0, f);
    }
    var end_ln = ln.contents;
    var end_ch = ch.contents;
    var end = {
      ln: end_ln,
      ch: end_ch
    };
    Core__Option.forEach(param.ann, (function (ann) {
            hMap.set(stringOfKey(ann), {
                  begin: begin,
                  end: end
                });
          }));
  };
  f(t);
  return hMap;
}

function extract(param, id, stringOfID) {
  var ann = param.ann;
  var it = param.it;
  if (ann !== undefined ? Caml_obj.equal(stringOfID(Caml_option.valFromOption(ann)), stringOfID(id)) : false) {
    return {
            it: it,
            ann: ann
          };
  }
  if (it.TAG === "Plain") {
    return ;
  }
  var _es = it._0;
  while(true) {
    var es = _es;
    if (!es) {
      return ;
    }
    var e = extract(es.hd, id, stringOfID);
    if (e !== undefined) {
      return e;
    }
    _es = es.tl;
    continue ;
  };
}

function toString(t) {
  var s = t.it;
  if (s.TAG === "Plain") {
    return s._0;
  } else {
    return Core__List.toArray(Core__List.map(s._0, toString)).join("");
  }
}

function map(f) {
  return function (t) {
    var s = t.it;
    var tmp;
    tmp = s.TAG === "Plain" ? ({
          TAG: "Plain",
          _0: f(s._0)
        }) : ({
          TAG: "Group",
          _0: Core__List.map(s._0, map(f))
        });
    return {
            it: tmp,
            ann: t.ann
          };
  };
}

function concat2(p1, s, p2) {
  return {
          TAG: "Group",
          _0: {
            hd: p1,
            tl: {
              hd: {
                it: {
                  TAG: "Plain",
                  _0: s
                },
                ann: undefined
              },
              tl: {
                hd: p2,
                tl: /* [] */0
              }
            }
          }
        };
}

function concat(s, ts) {
  var intersperse = function (x, ys) {
    if (!ys) {
      return /* [] */0;
    }
    var ys$1 = ys.tl;
    var y = ys.hd;
    if (!ys$1) {
      return {
              hd: y,
              tl: /* [] */0
            };
    }
    var loop = function (ys) {
      if (ys) {
        return {
                hd: x,
                tl: {
                  hd: ys.hd,
                  tl: loop(ys.tl)
                }
              };
      } else {
        return /* [] */0;
      }
    };
    return {
            hd: y,
            tl: loop(ys$1)
          };
  };
  return {
          TAG: "Group",
          _0: intersperse({
                it: {
                  TAG: "Plain",
                  _0: s
                },
                ann: undefined
              }, ts)
        };
}

function fromString(it) {
  return {
          it: {
            TAG: "Plain",
            _0: it
          },
          ann: undefined
        };
}

function wrap(prefix, it, suffix) {
  var prefix_it = {
    TAG: "Plain",
    _0: prefix
  };
  var prefix$1 = {
    it: prefix_it,
    ann: undefined
  };
  var suffix_it = {
    TAG: "Plain",
    _0: suffix
  };
  var suffix$1 = {
    it: suffix_it,
    ann: undefined
  };
  return {
          TAG: "Group",
          _0: {
            hd: prefix$1,
            tl: {
              hd: it,
              tl: {
                hd: suffix$1,
                tl: /* [] */0
              }
            }
          }
        };
}

function dummy(it) {
  return {
          it: it,
          ann: undefined
        };
}

function includes(t, s) {
  var it = t.it;
  if (it.TAG === "Plain") {
    return it._0.includes(s);
  } else {
    return Core__List.some(it._0, (function (t) {
                  return includes(t, s);
                }));
  }
}

function s(strings, parameters) {
  var s$1 = Core__Option.getExn(Core__Array.last(strings), undefined);
  var ih = s$1 === "" ? /* [] */0 : ({
        hd: {
          it: {
            TAG: "Plain",
            _0: s$1
          },
          ann: undefined
        },
        tl: /* [] */0
      });
  return {
          TAG: "Group",
          _0: Core__Array.reduceRightWithIndex(parameters, ih, (function (ih, parameter, i) {
                  var ih$1 = {
                    hd: parameter,
                    tl: ih
                  };
                  var s = Core__Option.getExn(strings[i], undefined);
                  if (s === "") {
                    return ih$1;
                  } else {
                    return {
                            hd: {
                              it: {
                                TAG: "Plain",
                                _0: s
                              },
                              ann: undefined
                            },
                            tl: ih$1
                          };
                  }
                }))
        };
}

function containsNL(it) {
  return includes(it, "\n");
}

function toString$1(t) {
  if (typeof t !== "object") {
    switch (t) {
      case "Maybe" :
          return "maybe?";
      case "PairNew" :
          return "mpair";
      case "PairRefLeft" :
          return "left";
      case "PairRefRight" :
          return "right";
      case "PairSetLeft" :
          return "set-left!";
      case "PairSetRight" :
          return "set-right!";
      case "VecNew" :
          return "mvec";
      case "VecRef" :
          return "vec-ref";
      case "VecSet" :
          return "vec-set!";
      case "VecLen" :
          return "vec-len";
      case "Err" :
          return "error";
      case "Not" :
          return "not";
      case "ZeroP" :
          return "zero?";
      case "Print" :
          return "print";
      case "Next" :
          return "next";
      case "StringAppend" :
          return "++";
      case "Cons" :
          return "cons";
      case "List" :
          return "list";
      case "EmptyP" :
          return "empty?";
      case "First" :
          return "first";
      case "Rest" :
          return "rest";
      
    }
  } else if (t.TAG === "Arith") {
    switch (t._0) {
      case "Add" :
          return "+";
      case "Sub" :
          return "-";
      case "Mul" :
          return "*";
      case "Div" :
          return "/";
      
    }
  } else {
    switch (t._0) {
      case "Lt" :
          return "<";
      case "NumEq" :
          return "=";
      case "Eq" :
          return "eq?";
      case "Gt" :
          return ">";
      case "Le" :
          return "<=";
      case "Ge" :
          return ">=";
      case "Ne" :
          return "!=";
      case "Equal" :
          return "equal?";
      
    }
  }
}

var Primitive = {
  toString: toString$1
};

function toString$2(t) {
  switch (t) {
    case "Plain" :
        return "let";
    case "Nested" :
        return "let*";
    case "Recursive" :
        return "letrec";
    
  }
}

var LetKind = {
  toString: toString$2
};

function termsOfBlock(param) {
  var it = param.it;
  if (it.TAG === "BRet") {
    return /* [] */0;
  } else {
    return {
            hd: it._0,
            tl: termsOfBlock(it._1)
          };
  }
}

function termsOfProgram(param) {
  var it = param.it;
  if (typeof it !== "object") {
    return /* [] */0;
  } else {
    return {
            hd: it._0,
            tl: termsOfProgram(it._1)
          };
  }
}

function xsOfTerm(t) {
  var d = t.it;
  if (d.TAG === "Def") {
    var d$1 = d._0;
    var match = d$1.it;
    return {
            hd: match._0,
            tl: /* [] */0
          };
  } else {
    return /* [] */0;
  }
}

function xsOfBlock(b) {
  return Core__List.flat(Core__List.map(termsOfBlock(b), xsOfTerm));
}

function xsOfProgram(p) {
  return Core__List.flat(Core__List.map(termsOfProgram(p), xsOfTerm));
}

function toString$3(t) {
  switch (t) {
    case "Name" :
        return "name";
    case "Expression" :
        return "expression";
    case "Bind" :
        return "bind";
    case "Block" :
        return "block";
    case "Definition" :
        return "definition";
    case "Term" :
        return "term";
    case "Program" :
        return "program";
    
  }
}

var NodeKind = {
  toString: toString$3
};

function toString$4(t) {
  if (t === "Atom") {
    return "atom";
  } else {
    return "list";
  }
}

var SExprKind = {
  toString: toString$4
};

function toString$5(t) {
  switch (t) {
    case "ExactlyOne" :
        return "exactly one";
    case "ExactlyTwo" :
        return "exactly two";
    case "ExactlyThree" :
        return "exactly three";
    case "OneThenMany" :
        return "one followed by many";
    case "ManyThenOne" :
        return "many followed by one";
    case "OneThenManyThenOne" :
        return "one followed by several followed by one";
    
  }
}

var Arity = {
  toString: toString$5
};

function toString$6(t) {
  if (t === "Definition") {
    return "definition";
  } else {
    return "expression";
  }
}

var TermKind = {
  toString: toString$6
};

function toString$7(t) {
  switch (t.TAG) {
    case "SExprParseError" :
        return "expecting a (valid) s-expression, but the input is not: " + t._0;
    case "SExprKindError" :
        return "expecting a " + t._1 + ", given " + SExpression.SExpr.toString(t._2);
    case "SExprArityError" :
        return "expecting " + t._1 + ", given " + Core__List.toArray(Core__List.map(t._2, SExpression.SExpr.toString)).join(" ");
    case "LiteralListError" :
        return "expecting a constant or a vector, given " + SExpression.SExpr.toString(t._0);
    case "TermKindError" :
        var term = t._2;
        return "expecting " + t._1 + ", given something else at " + SExpression.SourcePoint.toString(term.ann.begin) + "-" + SExpression.SourcePoint.toString(term.ann.end);
    
  }
}

var ParseError = {
  toString: toString$7
};

var SMoLParseError = /* @__PURE__ */Caml_exceptions.create("SMoL.SMoLParseError");

function makeProgram(ts) {
  if (!ts) {
    return {
            it: "PNil",
            ann: {
              begin: {
                ln: 0,
                ch: 0
              },
              end: {
                ln: 0,
                ch: 0
              }
            }
          };
  }
  var ts$1 = ts.tl;
  var t = ts.hd;
  if (ts$1) {
    var p = makeProgram(ts$1);
    return {
            it: {
              TAG: "PCons",
              _0: t,
              _1: p
            },
            ann: {
              begin: t.ann.begin,
              end: p.ann.end
            }
          };
  }
  var rest_ann = {
    begin: t.ann.end,
    end: t.ann.end
  };
  var rest = {
    it: "PNil",
    ann: rest_ann
  };
  return {
          it: {
            TAG: "PCons",
            _0: t,
            _1: rest
          },
          ann: t.ann
        };
}

function makeBlock(ts, e) {
  if (!ts) {
    return {
            it: {
              TAG: "BRet",
              _0: e
            },
            ann: e.ann
          };
  }
  var t = ts.hd;
  var b = makeBlock(ts.tl, e);
  return {
          it: {
            TAG: "BCons",
            _0: t,
            _1: b
          },
          ann: {
            begin: t.ann.begin,
            end: b.ann.end
          }
        };
}

function constant_of_atom(atom) {
  if (atom.TAG === "Str") {
    return {
            TAG: "Str",
            _0: atom._0
          };
  }
  var x = atom._0;
  switch (x) {
    case "#f" :
        return {
                TAG: "Lgc",
                _0: false
              };
    case "#t" :
        return {
                TAG: "Lgc",
                _0: true
              };
    default:
      var tryNum = Core__Float.fromString(x);
      if (tryNum !== undefined) {
        return {
                TAG: "Num",
                _0: tryNum
              };
      } else {
        return {
                TAG: "Sym",
                _0: x
              };
      }
  }
}

function outputletOfSExpr(e) {
  var it = e.it;
  if (it.TAG === "Atom") {
    var match = it._0;
    if (match.TAG !== "Str" && match._0 === "error") {
      return "OErr";
    }
    
  }
  var p = function (e) {
    var atom = e.it;
    if (atom.TAG === "Atom") {
      return {
              TAG: "Con",
              _0: constant_of_atom(atom._0)
            };
    } else if (atom.sequenceKind === "List") {
      return {
              TAG: "Struct",
              _0: undefined,
              _1: {
                TAG: "Lst",
                _0: Core__List.map(atom.content, p)
              }
            };
    } else {
      return {
              TAG: "Struct",
              _0: undefined,
              _1: {
                TAG: "Vec",
                _0: Core__List.map(atom.content, p)
              }
            };
    }
  };
  return {
          TAG: "OVal",
          _0: p(e)
        };
}

function parseValue(e) {
  var ann = e.ann;
  var it = e.it;
  if (it.TAG === "Atom") {
    return {
            it: {
              TAG: "Con",
              _0: constant_of_atom(it._0)
            },
            ann: ann
          };
  }
  if (it.sequenceKind === "List") {
    var content = Core__List.map(it.content, parseValue);
    return {
            it: {
              TAG: "AppPrm",
              _0: "List",
              _1: content
            },
            ann: ann
          };
  }
  var content$1 = Core__List.map(it.content, parseValue);
  return {
          it: {
            TAG: "AppPrm",
            _0: "VecNew",
            _1: content$1
          },
          ann: ann
        };
}

function as_id(context, e) {
  var match = e.it;
  if (match.TAG === "Atom") {
    var x = match._0;
    if (x.TAG !== "Str") {
      return {
              it: x._0,
              ann: e.ann
            };
    }
    throw {
          RE_EXN_ID: SMoLParseError,
          _1: {
            TAG: "SExprKindError",
            _0: "Atom",
            _1: context,
            _2: e
          },
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: "SExprKindError",
          _0: "Atom",
          _1: context,
          _2: e
        },
        Error: new Error()
      };
}

function as_list(context, e) {
  var it = e.it;
  if (it.TAG === "Atom") {
    throw {
          RE_EXN_ID: SMoLParseError,
          _1: {
            TAG: "SExprKindError",
            _0: "List",
            _1: context,
            _2: e
          },
          Error: new Error()
        };
  }
  if (it.sequenceKind === "List") {
    return {
            it: it.content,
            ann: e.ann
          };
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: "SExprKindError",
          _0: "List",
          _1: context,
          _2: e
        },
        Error: new Error()
      };
}

function as_one_then_many(context, es) {
  if (es) {
    return [
            es.hd,
            es.tl
          ];
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: "SExprArityError",
          _0: "OneThenMany",
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_many_then_one(context, es) {
  if (es) {
    var e1 = es.hd;
    var match = Core__List.reverse(es.tl);
    if (match) {
      return [
              {
                hd: e1,
                tl: Core__List.reverse(match.tl)
              },
              match.hd
            ];
    } else {
      return [
              /* [] */0,
              e1
            ];
    }
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: "SExprArityError",
          _0: "ManyThenOne",
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_one(context, es) {
  if (es) {
    if (es.tl) {
      throw {
            RE_EXN_ID: SMoLParseError,
            _1: {
              TAG: "SExprArityError",
              _0: "ExactlyOne",
              _1: context,
              _2: es
            },
            Error: new Error()
          };
    }
    return es.hd;
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: "SExprArityError",
          _0: "ExactlyOne",
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_two(context, es) {
  if (es) {
    var match = es.tl;
    if (match && !match.tl) {
      return [
              es.hd,
              match.hd
            ];
    }
    
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: "SExprArityError",
          _0: "ExactlyTwo",
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_three(context, es) {
  if (es) {
    var match = es.tl;
    if (match) {
      var match$1 = match.tl;
      if (match$1 && !match$1.tl) {
        return [
                es.hd,
                match.hd,
                match$1.hd
              ];
      }
      
    }
    
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: "SExprArityError",
          _0: "ExactlyThree",
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_one_then_many_then_one(context, es) {
  if (es) {
    var match = es.tl;
    if (match) {
      var e2 = match.hd;
      var e1 = es.hd;
      var match$1 = Core__List.reverse(match.tl);
      if (match$1) {
        return [
                e1,
                {
                  hd: e2,
                  tl: Core__List.reverse(match$1.tl)
                },
                match$1.hd
              ];
      } else {
        return [
                e1,
                /* [] */0,
                e2
              ];
      }
    }
    throw {
          RE_EXN_ID: SMoLParseError,
          _1: {
            TAG: "SExprArityError",
            _0: "OneThenManyThenOne",
            _1: context,
            _2: es
          },
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: "SExprArityError",
          _0: "OneThenManyThenOne",
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_expr(context, e) {
  var it = e.it;
  if (it.TAG !== "Def") {
    return it._0;
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: "TermKindError",
          _0: "Expression",
          _1: context,
          _2: e
        },
        Error: new Error()
      };
}

function expr_of_atom(atom) {
  if (atom.TAG === "Str") {
    return {
            TAG: "Con",
            _0: {
              TAG: "Str",
              _0: atom._0
            }
          };
  }
  var x = atom._0;
  switch (x) {
    case "#f" :
        return {
                TAG: "Con",
                _0: {
                  TAG: "Lgc",
                  _0: false
                }
              };
    case "#t" :
        return {
                TAG: "Con",
                _0: {
                  TAG: "Lgc",
                  _0: true
                }
              };
    default:
      var tryNum = Core__Option.map(Core__Float.fromString(x), (function (n) {
              return {
                      TAG: "Con",
                      _0: {
                        TAG: "Num",
                        _0: n
                      }
                    };
            }));
      return Core__Option.getOr(tryNum, {
                  TAG: "Ref",
                  _0: x
                });
  }
}

function parseLet(letKind, ann, rest) {
  var match = as_one_then_many_then_one("the bindings followed by the body", rest);
  var xes = Core__List.map(Core__List.map(as_list("variable-expression pairs", match[0]).it, (function (xe) {
              return as_list("a variable and an expression", xe);
            })), mapAnn(function (xe) {
            return as_two("a variable and an expression", xe);
          }));
  var xes$1 = Core__List.map(xes, mapAnn(function (param) {
            var x = as_id("a variable to be bound", param[0]);
            var e = as_expr("an expression", parseTerm(param[1]));
            return [
                    x,
                    e
                  ];
          }));
  var ts = Core__List.map(match[1], parseTerm);
  var result = as_expr("an expression to be return", parseTerm(match[2]));
  return {
          TAG: "Exp",
          _0: ann({
                TAG: "Let",
                _0: letKind,
                _1: xes$1,
                _2: makeBlock(ts, result)
              })
        };
}

function parseTerm(e) {
  var ann = function (it) {
    return {
            it: it,
            ann: e.ann
          };
  };
  var atom = e.it;
  var tmp;
  if (atom.TAG === "Atom") {
    var it = expr_of_atom(atom._0);
    tmp = {
      TAG: "Exp",
      _0: {
        it: it,
        ann: e.ann
      }
    };
  } else if (atom.sequenceKind === "List") {
    var es = atom.content;
    var exit = 0;
    if (es) {
      var match = es.hd.it;
      if (match.TAG === "Atom") {
        var match$1 = match._0;
        if (match$1.TAG === "Str") {
          exit = 1;
        } else {
          var exit$1 = 0;
          switch (match$1._0) {
            case "!=" :
                tmp = makeAppPrm(ann, {
                      TAG: "Cmp",
                      _0: "Ne"
                    }, es.tl);
                break;
            case "*" :
                tmp = makeAppPrm(ann, {
                      TAG: "Arith",
                      _0: "Mul"
                    }, es.tl);
                break;
            case "+" :
                tmp = makeAppPrm(ann, {
                      TAG: "Arith",
                      _0: "Add"
                    }, es.tl);
                break;
            case "++" :
                tmp = makeAppPrm(ann, "StringAppend", es.tl);
                break;
            case "-" :
                tmp = makeAppPrm(ann, {
                      TAG: "Arith",
                      _0: "Sub"
                    }, es.tl);
                break;
            case "/" :
                tmp = makeAppPrm(ann, {
                      TAG: "Arith",
                      _0: "Div"
                    }, es.tl);
                break;
            case "<" :
                tmp = makeAppPrm(ann, {
                      TAG: "Cmp",
                      _0: "Lt"
                    }, es.tl);
                break;
            case "<=" :
                tmp = makeAppPrm(ann, {
                      TAG: "Cmp",
                      _0: "Le"
                    }, es.tl);
                break;
            case "=" :
                tmp = makeAppPrm(ann, {
                      TAG: "Cmp",
                      _0: "NumEq"
                    }, es.tl);
                break;
            case ">" :
                tmp = makeAppPrm(ann, {
                      TAG: "Cmp",
                      _0: "Gt"
                    }, es.tl);
                break;
            case ">=" :
                tmp = makeAppPrm(ann, {
                      TAG: "Cmp",
                      _0: "Ge"
                    }, es.tl);
                break;
            case "and" :
                var e_ns = Core__List.map(Core__List.map(es.tl, parseTerm), (function (e) {
                        return as_expr("an expression", e);
                      }));
                tmp = {
                  TAG: "Exp",
                  _0: {
                    it: {
                      TAG: "And",
                      _0: e_ns
                    },
                    ann: e.ann
                  }
                };
                break;
            case "begin" :
                var match$2 = as_many_then_one("one or more expressions", es.tl);
                var terms = Core__List.map(Core__List.map(match$2[0], parseTerm), (function (t) {
                        return as_expr("an expression", t);
                      }));
                var result = as_expr("an expression", parseTerm(match$2[1]));
                tmp = {
                  TAG: "Exp",
                  _0: {
                    it: {
                      TAG: "Bgn",
                      _0: terms,
                      _1: result
                    },
                    ann: e.ann
                  }
                };
                break;
            case "cond" :
                var branches = Core__List.map(Core__List.map(es.tl, (function (branch) {
                            return as_list("a `cond` branch", branch).it;
                          })), (function (branch) {
                        return as_one_then_many_then_one("the condition followed by the branch", branch);
                      }));
                var loop = function (_parsed, _branches) {
                  while(true) {
                    var branches = _branches;
                    var parsed = _parsed;
                    if (branches) {
                      var match = branches.hd;
                      var $$case = match[0];
                      var match$1 = $$case.it;
                      if (match$1.TAG === "Atom") {
                        var match$2 = match$1._0;
                        if (match$2.TAG !== "Str" && match$2._0 === "else" && !branches.tl) {
                          var terms = Core__List.map(match[1], parseTerm);
                          var result = as_expr("an expression", parseTerm(match[2]));
                          var it_0 = Core__List.reverse(parsed);
                          var it_1 = makeBlock(terms, result);
                          var it = {
                            TAG: "Cnd",
                            _0: it_0,
                            _1: it_1
                          };
                          return {
                                  TAG: "Exp",
                                  _0: {
                                    it: it,
                                    ann: e.ann
                                  }
                                };
                        }
                        
                      }
                      var $$case$1 = as_expr("a (conditional) expression", parseTerm($$case));
                      var terms$1 = Core__List.map(match[1], parseTerm);
                      var result$1 = as_expr("an expression", parseTerm(match[2]));
                      _branches = branches.tl;
                      _parsed = {
                        hd: [
                          $$case$1,
                          makeBlock(terms$1, result$1)
                        ],
                        tl: parsed
                      };
                      continue ;
                    }
                    var it_0$1 = Core__List.reverse(parsed);
                    var it$1 = {
                      TAG: "Cnd",
                      _0: it_0$1,
                      _1: undefined
                    };
                    return {
                            TAG: "Exp",
                            _0: {
                              it: it$1,
                              ann: e.ann
                            }
                          };
                  };
                };
                tmp = loop(/* [] */0, branches);
                break;
            case "deffun" :
                var match$3 = as_one_then_many_then_one("a function header and a body", es.tl);
                var match$4 = as_one_then_many("function name followed by parameters", as_list("function name and parameters", match$3[0]).it);
                var fun = as_id("a function name", match$4[0]);
                var args = Core__List.map(match$4[1], (function (arg) {
                        return as_id("a parameter", arg);
                      }));
                var terms$1 = Belt_List.map(match$3[1], parseTerm);
                var result$1 = as_expr("an expression to be returned", parseTerm(match$3[2]));
                var it_2 = makeBlock(terms$1, result$1);
                var it$1 = {
                  TAG: "Fun",
                  _0: fun,
                  _1: args,
                  _2: it_2
                };
                tmp = {
                  TAG: "Def",
                  _0: {
                    it: it$1,
                    ann: e.ann
                  }
                };
                break;
            case "defgen" :
                var match$5 = as_one_then_many_then_one("a generator header and a body", es.tl);
                var match$6 = as_one_then_many("generator name followed by parameters", as_list("generator name and parameters", match$5[0]).it);
                var fun$1 = as_id("a generator name", match$6[0]);
                var args$1 = Core__List.map(match$6[1], (function (arg) {
                        return as_id("a parameter", arg);
                      }));
                var terms$2 = Belt_List.map(match$5[1], parseTerm);
                var result$2 = as_expr("an expression to be returned", parseTerm(match$5[2]));
                var it_2$1 = makeBlock(terms$2, result$2);
                var it$2 = {
                  TAG: "GFun",
                  _0: fun$1,
                  _1: args$1,
                  _2: it_2$1
                };
                tmp = {
                  TAG: "Def",
                  _0: {
                    it: it$2,
                    ann: e.ann
                  }
                };
                break;
            case "defvar" :
                var match$7 = as_two("a variable and an expression", es.tl);
                var x = as_id("a variable name", match$7[0]);
                var e$1 = as_expr("an expression", parseTerm(match$7[1]));
                tmp = {
                  TAG: "Def",
                  _0: {
                    it: {
                      TAG: "Var",
                      _0: x,
                      _1: e$1
                    },
                    ann: e.ann
                  }
                };
                break;
            case "empty?" :
                tmp = makeAppPrm(ann, "EmptyP", es.tl);
                break;
            case "eq?" :
                tmp = makeAppPrm(ann, {
                      TAG: "Cmp",
                      _0: "Eq"
                    }, es.tl);
                break;
            case "error" :
                tmp = makeAppPrm(ann, "Err", es.tl);
                break;
            case "first" :
                tmp = makeAppPrm(ann, "First", es.tl);
                break;
            case "generator" :
                var match$8 = as_one_then_many_then_one("the generator signature followed by the function body", es.tl);
                var args$2 = Core__List.map(as_list("generator parameters", match$8[0]).it, (function (arg) {
                        return as_id("a parameter", arg);
                      }));
                var terms$3 = Core__List.map(match$8[1], parseTerm);
                var result$3 = as_expr("an expression to be returned", parseTerm(match$8[2]));
                var it_1 = makeBlock(terms$3, result$3);
                var it$3 = {
                  TAG: "GLam",
                  _0: args$2,
                  _1: it_1
                };
                tmp = {
                  TAG: "Exp",
                  _0: {
                    it: it$3,
                    ann: e.ann
                  }
                };
                break;
            case "if" :
                var match$9 = as_three("three expressions (i.e., a condition, the \"then\" branch, and the \"else\" branch)", es.tl);
                var e_cnd = as_expr("a (conditional) expression", parseTerm(match$9[0]));
                var e_thn = as_expr("an expression", parseTerm(match$9[1]));
                var e_els = as_expr("an expression", parseTerm(match$9[2]));
                tmp = {
                  TAG: "Exp",
                  _0: {
                    it: {
                      TAG: "If",
                      _0: e_cnd,
                      _1: e_thn,
                      _2: e_els
                    },
                    ann: e.ann
                  }
                };
                break;
            case "lambda" :
                var match$10 = as_one_then_many_then_one("the function signature followed by the function body", es.tl);
                var args$3 = Core__List.map(as_list("function parameters", match$10[0]).it, (function (arg) {
                        return as_id("a parameter", arg);
                      }));
                var terms$4 = Core__List.map(match$10[1], parseTerm);
                var result$4 = as_expr("an expression to be returned", parseTerm(match$10[2]));
                var it_1$1 = makeBlock(terms$4, result$4);
                var it$4 = {
                  TAG: "Lam",
                  _0: args$3,
                  _1: it_1$1
                };
                tmp = {
                  TAG: "Exp",
                  _0: {
                    it: it$4,
                    ann: e.ann
                  }
                };
                break;
            case "left" :
                tmp = makeAppPrm(ann, "PairRefLeft", es.tl);
                break;
            case "let" :
                tmp = parseLet("Plain", ann, es.tl);
                break;
            case "let*" :
                tmp = parseLet("Nested", ann, es.tl);
                break;
            case "letrec" :
                tmp = parseLet("Recursive", ann, es.tl);
                break;
            case "list" :
                tmp = makeAppPrm(ann, "List", es.tl);
                break;
            case "maybe?" :
                tmp = makeAppPrm(ann, "Maybe", es.tl);
                break;
            case "next" :
                tmp = makeAppPrm(ann, "Next", es.tl);
                break;
            case "not" :
                tmp = makeAppPrm(ann, "Not", es.tl);
                break;
            case "or" :
                var e_ns$1 = Core__List.map(Core__List.map(es.tl, parseTerm), (function (e) {
                        return as_expr("an expression", e);
                      }));
                tmp = {
                  TAG: "Exp",
                  _0: {
                    it: {
                      TAG: "Or",
                      _0: e_ns$1
                    },
                    ann: e.ann
                  }
                };
                break;
            case "mpair" :
            case "pair" :
                tmp = makeAppPrm(ann, "PairNew", es.tl);
                break;
            case "print" :
                tmp = makeAppPrm(ann, "Print", es.tl);
                break;
            case "quote" :
                var e$2 = as_one("a quoted value", es.tl);
                tmp = {
                  TAG: "Exp",
                  _0: parseValue(e$2)
                };
                break;
            case "rest" :
                tmp = makeAppPrm(ann, "Rest", es.tl);
                break;
            case "right" :
                tmp = makeAppPrm(ann, "PairRefRight", es.tl);
                break;
            case "set!" :
                var match$11 = as_two("a variable and an expression", es.tl);
                var x$1 = as_id("a variable to be set", match$11[0]);
                var e$3 = as_expr("an expression", parseTerm(match$11[1]));
                tmp = {
                  TAG: "Exp",
                  _0: {
                    it: {
                      TAG: "Set",
                      _0: x$1,
                      _1: e$3
                    },
                    ann: e.ann
                  }
                };
                break;
            case "set-left!" :
                tmp = makeAppPrm(ann, "PairSetLeft", es.tl);
                break;
            case "set-right!" :
                tmp = makeAppPrm(ann, "PairSetRight", es.tl);
                break;
            case "equal?" :
            case "string=?" :
                tmp = makeAppPrm(ann, {
                      TAG: "Cmp",
                      _0: "Equal"
                    }, es.tl);
                break;
            case "ivec" :
            case "mvec" :
            case "vec" :
                exit$1 = 2;
                break;
            case "vec-len" :
            case "vlen" :
                tmp = makeAppPrm(ann, "VecLen", es.tl);
                break;
            case "vec-ref" :
            case "vref" :
                tmp = makeAppPrm(ann, "VecRef", es.tl);
                break;
            case "vec-set!" :
            case "vset!" :
                tmp = makeAppPrm(ann, "VecSet", es.tl);
                break;
            case "yield" :
                var e$4 = as_one("an expression", es.tl);
                var e$5 = as_expr("an expression", parseTerm(e$4));
                tmp = {
                  TAG: "Exp",
                  _0: {
                    it: {
                      TAG: "Yield",
                      _0: e$5
                    },
                    ann: e.ann
                  }
                };
                break;
            case "zero?" :
                tmp = makeAppPrm(ann, "ZeroP", es.tl);
                break;
            case "Î»" :
                var match$12 = as_one_then_many_then_one("the function signature followed by the function body", es.tl);
                var args$4 = Core__List.map(as_list("function parameters", match$12[0]).it, (function (arg) {
                        return as_id("a parameter", arg);
                      }));
                var terms$5 = Core__List.map(match$12[1], parseTerm);
                var result$5 = as_expr("an expression to be returned", parseTerm(match$12[2]));
                var it_1$2 = makeBlock(terms$5, result$5);
                var it$5 = {
                  TAG: "Lam",
                  _0: args$4,
                  _1: it_1$2
                };
                tmp = {
                  TAG: "Exp",
                  _0: {
                    it: it$5,
                    ann: e.ann
                  }
                };
                break;
            default:
              exit = 1;
          }
          if (exit$1 === 2) {
            tmp = makeAppPrm(ann, "VecNew", es.tl);
          }
          
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var match$13 = as_one_then_many("a function call/application, which includes a function and then zero or more arguments", es);
      var e$6 = as_expr("a function", parseTerm(match$13[0]));
      var es$1 = Core__List.map(Core__List.map(match$13[1], parseTerm), (function (e) {
              return as_expr("an argument", e);
            }));
      tmp = {
        TAG: "Exp",
        _0: {
          it: {
            TAG: "App",
            _0: e$6,
            _1: es$1
          },
          ann: e.ann
        }
      };
    }
    
  } else {
    var content = Core__List.map(atom.content, parseValue);
    tmp = {
      TAG: "Exp",
      _0: {
        it: {
          TAG: "AppPrm",
          _0: "VecNew",
          _1: content
        },
        ann: e.ann
      }
    };
  }
  return ann(tmp);
}

function makeAppPrm(ann, p, es) {
  var es$1 = Core__List.map(Core__List.map(es, parseTerm), (function (e) {
          return as_expr("an argument", e);
        }));
  return {
          TAG: "Exp",
          _0: ann({
                TAG: "AppPrm",
                _0: p,
                _1: es$1
              })
        };
}

function parseTerms(src) {
  try {
    return Core__List.map(SExpression.SExpr.fromString(true, src), parseTerm);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SExpression.SExpressionError) {
      var err$1 = {
        TAG: "SExprParseError",
        _0: SExpression.$$Error.toString(err._1)
      };
      throw {
            RE_EXN_ID: SMoLParseError,
            _1: err$1,
            Error: new Error()
          };
    }
    throw err;
  }
}

function parseProgram(src) {
  var ts = parseTerms(src);
  return makeProgram(ts);
}

function parseOutput(src) {
  try {
    return Core__List.map(SExpression.SExpr.fromString(undefined, src), outputletOfSExpr);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SExpression.SExpressionError) {
      var err$1 = {
        TAG: "SExprParseError",
        _0: SExpression.$$Error.toString(err._1)
      };
      throw {
            RE_EXN_ID: SMoLParseError,
            _1: err$1,
            Error: new Error()
          };
    }
    throw err;
  }
}

var SMoLPrintError = /* @__PURE__ */Caml_exceptions.create("SMoL.SMoLPrintError");

function toString$8(param) {
  return toString$3(param.nodeKind) + "-" + SExpression.SourceLocation.toString(param.sourceLocation);
}

var KindedSourceLocation = {
  toString: toString$8
};

function indent(t, i) {
  var pad = Js_string.repeat(i, " ");
  return map(function (s) {
                return Js_string.replaceByRe(/\n/g, "\n" + pad, s);
              })(t);
}

function indentBlock(s, i) {
  return indent({
              it: {
                TAG: "Group",
                _0: {
                  hd: {
                    it: {
                      TAG: "Plain",
                      _0: "\n"
                    },
                    ann: undefined
                  },
                  tl: {
                    hd: s,
                    tl: /* [] */0
                  }
                }
              },
              ann: undefined
            }, i);
}

function hcat(p1, s, p2) {
  return {
          TAG: "Group",
          _0: {
            hd: p1,
            tl: {
              hd: {
                it: {
                  TAG: "Plain",
                  _0: s
                },
                ann: undefined
              },
              tl: {
                hd: indent(p2, toString(p1).length + s.length | 0),
                tl: /* [] */0
              }
            }
          }
        };
}

function printName(x) {
  return x;
}

function constantToString(c) {
  if (typeof c !== "object") {
    if (c === "Uni") {
      return "#<void>";
    } else {
      return "#<empty>";
    }
  }
  switch (c.TAG) {
    case "Num" :
        return c._0.toString();
    case "Lgc" :
        if (c._0) {
          return "#t";
        } else {
          return "#f";
        }
    case "Str" :
        return JSON.stringify(c._0);
    case "Sym" :
        return c._0;
    
  }
}

function plainList(es) {
  return s([
              "(",
              ")"
            ], [{
                it: concat(" ", es),
                ann: undefined
              }]);
}

function bindsLikeList(es) {
  return s([
              "(",
              ")"
            ], [indent({
                    it: concat("\n", es),
                    ann: undefined
                  }, 1)]);
}

function appLikeList(e1, es) {
  if (Core__List.some(es, containsNL)) {
    return s([
                "(",
                ")"
              ], [{
                  it: hcat(e1, " ", {
                        it: concat("\n", es),
                        ann: undefined
                      }),
                  ann: undefined
                }]);
  } else {
    return s([
                "(",
                ")"
              ], [{
                  it: concat(" ", {
                        hd: e1,
                        tl: es
                      }),
                  ann: undefined
                }]);
  }
}

function beginLikeList(e1, es) {
  return s([
              "(",
              "",
              ")"
            ], [
              e1,
              indentBlock({
                    it: concat("\n", es),
                    ann: undefined
                  }, 2)
            ]);
}

function letLikeList(e1, e2, e3) {
  return s([
              "(",
              "",
              ")"
            ], [
              {
                it: hcat(e1, " ", e2),
                ann: undefined
              },
              indentBlock(e3, 2)
            ]);
}

function defvarLikeList(e1, e2, e3) {
  if (includes(e2, "\n") || includes(e3, "\n")) {
    return letLikeList(e1, e2, e3);
  } else {
    return s([
                "(",
                " ",
                " ",
                ")"
              ], [
                e1,
                e2,
                e3
              ]);
  }
}

function defvarToString(x, e) {
  return defvarLikeList({
              it: {
                TAG: "Plain",
                _0: "defvar"
              },
              ann: undefined
            }, x, e);
}

function deffunToString(f, xs, b) {
  return letLikeList({
              it: {
                TAG: "Plain",
                _0: "deffun"
              },
              ann: undefined
            }, {
              it: appLikeList(f, xs),
              ann: undefined
            }, b);
}

function defgenToString(f, xs, b) {
  return letLikeList({
              it: {
                TAG: "Plain",
                _0: "defgen"
              },
              ann: undefined
            }, {
              it: appLikeList(f, xs),
              ann: undefined
            }, b);
}

function exprSetToString(x, e) {
  return defvarLikeList({
              it: {
                TAG: "Plain",
                _0: "set!"
              },
              ann: undefined
            }, x, e);
}

function exprLamToString(xs, b) {
  return defvarLikeList({
              it: {
                TAG: "Plain",
                _0: "lambda"
              },
              ann: undefined
            }, {
              it: plainList(xs),
              ann: undefined
            }, b);
}

function exprGLamToString(xs, b) {
  return defvarLikeList({
              it: {
                TAG: "Plain",
                _0: "generator"
              },
              ann: undefined
            }, {
              it: plainList(xs),
              ann: undefined
            }, b);
}

function exprYieldToString(e) {
  return appLikeList({
              it: {
                TAG: "Plain",
                _0: "yield"
              },
              ann: undefined
            }, {
              hd: e,
              tl: /* [] */0
            });
}

function exprBgnToString(es, e) {
  return beginLikeList({
              it: {
                TAG: "Plain",
                _0: "begin"
              },
              ann: undefined
            }, Belt_List.concatMany([
                  es,
                  {
                    hd: e,
                    tl: /* [] */0
                  }
                ]));
}

function exprCndToString(ebs, ob) {
  var ebs$1 = ob !== undefined ? Belt_List.concatMany([
          ebs,
          {
            hd: [
              {
                it: {
                  TAG: "Plain",
                  _0: "else"
                },
                ann: undefined
              },
              ob
            ],
            tl: /* [] */0
          }
        ]) : ebs;
  var ebs$2 = Core__List.map(ebs$1, (function (param) {
          var ss_0 = {
            it: {
              TAG: "Plain",
              _0: "["
            },
            ann: undefined
          };
          var ss_1 = {
            hd: param[0],
            tl: {
              hd: indentBlock(param[1], 1),
              tl: {
                hd: {
                  it: {
                    TAG: "Plain",
                    _0: "]"
                  },
                  ann: undefined
                },
                tl: /* [] */0
              }
            }
          };
          var ss = {
            hd: ss_0,
            tl: ss_1
          };
          return {
                  it: {
                    TAG: "Group",
                    _0: ss
                  },
                  ann: undefined
                };
        }));
  return beginLikeList({
              it: {
                TAG: "Plain",
                _0: "cond"
              },
              ann: undefined
            }, ebs$2);
}

function exprIfToString(e_cnd, e_thn, e_els) {
  return appLikeList({
              it: {
                TAG: "Plain",
                _0: "if"
              },
              ann: undefined
            }, {
              hd: e_cnd,
              tl: {
                hd: e_thn,
                tl: {
                  hd: e_els,
                  tl: /* [] */0
                }
              }
            });
}

function exprAndToString(e_ns) {
  return appLikeList({
              it: s(["and"], []),
              ann: undefined
            }, e_ns);
}

function exprOrToString(e_ns) {
  return appLikeList({
              it: s(["or"], []),
              ann: undefined
            }, e_ns);
}

function symbolToString(param) {
  var sourceLocation = param.ann;
  var it = param.it;
  return {
          it: it,
          ann: {
            sourceLocation: sourceLocation,
            print: {
              it: {
                TAG: "Plain",
                _0: it
              },
              ann: {
                nodeKind: "Name",
                sourceLocation: sourceLocation
              }
            }
          }
        };
}

function printExp(param) {
  var sourceLocation = param.ann;
  var it = param.it;
  var e;
  switch (it.TAG) {
    case "Con" :
        var c = it._0;
        e = {
          it: {
            TAG: "Con",
            _0: c
          },
          ann: {
            TAG: "Plain",
            _0: constantToString(c)
          }
        };
        break;
    case "Ref" :
        var x = it._0;
        e = {
          it: {
            TAG: "Ref",
            _0: x
          },
          ann: {
            TAG: "Plain",
            _0: x
          }
        };
        break;
    case "Set" :
        var x$1 = symbolToString(it._0);
        var e$1 = printExp(it._1);
        e = {
          it: {
            TAG: "Set",
            _0: x$1,
            _1: e$1
          },
          ann: exprSetToString(x$1.ann.print, e$1.ann.print)
        };
        break;
    case "Lam" :
        var xs = Core__List.map(it._0, symbolToString);
        var b = printBlock(it._1);
        e = {
          it: {
            TAG: "Lam",
            _0: xs,
            _1: b
          },
          ann: exprLamToString(Core__List.map(xs, (function (x) {
                      return x.ann.print;
                    })), b.ann.print)
        };
        break;
    case "Let" :
        var kind = it._0;
        var xes = Core__List.map(it._1, xeToString);
        var b$1 = printBlock(it._2);
        var it$1 = toString$2(kind);
        e = {
          it: {
            TAG: "Let",
            _0: kind,
            _1: xes,
            _2: b$1
          },
          ann: letLikeList({
                it: {
                  TAG: "Plain",
                  _0: it$1
                },
                ann: undefined
              }, {
                it: bindsLikeList(Core__List.map(xes, (function (xe) {
                            return xe.ann.print;
                          }))),
                ann: undefined
              }, b$1.ann.print)
        };
        break;
    case "AppPrm" :
        var p = it._0;
        var es = Core__List.map(it._1, printExp);
        var it$2 = toString$1(p);
        e = {
          it: {
            TAG: "AppPrm",
            _0: p,
            _1: es
          },
          ann: appLikeList({
                it: {
                  TAG: "Plain",
                  _0: it$2
                },
                ann: undefined
              }, Core__List.map(es, (function (e) {
                      return e.ann.print;
                    })))
        };
        break;
    case "App" :
        var e$2 = printExp(it._0);
        var es$1 = Core__List.map(it._1, printExp);
        e = {
          it: {
            TAG: "App",
            _0: e$2,
            _1: es$1
          },
          ann: appLikeList(e$2.ann.print, Core__List.map(es$1, (function (e) {
                      return e.ann.print;
                    })))
        };
        break;
    case "Bgn" :
        var es$2 = Core__List.map(it._0, printExp);
        var e$3 = printExp(it._1);
        e = {
          it: {
            TAG: "Bgn",
            _0: es$2,
            _1: e$3
          },
          ann: exprBgnToString(Core__List.map(es$2, (function (e) {
                      return e.ann.print;
                    })), e$3.ann.print)
        };
        break;
    case "If" :
        var e_cnd = printExp(it._0);
        var e_thn = printExp(it._1);
        var e_els = printExp(it._2);
        e = {
          it: {
            TAG: "If",
            _0: e_cnd,
            _1: e_thn,
            _2: e_els
          },
          ann: exprIfToString(e_cnd.ann.print, e_thn.ann.print, e_els.ann.print)
        };
        break;
    case "And" :
        var e_ns = Core__List.map(it._0, (function (e_k) {
                return printExp(e_k);
              }));
        e = {
          it: {
            TAG: "And",
            _0: e_ns
          },
          ann: exprAndToString(Core__List.map(e_ns, (function (e_k) {
                      return e_k.ann.print;
                    })))
        };
        break;
    case "Or" :
        var e_ns$1 = Core__List.map(it._0, (function (e_k) {
                return printExp(e_k);
              }));
        e = {
          it: {
            TAG: "Or",
            _0: e_ns$1
          },
          ann: exprOrToString(Core__List.map(e_ns$1, (function (e_k) {
                      return e_k.ann.print;
                    })))
        };
        break;
    case "Cnd" :
        var ebs = Core__List.map(it._0, ebToString);
        var ob = Core__Option.map(it._1, printBlock);
        e = {
          it: {
            TAG: "Cnd",
            _0: ebs,
            _1: ob
          },
          ann: exprCndToString(Core__List.map(ebs, (function (param) {
                      return [
                              param[0].ann.print,
                              param[1].ann.print
                            ];
                    })), Core__Option.map(ob, (function (b) {
                      return b.ann.print;
                    })))
        };
        break;
    case "GLam" :
        var xs$1 = Core__List.map(it._0, symbolToString);
        var b$2 = printBlock(it._1);
        e = {
          it: {
            TAG: "Lam",
            _0: xs$1,
            _1: b$2
          },
          ann: exprGLamToString(Core__List.map(xs$1, (function (x) {
                      return x.ann.print;
                    })), b$2.ann.print)
        };
        break;
    case "Yield" :
        var e$4 = printExp(it._0);
        e = {
          it: {
            TAG: "Yield",
            _0: e$4
          },
          ann: exprYieldToString(e$4.ann.print)
        };
        break;
    
  }
  return {
          it: e.it,
          ann: {
            sourceLocation: sourceLocation,
            print: {
              it: e.ann,
              ann: {
                nodeKind: "Expression",
                sourceLocation: sourceLocation
              }
            }
          }
        };
}

function printDef(param) {
  var sourceLocation = param.ann;
  var d = param.it;
  var d$1;
  switch (d.TAG) {
    case "Var" :
        var x = symbolToString(d._0);
        var e = printExp(d._1);
        d$1 = {
          it: {
            TAG: "Var",
            _0: x,
            _1: e
          },
          ann: defvarToString(x.ann.print, e.ann.print)
        };
        break;
    case "Fun" :
        var f = symbolToString(d._0);
        var xs = Core__List.map(d._1, symbolToString);
        var b = printBlock(d._2);
        d$1 = {
          it: {
            TAG: "Fun",
            _0: f,
            _1: xs,
            _2: b
          },
          ann: deffunToString(f.ann.print, Core__List.map(xs, (function (x) {
                      return x.ann.print;
                    })), b.ann.print)
        };
        break;
    case "GFun" :
        var f$1 = symbolToString(d._0);
        var xs$1 = Core__List.map(d._1, symbolToString);
        var b$1 = printBlock(d._2);
        d$1 = {
          it: {
            TAG: "GFun",
            _0: f$1,
            _1: xs$1,
            _2: b$1
          },
          ann: defgenToString(f$1.ann.print, Core__List.map(xs$1, (function (x) {
                      return x.ann.print;
                    })), b$1.ann.print)
        };
        break;
    
  }
  return {
          it: d$1.it,
          ann: {
            sourceLocation: sourceLocation,
            print: {
              it: d$1.ann,
              ann: {
                nodeKind: "Definition",
                sourceLocation: sourceLocation
              }
            }
          }
        };
}

function xeToString(param) {
  var xe = param.it;
  var sourceLocation = param.ann;
  var x = symbolToString(xe[0]);
  var e = printExp(xe[1]);
  var print = s([
        "[",
        "]"
      ], [{
          it: hcat(x.ann.print, " ", e.ann.print),
          ann: undefined
        }]);
  return {
          it: [
            x,
            e
          ],
          ann: {
            sourceLocation: sourceLocation,
            print: {
              it: print,
              ann: {
                nodeKind: "Bind",
                sourceLocation: sourceLocation
              }
            }
          }
        };
}

function ebToString(eb) {
  return [
          printExp(eb[0]),
          printBlock(eb[1])
        ];
}

function printBlock(param) {
  var sourceLocation = param.ann;
  var b = param.it;
  var annPrint = function (p) {
    return {
            it: p,
            ann: {
              nodeKind: "Block",
              sourceLocation: sourceLocation
            }
          };
  };
  if (b.TAG === "BRet") {
    var e = printExp(b._0);
    return {
            it: {
              TAG: "BRet",
              _0: e
            },
            ann: {
              sourceLocation: e.ann.sourceLocation,
              print: annPrint(s([
                        "",
                        ""
                      ], [e.ann.print]))
            }
          };
  }
  var t = printTerm(b._0);
  var b$1 = printBlock(b._1);
  var print = annPrint(s([
            "",
            "\n",
            ""
          ], [
            t.ann.print,
            b$1.ann.print
          ]));
  return {
          it: {
            TAG: "BCons",
            _0: t,
            _1: b$1
          },
          ann: {
            sourceLocation: sourceLocation,
            print: print
          }
        };
}

function printTerm(param) {
  var sourceLocation = param.ann;
  var t = param.it;
  var annPrint = function (p) {
    return {
            it: p,
            ann: {
              nodeKind: "Term",
              sourceLocation: sourceLocation
            }
          };
  };
  if (t.TAG === "Def") {
    var it = printDef(t._0);
    return {
            it: {
              TAG: "Def",
              _0: it
            },
            ann: {
              sourceLocation: sourceLocation,
              print: annPrint({
                    TAG: "Group",
                    _0: {
                      hd: it.ann.print,
                      tl: /* [] */0
                    }
                  })
            }
          };
  }
  var it$1 = printExp(t._0);
  return {
          it: {
            TAG: "Exp",
            _0: it$1
          },
          ann: {
            sourceLocation: sourceLocation,
            print: annPrint({
                  TAG: "Group",
                  _0: {
                    hd: it$1.ann.print,
                    tl: /* [] */0
                  }
                })
          }
        };
}

function printOutputlet(o) {
  var p = function (v) {
    switch (v.TAG) {
      case "Ref" :
          return "#" + v._0.toString() + "#";
      case "Con" :
          return constantToString(v._0);
      case "Struct" :
          var content = v._1;
          var i = v._0;
          var i$1 = i !== undefined ? "#" + i.toString() + "=" : "";
          var content$1;
          content$1 = content.TAG === "Lst" ? "(" + Core__List.toArray(Core__List.map(content._0, p)).join(" ") + ")" : "#(" + Core__List.toArray(Core__List.map(content._0, p)).join(" ") + ")";
          return i$1 + content$1;
      
    }
  };
  if (typeof o !== "object") {
    return "error";
  } else {
    return p(o._0);
  }
}

function printOutput(sepOpt, os) {
  var sep = sepOpt !== undefined ? sepOpt : " ";
  return Core__List.toArray(Core__List.map(os, printOutputlet)).join(sep);
}

function printProgramFull(_insertPrintTopLevel, p) {
  var print = function (param) {
    var sourceLocation = param.ann;
    var it = param.it;
    var annPrint = function (it) {
      return {
              it: it,
              ann: {
                nodeKind: "Program",
                sourceLocation: sourceLocation
              }
            };
    };
    if (typeof it !== "object") {
      return {
              it: "PNil",
              ann: {
                sourceLocation: sourceLocation,
                print: {
                  it: {
                    TAG: "Group",
                    _0: /* [] */0
                  },
                  ann: {
                    nodeKind: "Program",
                    sourceLocation: sourceLocation
                  }
                }
              }
            };
    }
    var p = it._1;
    var t = printTerm(it._0);
    var tmp = p.it;
    if (typeof tmp !== "object") {
      return {
              it: {
                TAG: "PCons",
                _0: t,
                _1: {
                  it: "PNil",
                  ann: {
                    sourceLocation: {
                      begin: sourceLocation.end,
                      end: sourceLocation.end
                    },
                    print: {
                      it: {
                        TAG: "Plain",
                        _0: ""
                      },
                      ann: {
                        nodeKind: "Program",
                        sourceLocation: sourceLocation
                      }
                    }
                  }
                }
              },
              ann: {
                sourceLocation: sourceLocation,
                print: annPrint({
                      TAG: "Group",
                      _0: {
                        hd: t.ann.print,
                        tl: /* [] */0
                      }
                    })
              }
            };
    }
    var p$1 = print(p);
    return {
            it: {
              TAG: "PCons",
              _0: t,
              _1: p$1
            },
            ann: {
              sourceLocation: sourceLocation,
              print: annPrint(concat2(t.ann.print, "\n", p$1.ann.print))
            }
          };
  };
  return print(p);
}

function printProgram(insertPrintTopLevel, p) {
  return toString(printProgramFull(insertPrintTopLevel, p).ann.print);
}

function printStandAloneTerm(t) {
  return toString(printTerm(t).ann.print);
}

function moveBeginChByOne(sourceLocation) {
  var init = sourceLocation.begin;
  return {
          begin: {
            ln: init.ln,
            ch: sourceLocation.begin.ch + 1 | 0
          },
          end: sourceLocation.end
        };
}

function insertTopLevelPrint(p) {
  var match = p.it;
  var tmp;
  if (typeof match !== "object") {
    tmp = "PNil";
  } else {
    var t = match._0;
    var e = t.it;
    var tmp$1;
    if (e.TAG === "Def") {
      tmp$1 = e;
    } else {
      var ie = function (e) {
        var ib = function (b) {
          var e = b.it;
          var tmp;
          tmp = e.TAG === "BRet" ? ({
                TAG: "BRet",
                _0: ie(e._0)
              }) : ({
                TAG: "BCons",
                _0: e._0,
                _1: ib(e._1)
              });
          return {
                  it: tmp,
                  ann: b.ann
                };
        };
        var ieb = function (param) {
          return [
                  param[0],
                  ib(param[1])
                ];
        };
        var e$1 = e.it;
        var tmp;
        var exit = 0;
        switch (e$1.TAG) {
          case "Set" :
              tmp = {
                TAG: "Set",
                _0: e$1._0,
                _1: e$1._1
              };
              break;
          case "Let" :
              tmp = {
                TAG: "Let",
                _0: e$1._0,
                _1: e$1._1,
                _2: ib(e$1._2)
              };
              break;
          case "AppPrm" :
              var tmp$1 = e$1._0;
              if (typeof tmp$1 !== "object") {
                switch (tmp$1) {
                  case "PairSetLeft" :
                      tmp = {
                        TAG: "AppPrm",
                        _0: "PairSetLeft",
                        _1: e$1._1
                      };
                      break;
                  case "PairSetRight" :
                      tmp = {
                        TAG: "AppPrm",
                        _0: "PairSetRight",
                        _1: e$1._1
                      };
                      break;
                  case "VecSet" :
                      tmp = {
                        TAG: "AppPrm",
                        _0: "VecSet",
                        _1: e$1._1
                      };
                      break;
                  case "Err" :
                      tmp = {
                        TAG: "AppPrm",
                        _0: "Err",
                        _1: e$1._1
                      };
                      break;
                  case "Print" :
                      tmp = {
                        TAG: "AppPrm",
                        _0: "Print",
                        _1: e$1._1
                      };
                      break;
                  default:
                    exit = 1;
                }
              } else {
                exit = 1;
              }
              break;
          case "Bgn" :
              tmp = {
                TAG: "Bgn",
                _0: e$1._0,
                _1: ie(e$1._1)
              };
              break;
          case "If" :
              tmp = {
                TAG: "If",
                _0: e$1._0,
                _1: ie(e$1._1),
                _2: ie(e$1._2)
              };
              break;
          case "Cnd" :
              tmp = {
                TAG: "Cnd",
                _0: Core__List.map(e$1._0, ieb),
                _1: Core__Option.map(e$1._1, ib)
              };
              break;
          case "Yield" :
              tmp = {
                TAG: "Yield",
                _0: e$1._0
              };
              break;
          default:
            exit = 1;
        }
        if (exit === 1) {
          tmp = {
            TAG: "AppPrm",
            _0: "Print",
            _1: {
              hd: {
                it: e$1,
                ann: moveBeginChByOne(t.ann)
              },
              tl: /* [] */0
            }
          };
        }
        return {
                it: tmp,
                ann: e.ann
              };
      };
      tmp$1 = {
        TAG: "Exp",
        _0: ie(e._0)
      };
    }
    var t_ann = t.ann;
    var t$1 = {
      it: tmp$1,
      ann: t_ann
    };
    tmp = {
      TAG: "PCons",
      _0: t$1,
      _1: insertTopLevelPrint(match._1)
    };
  }
  return {
          it: tmp,
          ann: p.ann
        };
}

function toString$9(x) {
  if (x === "Nonlocal") {
    return "nonlocal";
  } else {
    return "global";
  }
}

function refMut(env, x) {
  if (env.TAG === "G") {
    return ;
  }
  var decl = env._2;
  if (!Belt_HashSetString.has(env._0, x)) {
    var _env = env._1;
    while(true) {
      var env$1 = _env;
      if (env$1.TAG === "G") {
        if (Belt_HashSetString.has(env$1._0, x)) {
          return Belt_HashMapString.set(decl, x, "Global");
        } else {
          return ;
        }
      }
      if (Belt_HashSetString.has(env$1._0, x)) {
        return Belt_HashMapString.set(decl, x, "Nonlocal");
      }
      _env = env$1._1;
      continue ;
    };
  }
  
}

function extend(ss, env) {
  var refs = Belt_HashMapString.make(0);
  return [
          refs,
          {
            TAG: "E",
            _0: Belt_HashSetString.fromArray(Belt_List.toArray(ss)),
            _1: env,
            _2: refs
          }
        ];
}

function printName$1(x) {
  var re = /-/g;
  var matchFn = function (_matchPart, _offset, _wholeString) {
    return "_";
  };
  return x.replace(re, matchFn);
}

function constantToString$1(c) {
  if (typeof c !== "object") {
    if (c === "Uni") {
      return "None";
    }
    throw {
          RE_EXN_ID: SMoLPrintError,
          _1: "Lists are not supported in Python.",
          Error: new Error()
        };
  } else {
    switch (c.TAG) {
      case "Num" :
          return String(c._0);
      case "Lgc" :
          if (c._0) {
            return "True";
          } else {
            return "False";
          }
      case "Str" :
          return JSON.stringify(c._0);
      case "Sym" :
          return c._0;
      
    }
  }
}

function listToString(es) {
  if (Belt_List.some(es, containsNL)) {
    return {
            TAG: "Group",
            _0: {
              hd: {
                it: {
                  TAG: "Plain",
                  _0: "("
                },
                ann: undefined
              },
              tl: {
                hd: indentBlock({
                      it: concat(",\n", es),
                      ann: undefined
                    }, 4),
                tl: {
                  hd: {
                    it: {
                      TAG: "Plain",
                      _0: ")"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          };
  } else {
    return {
            TAG: "Group",
            _0: {
              hd: {
                it: {
                  TAG: "Plain",
                  _0: "("
                },
                ann: undefined
              },
              tl: {
                hd: {
                  it: concat(", ", es),
                  ann: undefined
                },
                tl: {
                  hd: {
                    it: {
                      TAG: "Plain",
                      _0: ")"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          };
  }
}

function defvarLike(op, x, e) {
  return {
          TAG: "Group",
          _0: {
            hd: {
              it: {
                TAG: "Plain",
                _0: op
              },
              ann: undefined
            },
            tl: {
              hd: x,
              tl: {
                hd: {
                  it: {
                    TAG: "Plain",
                    _0: " = "
                  },
                  ann: undefined
                },
                tl: {
                  hd: e,
                  tl: /* [] */0
                }
              }
            }
          }
        };
}

function exprAppToString(e, es) {
  return {
          TAG: "Group",
          _0: {
            hd: e,
            tl: {
              hd: {
                it: listToString(es),
                ann: undefined
              },
              tl: /* [] */0
            }
          }
        };
}

function consumeContext(ctx, ann, e) {
  var e$1 = ann(e);
  if (ctx.TAG === "Expr" || ctx._0 === "Step") {
    return e$1;
  } else {
    return {
            it: s([
                  "return ",
                  ""
                ], [e$1]),
            ann: undefined
          };
  }
}

function paren(e) {
  return s([
              "(",
              ")"
            ], [{
                it: e,
                ann: undefined
              }]);
}

function consumeContextWrapEvenReturn(ctx, ann, e) {
  if (ctx.TAG === "Expr") {
    if (ctx._0) {
      return ann(paren(e));
    } else {
      return ann(e);
    }
  } else if (ctx._0 === "Step") {
    return ann(e);
  } else {
    return {
            it: s([
                  "return ",
                  ""
                ], [ann(paren(e))]),
            ann: undefined
          };
  }
}

function consumeContextWrap(ctx, ann, e) {
  if (ctx.TAG === "Expr") {
    if (ctx._0) {
      return ann(paren(e));
    } else {
      return ann(e);
    }
  } else if (ctx._0 === "Step") {
    return ann(e);
  } else {
    return {
            it: s([
                  "return ",
                  ""
                ], [ann(e)]),
            ann: undefined
          };
  }
}

function consumeContextVoid(ctx, ann, e) {
  var e$1 = ann(e);
  if (ctx.TAG === "Expr" || ctx._0 === "Step") {
    return e$1;
  } else {
    return {
            it: s([
                  "",
                  "\nreturn"
                ], [e$1]),
            ann: undefined
          };
  }
}

function consumeContextEscapeWrap(ctx, ann, e) {
  return ann(e);
}

function consumeContextStat(ctx, ann, e) {
  var e$1 = ann(e);
  if (ctx.TAG !== "Expr") {
    if (ctx._0 === "Step") {
      return e$1;
    } else {
      return {
              it: s([
                    "",
                    "\nreturn"
                  ], [e$1]),
              ann: undefined
            };
    }
  }
  var err = toString(e$1) + " can't be used as a expression in Python";
  throw {
        RE_EXN_ID: SMoLPrintError,
        _1: err,
        Error: new Error()
      };
}

function stringOfArith(o) {
  switch (o) {
    case "Add" :
        return "+";
    case "Sub" :
        return "-";
    case "Mul" :
        return "*";
    case "Div" :
        return "/";
    
  }
}

function stringOfCmp(o) {
  switch (o) {
    case "Lt" :
        return "<";
    case "Eq" :
        return "is";
    case "Gt" :
        return ">";
    case "Le" :
        return "<=";
    case "Ge" :
        return ">=";
    case "Ne" :
        return "!=";
    case "NumEq" :
    case "Equal" :
        return "==";
    
  }
}

function exprAppPrmToString(ann, ctx, p, es) {
  if (typeof p !== "object") {
    switch (p) {
      case "PairNew" :
          if (es) {
            var match = es.tl;
            if (match && !match.tl) {
              var e1 = es.hd(false);
              var e2 = match.hd(false);
              return {
                      it: [
                        "PairNew",
                        {
                          hd: e1,
                          tl: {
                            hd: e2,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContext(ctx, ann, s([
                                "[ ",
                                ", ",
                                " ]"
                              ], [
                                e1.ann.print,
                                e2.ann.print
                              ]))
                    };
            }
            
          }
          break;
      case "PairRefLeft" :
          if (es && !es.tl) {
            var e1$1 = es.hd(true);
            return {
                    it: [
                      "PairRefLeft",
                      {
                        hd: e1$1,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext(ctx, ann, s([
                              "",
                              "[0]"
                            ], [e1$1.ann.print]))
                  };
          }
          break;
      case "PairRefRight" :
          if (es && !es.tl) {
            var e1$2 = es.hd(true);
            return {
                    it: [
                      "PairRefRight",
                      {
                        hd: e1$2,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext(ctx, ann, s([
                              "",
                              "[1]"
                            ], [e1$2.ann.print]))
                  };
          }
          break;
      case "PairSetLeft" :
          if (es) {
            var match$1 = es.tl;
            if (match$1 && !match$1.tl) {
              var e1$3 = es.hd(false);
              var e2$1 = match$1.hd(false);
              return {
                      it: [
                        "PairSetLeft",
                        {
                          hd: e1$3,
                          tl: {
                            hd: e2$1,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContextStat(ctx, ann, s([
                                "",
                                "[0] = ",
                                ""
                              ], [
                                e1$3.ann.print,
                                e2$1.ann.print
                              ]))
                    };
            }
            
          }
          break;
      case "PairSetRight" :
          if (es) {
            var match$2 = es.tl;
            if (match$2 && !match$2.tl) {
              var e1$4 = es.hd(false);
              var e2$2 = match$2.hd(false);
              return {
                      it: [
                        "PairSetRight",
                        {
                          hd: e1$4,
                          tl: {
                            hd: e2$2,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContextStat(ctx, ann, s([
                                "",
                                "[1] = ",
                                ""
                              ], [
                                e1$4.ann.print,
                                e2$2.ann.print
                              ]))
                    };
            }
            
          }
          break;
      case "VecNew" :
          var es$1 = Belt_List.map(es, (function (e) {
                  return e(false);
                }));
          return {
                  it: [
                    "VecNew",
                    es$1
                  ],
                  ann: consumeContext(ctx, ann, s([
                            "[ ",
                            " ]"
                          ], [{
                              it: concat(", ", Belt_List.map(es$1, (function (e) {
                                          return e.ann.print;
                                        }))),
                              ann: undefined
                            }]))
                };
      case "VecRef" :
          if (es) {
            var match$3 = es.tl;
            if (match$3 && !match$3.tl) {
              var e1$5 = es.hd(true);
              var e2$3 = match$3.hd(false);
              return {
                      it: [
                        "VecRef",
                        {
                          hd: e1$5,
                          tl: {
                            hd: e2$3,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContext(ctx, ann, s([
                                "",
                                "[",
                                "]"
                              ], [
                                e1$5.ann.print,
                                e2$3.ann.print
                              ]))
                    };
            }
            
          }
          break;
      case "VecSet" :
          if (es) {
            var match$4 = es.tl;
            if (match$4) {
              var match$5 = match$4.tl;
              if (match$5 && !match$5.tl) {
                var e1$6 = es.hd(true);
                var e2$4 = match$4.hd(false);
                var e3 = match$5.hd(false);
                return {
                        it: [
                          "VecSet",
                          {
                            hd: e1$6,
                            tl: {
                              hd: e2$4,
                              tl: {
                                hd: e3,
                                tl: /* [] */0
                              }
                            }
                          }
                        ],
                        ann: consumeContextStat(ctx, ann, s([
                                  "",
                                  "[",
                                  "] = ",
                                  ""
                                ], [
                                  e1$6.ann.print,
                                  e2$4.ann.print,
                                  e3.ann.print
                                ]))
                      };
              }
              
            }
            
          }
          break;
      case "VecLen" :
          if (es && !es.tl) {
            var e1$7 = es.hd(false);
            return {
                    it: [
                      "VecLen",
                      {
                        hd: e1$7,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext(ctx, ann, s([
                              "len(",
                              ")"
                            ], [e1$7.ann.print]))
                  };
          }
          break;
      case "Err" :
          if (es && !es.tl) {
            var e1$8 = es.hd(true);
            return {
                    it: [
                      "Err",
                      {
                        hd: e1$8,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextEscapeWrap(ctx, ann, s([
                              "raise ",
                              ""
                            ], [e1$8.ann.print]))
                  };
          }
          break;
      case "Not" :
          if (es && !es.tl) {
            var e1$9 = es.hd(true);
            return {
                    it: [
                      "Not",
                      {
                        hd: e1$9,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextWrap(ctx, ann, s([
                              "not ",
                              ""
                            ], [e1$9.ann.print]))
                  };
          }
          break;
      case "ZeroP" :
          if (es && !es.tl) {
            var e1$10 = es.hd(true);
            return {
                    it: [
                      "ZeroP",
                      {
                        hd: e1$10,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextWrap(ctx, ann, s([
                              "",
                              " == 0"
                            ], [e1$10.ann.print]))
                  };
          }
          break;
      case "Print" :
          if (es && !es.tl) {
            var e1$11 = es.hd(false);
            return {
                    it: [
                      "Print",
                      {
                        hd: e1$11,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextVoid(ctx, ann, s([
                              "print(",
                              ")"
                            ], [e1$11.ann.print]))
                  };
          }
          break;
      case "Next" :
          if (es && !es.tl) {
            var e1$12 = es.hd(false);
            return {
                    it: [
                      "Next",
                      {
                        hd: e1$12,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextVoid(ctx, ann, s([
                              "next(",
                              ")"
                            ], [e1$12.ann.print]))
                  };
          }
          break;
      case "Maybe" :
      case "StringAppend" :
          break;
      case "Cons" :
      case "List" :
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "List is not supported by Python",
                Error: new Error()
              };
      case "EmptyP" :
      case "First" :
      case "Rest" :
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "List is not supported by Python.",
                Error: new Error()
              };
      
    }
  } else {
    if (p.TAG === "Arith") {
      var o = p._0;
      var es$2 = Belt_List.map(es, (function (e) {
              return e(true);
            }));
      return {
              it: [
                {
                  TAG: "Arith",
                  _0: o
                },
                es$2
              ],
              ann: consumeContextWrap(ctx, ann, concat(" " + stringOfArith(o) + " ", Belt_List.map(es$2, (function (e) {
                              return e.ann.print;
                            }))))
            };
    }
    if (es) {
      var match$6 = es.tl;
      if (match$6 && !match$6.tl) {
        var o$1 = p._0;
        var e1$13 = es.hd(true);
        var e2$5 = match$6.hd(true);
        var it = stringOfCmp(o$1);
        return {
                it: [
                  {
                    TAG: "Cmp",
                    _0: o$1
                  },
                  {
                    hd: e1$13,
                    tl: {
                      hd: e2$5,
                      tl: /* [] */0
                    }
                  }
                ],
                ann: consumeContextWrap(ctx, ann, s([
                          "",
                          " ",
                          " ",
                          ""
                        ], [
                          e1$13.ann.print,
                          {
                            it: {
                              TAG: "Plain",
                              _0: it
                            },
                            ann: undefined
                          },
                          e2$5.ann.print
                        ]))
              };
      }
      
    }
    
  }
  var err = "Python doesn't let you use " + toString$1(p) + " on " + String(Belt_List.length(es)) + " parameter(s).";
  throw {
        RE_EXN_ID: SMoLPrintError,
        _1: err,
        Error: new Error()
      };
}

function funLike(op, x, xs, e) {
  return s([
              "",
              " ",
              ":",
              ""
            ], [
              {
                it: {
                  TAG: "Plain",
                  _0: op
                },
                ann: undefined
              },
              {
                it: exprAppToString(x, xs),
                ann: undefined
              },
              indentBlock(e, 4)
            ]);
}

function defvarToString$1(x, e) {
  return defvarLike("", x, e);
}

function deffunToString$1(f, xs, b) {
  return funLike("def", f, xs, b);
}

function defgenToString$1(f, xs, b) {
  return funLike("def", f, xs, b);
}

function exprSetToString$1(x, e) {
  return defvarLike("", x, e);
}

function exprLamToString$1(xs, b) {
  return s([
              "lambda ",
              ": ",
              ""
            ], [
              xs,
              b
            ]);
}

function exprYieldToString$1(e) {
  return s([
              "yield ",
              ""
            ], [e]);
}

function ifStat(cnd, thn, els) {
  return s([
              "if ",
              ":",
              "",
              ""
            ], [
              cnd,
              indentBlock(thn, 4),
              {
                it: els !== undefined ? s([
                        "\nelse:",
                        ""
                      ], [indentBlock(els, 4)]) : s([""], []),
                ann: undefined
              }
            ]);
}

function exprCndToString$1(ebs, ob) {
  if (ebs === /* [] */0) {
    throw {
          RE_EXN_ID: SMoLPrintError,
          _1: "`else`-only conditional is not supported by Python.",
          Error: new Error()
        };
  }
  var ebs$1 = Belt_List.map(ebs, (function (param) {
          return {
                  it: ifStat(param[0], param[1], undefined),
                  ann: undefined
                };
        }));
  var ebs$2 = ob !== undefined ? Belt_List.concatMany([
          ebs$1,
          {
            hd: {
              it: s([
                    "se:",
                    ""
                  ], [indentBlock(ob, 4)]),
              ann: undefined
            },
            tl: /* [] */0
          }
        ]) : ebs$1;
  return concat("\nel", ebs$2);
}

function exprIfToString$1(e_cnd, e_thn, e_els) {
  return s([
              "",
              " if ",
              " else ",
              ""
            ], [
              e_thn,
              e_cnd,
              e_els
            ]);
}

function exprAndToString$1(e_ns) {
  if (e_ns === /* [] */0) {
    return s(["True"], []);
  } else {
    return concat(" and ", e_ns);
  }
}

function exprOrToString$1(e_ns) {
  if (e_ns === /* [] */0) {
    return s(["False"], []);
  } else {
    return concat(" or ", e_ns);
  }
}

function symbolToString$1(param) {
  var sourceLocation = param.ann;
  var it = param.it;
  return {
          it: it,
          ann: {
            sourceLocation: sourceLocation,
            print: {
              it: {
                TAG: "Plain",
                _0: printName$1(it)
              },
              ann: {
                nodeKind: "Name",
                sourceLocation: sourceLocation
              }
            }
          }
        };
}

function printExp$1(param, ctx, env) {
  var sourceLocation = param.ann;
  var it = param.it;
  var ann = function (it) {
    return {
            it: it,
            ann: {
              nodeKind: "Expression",
              sourceLocation: sourceLocation
            }
          };
  };
  switch (it.TAG) {
    case "Con" :
        var c = it._0;
        return {
                it: {
                  TAG: "Con",
                  _0: c
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContext(ctx, ann, {
                        TAG: "Plain",
                        _0: constantToString$1(c)
                      })
                }
              };
    case "Ref" :
        var x = it._0;
        return {
                it: {
                  TAG: "Ref",
                  _0: x
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContext(ctx, ann, {
                        TAG: "Plain",
                        _0: printName$1(x)
                      })
                }
              };
    case "Set" :
        var x$1 = it._0;
        refMut(env, x$1.it);
        var x$2 = symbolToString$1(x$1);
        var e = printExp$1(it._1, {
              TAG: "Expr",
              _0: false
            }, env);
        return {
                it: {
                  TAG: "Set",
                  _0: x$2,
                  _1: e
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextStat(ctx, ann, exprSetToString$1(x$2.ann.print, e.ann.print))
                }
              };
    case "Lam" :
        var xs = Belt_List.map(it._0, symbolToString$1);
        var b = printLamBody(it._1, xs, env);
        return {
                it: {
                  TAG: "Lam",
                  _0: xs,
                  _1: b
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrap(ctx, ann, exprLamToString$1({
                            it: concat(", ", Belt_List.map(xs, (function (x) {
                                        return x.ann.print;
                                      }))),
                            ann: undefined
                          }, b.ann.print))
                }
              };
    case "Let" :
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "let-expressions are not supported by Python",
              Error: new Error()
            };
    case "AppPrm" :
        var es = Belt_List.map(it._1, (function (e) {
                return function (b) {
                  return printExp$1(e, {
                              TAG: "Expr",
                              _0: b
                            }, env);
                };
              }));
        var match = exprAppPrmToString(ann, ctx, it._0, es);
        var match$1 = match.it;
        return {
                it: {
                  TAG: "AppPrm",
                  _0: match$1[0],
                  _1: match$1[1]
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: match.ann
                }
              };
    case "App" :
        var e$1 = printExp$1(it._0, {
              TAG: "Expr",
              _0: true
            }, env);
        var es$1 = Belt_List.map(it._1, (function (e) {
                return printExp$1(e, {
                            TAG: "Expr",
                            _0: false
                          }, env);
              }));
        return {
                it: {
                  TAG: "App",
                  _0: e$1,
                  _1: es$1
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContext(ctx, ann, exprAppToString(e$1.ann.print, Belt_List.map(es$1, (function (e) {
                                  return e.ann.print;
                                }))))
                }
              };
    case "Bgn" :
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "`begin` expressions are not supported by Python",
              Error: new Error()
            };
    case "If" :
        var e_els = it._2;
        var e_thn = it._1;
        var e_cnd = it._0;
        if (ctx.TAG === "Expr") {
          var e_cnd$1 = printExp$1(e_cnd, {
                TAG: "Expr",
                _0: true
              }, env);
          var e_thn$1 = printExp$1(e_thn, {
                TAG: "Expr",
                _0: true
              }, env);
          var e_els$1 = printExp$1(e_els, {
                TAG: "Expr",
                _0: true
              }, env);
          return {
                  it: {
                    TAG: "If",
                    _0: e_cnd$1,
                    _1: e_thn$1,
                    _2: e_els$1
                  },
                  ann: {
                    sourceLocation: sourceLocation,
                    print: consumeContextWrap({
                          TAG: "Expr",
                          _0: ctx._0
                        }, ann, exprIfToString$1(e_cnd$1.ann.print, e_thn$1.ann.print, e_els$1.ann.print))
                  }
                };
        }
        var ctx$1 = ctx._0;
        var e_cnd$2 = printExp$1(e_cnd, {
              TAG: "Expr",
              _0: false
            }, env);
        var e_thn$2 = printExp$1(e_thn, {
              TAG: "Stat",
              _0: ctx$1
            }, env);
        var e_els$2 = printExp$1(e_els, {
              TAG: "Stat",
              _0: ctx$1
            }, env);
        return {
                it: {
                  TAG: "If",
                  _0: e_cnd$2,
                  _1: e_thn$2,
                  _2: e_els$2
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: ann(ifStat(e_cnd$2.ann.print, e_thn$2.ann.print, e_els$2.ann.print))
                }
              };
    case "And" :
        var e_ns = Belt_List.map(it._0, (function (e_k) {
                return printExp$1(e_k, {
                            TAG: "Expr",
                            _0: false
                          }, env);
              }));
        return {
                it: {
                  TAG: "And",
                  _0: e_ns
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrap(ctx, ann, exprAndToString$1(Belt_List.map(e_ns, (function (e_k) {
                                  return e_k.ann.print;
                                }))))
                }
              };
    case "Or" :
        var e_ns$1 = Belt_List.map(it._0, (function (e_k) {
                return printExp$1(e_k, {
                            TAG: "Expr",
                            _0: false
                          }, env);
              }));
        return {
                it: {
                  TAG: "Or",
                  _0: e_ns$1
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrap(ctx, ann, exprOrToString$1(Belt_List.map(e_ns$1, (function (e_k) {
                                  return e_k.ann.print;
                                }))))
                }
              };
    case "Cnd" :
        if (ctx.TAG === "Expr") {
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "Multi-armed conditionals in Python is not supported by the translator yet.",
                Error: new Error()
              };
        }
        var ctx$2 = ctx._0;
        var ebs = Belt_List.map(it._0, (function (eb) {
                return [
                        printExp$1(eb[0], {
                              TAG: "Expr",
                              _0: false
                            }, env),
                        printBlock$1(eb[1], {
                              TAG: "Stat",
                              _0: ctx$2
                            }, env)
                      ];
              }));
        var ob = obToString(it._1, ctx$2, env);
        return {
                it: {
                  TAG: "Cnd",
                  _0: ebs,
                  _1: ob
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: ann(exprCndToString$1(Belt_List.map(ebs, (function (param) {
                                  return [
                                          param[0].ann.print,
                                          param[1].ann.print
                                        ];
                                })), Belt_Option.map(ob, (function (b) {
                                  return b.ann.print;
                                }))))
                }
              };
    case "GLam" :
        var xs$1 = Belt_List.map(it._0, symbolToString$1);
        var b$1 = printLamBody(it._1, xs$1, env);
        return {
                it: {
                  TAG: "GLam",
                  _0: xs$1,
                  _1: b$1
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrap(ctx, ann, exprLamToString$1({
                            it: concat(",", Belt_List.map(xs$1, (function (x) {
                                        return x.ann.print;
                                      }))),
                            ann: undefined
                          }, b$1.ann.print))
                }
              };
    case "Yield" :
        var e$2 = printExp$1(it._0, {
              TAG: "Expr",
              _0: false
            }, env);
        return {
                it: {
                  TAG: "Yield",
                  _0: e$2
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrapEvenReturn(ctx, ann, exprYieldToString$1(e$2.ann.print))
                }
              };
    
  }
}

function printDef$1(param, env) {
  var sourceLocation = param.ann;
  var d = param.it;
  var d$1;
  switch (d.TAG) {
    case "Var" :
        var x = symbolToString$1(d._0);
        var e = printExp$1(d._1, {
              TAG: "Expr",
              _0: false
            }, env);
        d$1 = {
          it: {
            TAG: "Var",
            _0: x,
            _1: e
          },
          ann: defvarToString$1(x.ann.print, e.ann.print)
        };
        break;
    case "Fun" :
        var f = symbolToString$1(d._0);
        var xs = Belt_List.map(d._1, symbolToString$1);
        var b = printDefBody(d._2, xs, env);
        d$1 = {
          it: {
            TAG: "Fun",
            _0: f,
            _1: xs,
            _2: b
          },
          ann: deffunToString$1(f.ann.print, Belt_List.map(xs, (function (x) {
                      return x.ann.print;
                    })), b.ann.print)
        };
        break;
    case "GFun" :
        var f$1 = symbolToString$1(d._0);
        var xs$1 = Belt_List.map(d._1, symbolToString$1);
        var b$1 = printDefBody(d._2, xs$1, env);
        d$1 = {
          it: {
            TAG: "GFun",
            _0: f$1,
            _1: xs$1,
            _2: b$1
          },
          ann: defgenToString$1(f$1.ann.print, Belt_List.map(xs$1, (function (x) {
                      return x.ann.print;
                    })), b$1.ann.print)
        };
        break;
    
  }
  return {
          it: d$1.it,
          ann: {
            sourceLocation: sourceLocation,
            print: {
              it: d$1.ann,
              ann: {
                nodeKind: "Definition",
                sourceLocation: sourceLocation
              }
            }
          }
        };
}

function obToString(ob, ctx, env) {
  return Belt_Option.map(ob, (function (b) {
                return printBlock$1(b, {
                            TAG: "Stat",
                            _0: ctx
                          }, env);
              }));
}

function printBlockHelper(param, ctx, env) {
  var sourceLocation = param.ann;
  var b = param.it;
  var annPrint = function (print) {
    return {
            it: print,
            ann: {
              nodeKind: "Block",
              sourceLocation: sourceLocation
            }
          };
  };
  if (b.TAG === "BRet") {
    var e = printExp$1(b._0, {
          TAG: "Stat",
          _0: ctx
        }, env);
    var print = annPrint({
          TAG: "Group",
          _0: {
            hd: e.ann.print,
            tl: /* [] */0
          }
        });
    return {
            it: {
              TAG: "BRet",
              _0: e
            },
            ann: {
              sourceLocation: sourceLocation,
              print: print
            }
          };
  }
  var t = printTerm$1(b._0, env, "Step");
  var b$1 = printBlockHelper(b._1, ctx, env);
  var print$1 = annPrint(s([
            "",
            "\n",
            ""
          ], [
            t.ann.print,
            b$1.ann.print
          ]));
  return {
          it: {
            TAG: "BCons",
            _0: t,
            _1: b$1
          },
          ann: {
            sourceLocation: sourceLocation,
            print: print$1
          }
        };
}

function printBlock$1(b, ctx, env) {
  var sourceLocation = b.ann;
  var it = b.it;
  if (it.TAG === "BRet" && ctx.TAG === "Expr") {
    var e = printExp$1(it._0, {
          TAG: "Expr",
          _0: ctx._0
        }, env);
    return {
            it: {
              TAG: "BRet",
              _0: e
            },
            ann: {
              sourceLocation: sourceLocation,
              print: {
                it: {
                  TAG: "Group",
                  _0: {
                    hd: e.ann.print,
                    tl: /* [] */0
                  }
                },
                ann: {
                  nodeKind: "Block",
                  sourceLocation: sourceLocation
                }
              }
            }
          };
  }
  if (ctx.TAG === "Expr") {
    throw {
          RE_EXN_ID: SMoLPrintError,
          _1: "Python blocks can't be used as expressions in general",
          Error: new Error()
        };
  }
  var xs = xsOfBlock(b);
  if (xs !== /* [] */0) {
    throw {
          RE_EXN_ID: SMoLPrintError,
          _1: "Python blocks can't declare local variables",
          Error: new Error()
        };
  }
  return printBlockHelper({
              it: it,
              ann: sourceLocation
            }, ctx._0, env);
}

function printLamBody(b, args, env) {
  var e = b.it;
  if (e.TAG === "BRet") {
    var args$1 = Belt_List.map(args, (function (x) {
            return x.it;
          }));
    var match = extend(args$1, env);
    var match$1 = printExp$1(e._0, {
          TAG: "Expr",
          _0: false
        }, match[1]);
    var ann = match$1.ann;
    return {
            it: {
              TAG: "BRet",
              _0: {
                it: match$1.it,
                ann: ann
              }
            },
            ann: ann
          };
  }
  throw {
        RE_EXN_ID: SMoLPrintError,
        _1: "In Python, a lambda body must contain exactly one expression",
        Error: new Error()
      };
}

function printDefBody(b, args, env) {
  var locs = Belt_List.map(xsOfBlock(b), (function (x) {
          return x.it;
        }));
  var args$1 = Belt_List.map(args, (function (x) {
          return x.it;
        }));
  var match = extend(Belt_List.concat(locs, args$1), env);
  var b$1 = printBlockHelper(b, "Return", match[1]);
  var print_it = concat("\n", Belt_List.concatMany([
            Belt_List.fromArray(Belt_HashMapString.toArray(match[0]).map(function (param) {
                      var it = toString$9(param[1]) + " " + param[0];
                      return {
                              it: {
                                TAG: "Plain",
                                _0: it
                              },
                              ann: undefined
                            };
                    })),
            {
              hd: b$1.ann.print,
              tl: /* [] */0
            }
          ]));
  var print = {
    it: print_it,
    ann: undefined
  };
  return {
          it: b$1.it,
          ann: {
            sourceLocation: b$1.ann.sourceLocation,
            print: print
          }
        };
}

function printTerm$1(param, env, ctx) {
  var sourceLocation = param.ann;
  var it = param.it;
  var annPrint = function (it) {
    return {
            it: it,
            ann: {
              nodeKind: "Term",
              sourceLocation: sourceLocation
            }
          };
  };
  if (it.TAG === "Def") {
    var it$1 = printDef$1(it._0, env);
    return {
            it: {
              TAG: "Def",
              _0: it$1
            },
            ann: {
              sourceLocation: sourceLocation,
              print: annPrint({
                    TAG: "Group",
                    _0: {
                      hd: it$1.ann.print,
                      tl: /* [] */0
                    }
                  })
            }
          };
  }
  var it$2 = printExp$1(it._0, {
        TAG: "Stat",
        _0: ctx
      }, env);
  return {
          it: {
            TAG: "Exp",
            _0: it$2
          },
          ann: {
            sourceLocation: sourceLocation,
            print: annPrint({
                  TAG: "Group",
                  _0: {
                    hd: it$2.ann.print,
                    tl: /* [] */0
                  }
                })
          }
        };
}

function printOutputlet$1(o) {
  var p = function (v) {
    switch (v.TAG) {
      case "Ref" :
          return "[...]";
      case "Con" :
          return constantToString$1(v._0);
      case "Struct" :
          var content = v._1;
          var i = "";
          var content$1;
          if (content.TAG === "Lst") {
            throw {
                  RE_EXN_ID: SMoLPrintError,
                  _1: "Lists are not supported in Python.",
                  Error: new Error()
                };
          }
          content$1 = "[" + Belt_List.toArray(Belt_List.map(content._0, p)).join(", ") + "]";
          return i + content$1;
      
    }
  };
  if (typeof o !== "object") {
    return "error";
  } else {
    return p(o._0);
  }
}

function printOutput$1(sepOpt, os) {
  var sep = sepOpt !== undefined ? sepOpt : " ";
  return Belt_List.toArray(Belt_List.map(os, printOutputlet$1)).join(sep);
}

function printProgramFull$1(insertPrintTopLevel, p) {
  var p$1 = insertPrintTopLevel ? insertTopLevelPrint(p) : p;
  var xs = xsOfProgram(p$1);
  var env = {
    TAG: "G",
    _0: Belt_HashSetString.fromArray(Belt_List.toArray(Belt_List.map(xs, (function (x) {
                    return x.it;
                  }))))
  };
  var print = function (param) {
    var sourceLocation = param.ann;
    var it = param.it;
    var annPrint = function (print) {
      return {
              sourceLocation: sourceLocation,
              print: {
                it: print,
                ann: {
                  nodeKind: "Program",
                  sourceLocation: sourceLocation
                }
              }
            };
    };
    if (typeof it !== "object") {
      return {
              it: "PNil",
              ann: {
                sourceLocation: sourceLocation,
                print: {
                  it: {
                    TAG: "Plain",
                    _0: ""
                  },
                  ann: {
                    nodeKind: "Program",
                    sourceLocation: sourceLocation
                  }
                }
              }
            };
    }
    var t = printTerm$1(it._0, env, "Step");
    var p = print(it._1);
    return {
            it: {
              TAG: "PCons",
              _0: t,
              _1: p
            },
            ann: annPrint({
                  TAG: "Group",
                  _0: {
                    hd: t.ann.print,
                    tl: {
                      hd: {
                        it: {
                          TAG: "Plain",
                          _0: p.it === "PNil" ? "" : "\n"
                        },
                        ann: undefined
                      },
                      tl: {
                        hd: p.ann.print,
                        tl: /* [] */0
                      }
                    }
                  }
                })
          };
  };
  return print(p$1);
}

function printProgram$1(insertPrintTopLevel, p) {
  return toString(printProgramFull$1(insertPrintTopLevel, p).ann.print);
}

function printStandAloneTerm$1(param) {
  var it = param.it;
  var globalEnv = {
    TAG: "G",
    _0: Belt_HashSetString.fromArray([])
  };
  var tmp;
  if (it.TAG === "Def") {
    var it$1 = printDef$1(it._0, globalEnv);
    tmp = it$1.ann.print;
  } else {
    var it$2 = printExp$1(it._0, {
          TAG: "Stat",
          _0: "Step"
        }, globalEnv);
    var sourceLocation = it$2.ann.sourceLocation;
    tmp = extract(it$2.ann.print, {
          nodeKind: "Expression",
          sourceLocation: sourceLocation
        }, toString$8);
  }
  return toString(tmp);
}

function printName$2(x) {
  var re = /-./g;
  var matchFn = function (matchPart, _offset, _wholeString) {
    return matchPart.substring(1).toUpperCase();
  };
  var x$1 = x.replace(re, matchFn);
  if (x$1 === "var") {
    return "$var";
  } else {
    return x$1;
  }
}

function constantToString$2(c) {
  if (typeof c !== "object") {
    if (c === "Uni") {
      return "undefined";
    }
    throw {
          RE_EXN_ID: SMoLPrintError,
          _1: "Lists are not supported in JavaScript.",
          Error: new Error()
        };
  } else {
    switch (c.TAG) {
      case "Num" :
          return String(c._0);
      case "Lgc" :
          if (c._0) {
            return "true";
          } else {
            return "false";
          }
      case "Str" :
          return JSON.stringify(c._0);
      case "Sym" :
          return c._0;
      
    }
  }
}

function listToString$1(es) {
  if (Belt_List.some(es, containsNL)) {
    return {
            TAG: "Group",
            _0: {
              hd: {
                it: {
                  TAG: "Plain",
                  _0: "("
                },
                ann: undefined
              },
              tl: {
                hd: indentBlock({
                      it: concat(",\n", es),
                      ann: undefined
                    }, 4),
                tl: {
                  hd: {
                    it: {
                      TAG: "Plain",
                      _0: ")"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          };
  } else {
    return {
            TAG: "Group",
            _0: {
              hd: {
                it: {
                  TAG: "Plain",
                  _0: "("
                },
                ann: undefined
              },
              tl: {
                hd: {
                  it: concat(", ", es),
                  ann: undefined
                },
                tl: {
                  hd: {
                    it: {
                      TAG: "Plain",
                      _0: ")"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          };
  }
}

function exprAppToString$1(e, es) {
  return {
          TAG: "Group",
          _0: {
            hd: e,
            tl: {
              hd: {
                it: listToString$1(es),
                ann: undefined
              },
              tl: /* [] */0
            }
          }
        };
}

function consumeContext$1(ctx, ann, e) {
  var e$1 = ann(e);
  if (ctx.TAG === "Expr") {
    return e$1;
  } else if (ctx._0 === "Step") {
    return {
            it: s([
                  "",
                  ";"
                ], [e$1]),
            ann: undefined
          };
  } else {
    return {
            it: s([
                  "return ",
                  ";"
                ], [e$1]),
            ann: undefined
          };
  }
}

function paren$1(e) {
  return s([
              "(",
              ")"
            ], [{
                it: e,
                ann: undefined
              }]);
}

function consumeContextWrapEvenReturn$1(ctx, ann, e) {
  if (ctx.TAG === "Expr") {
    if (ctx._0) {
      return ann(paren$1(e));
    } else {
      return ann(e);
    }
  } else if (ctx._0 === "Step") {
    return {
            it: s([
                  "",
                  ";"
                ], [ann(e)]),
            ann: undefined
          };
  } else {
    return {
            it: s([
                  "return ",
                  ";"
                ], [ann(paren$1(e))]),
            ann: undefined
          };
  }
}

function consumeContextWrap$1(ctx, ann, e) {
  if (ctx.TAG === "Expr") {
    if (ctx._0) {
      return ann(paren$1(e));
    } else {
      return ann(e);
    }
  } else if (ctx._0 === "Step") {
    return {
            it: s([
                  "",
                  ";"
                ], [ann(e)]),
            ann: undefined
          };
  } else {
    return {
            it: s([
                  "return ",
                  ";"
                ], [ann(e)]),
            ann: undefined
          };
  }
}

function consumeContextVoid$1(ctx, ann, e) {
  var e$1 = ann(e);
  if (ctx.TAG === "Expr") {
    return e$1;
  } else if (ctx._0 === "Step") {
    return {
            it: s([
                  "",
                  ";"
                ], [e$1]),
            ann: undefined
          };
  } else {
    return {
            it: s([
                  "",
                  ";\nreturn;"
                ], [e$1]),
            ann: undefined
          };
  }
}

function consumeContextEscapeWrap$1(ctx, ann, e) {
  var e$1 = ann(e);
  if (ctx.TAG === "Expr") {
    return e$1;
  } else {
    return {
            it: s([
                  "",
                  ";"
                ], [e$1]),
            ann: undefined
          };
  }
}

function consumeContextStat$1(ctx, ann, e) {
  var e$1 = ann(e);
  if (ctx.TAG !== "Expr") {
    if (ctx._0 === "Step") {
      return {
              it: s([
                    "",
                    ";"
                  ], [e$1]),
              ann: undefined
            };
    } else {
      return {
              it: s([
                    "",
                    ";\nreturn;"
                  ], [e$1]),
              ann: undefined
            };
    }
  }
  var err = toString(e$1) + " can't be used as a expression in JavaScript";
  throw {
        RE_EXN_ID: SMoLPrintError,
        _1: err,
        Error: new Error()
      };
}

function stringOfArith$1(o) {
  switch (o) {
    case "Add" :
        return "+";
    case "Sub" :
        return "-";
    case "Mul" :
        return "*";
    case "Div" :
        return "/";
    
  }
}

function stringOfCmp$1(o) {
  switch (o) {
    case "Lt" :
        return "<";
    case "NumEq" :
        return "==";
    case "Eq" :
        return "===";
    case "Gt" :
        return ">";
    case "Le" :
        return "<=";
    case "Ge" :
        return ">=";
    case "Ne" :
        return "!=";
    case "Equal" :
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "JavaScript doesn't not have structural equality.",
              Error: new Error()
            };
    
  }
}

function exprAppPrmToString$1(ann, ctx, p, es) {
  if (typeof p !== "object") {
    switch (p) {
      case "PairNew" :
          if (es) {
            var match = es.tl;
            if (match && !match.tl) {
              var e1 = es.hd(false);
              var e2 = match.hd(false);
              return {
                      it: [
                        "PairNew",
                        {
                          hd: e1,
                          tl: {
                            hd: e2,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContext$1(ctx, ann, s([
                                "[ ",
                                ", ",
                                " ]"
                              ], [
                                e1.ann.print,
                                e2.ann.print
                              ]))
                    };
            }
            
          }
          break;
      case "PairRefLeft" :
          if (es && !es.tl) {
            var e1$1 = es.hd(true);
            return {
                    it: [
                      "PairRefLeft",
                      {
                        hd: e1$1,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$1(ctx, ann, s([
                              "",
                              "[0]"
                            ], [e1$1.ann.print]))
                  };
          }
          break;
      case "PairRefRight" :
          if (es && !es.tl) {
            var e1$2 = es.hd(true);
            return {
                    it: [
                      "PairRefRight",
                      {
                        hd: e1$2,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$1(ctx, ann, s([
                              "",
                              "[1]"
                            ], [e1$2.ann.print]))
                  };
          }
          break;
      case "PairSetLeft" :
          if (es) {
            var match$1 = es.tl;
            if (match$1 && !match$1.tl) {
              var e1$3 = es.hd(false);
              var e2$1 = match$1.hd(false);
              return {
                      it: [
                        "PairSetLeft",
                        {
                          hd: e1$3,
                          tl: {
                            hd: e2$1,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContextStat$1(ctx, ann, s([
                                "",
                                "[0] = ",
                                ""
                              ], [
                                e1$3.ann.print,
                                e2$1.ann.print
                              ]))
                    };
            }
            
          }
          break;
      case "PairSetRight" :
          if (es) {
            var match$2 = es.tl;
            if (match$2 && !match$2.tl) {
              var e1$4 = es.hd(false);
              var e2$2 = match$2.hd(false);
              return {
                      it: [
                        "PairSetRight",
                        {
                          hd: e1$4,
                          tl: {
                            hd: e2$2,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContextStat$1(ctx, ann, s([
                                "",
                                "[1] = ",
                                ""
                              ], [
                                e1$4.ann.print,
                                e2$2.ann.print
                              ]))
                    };
            }
            
          }
          break;
      case "VecNew" :
          var es$1 = Belt_List.map(es, (function (e) {
                  return e(false);
                }));
          return {
                  it: [
                    "VecNew",
                    es$1
                  ],
                  ann: consumeContext$1(ctx, ann, s([
                            "[ ",
                            " ]"
                          ], [{
                              it: concat(", ", Belt_List.map(es$1, (function (e) {
                                          return e.ann.print;
                                        }))),
                              ann: undefined
                            }]))
                };
      case "VecRef" :
          if (es) {
            var match$3 = es.tl;
            if (match$3 && !match$3.tl) {
              var e1$5 = es.hd(true);
              var e2$3 = match$3.hd(false);
              return {
                      it: [
                        "VecRef",
                        {
                          hd: e1$5,
                          tl: {
                            hd: e2$3,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContext$1(ctx, ann, s([
                                "",
                                "[",
                                "]"
                              ], [
                                e1$5.ann.print,
                                e2$3.ann.print
                              ]))
                    };
            }
            
          }
          break;
      case "VecSet" :
          if (es) {
            var match$4 = es.tl;
            if (match$4) {
              var match$5 = match$4.tl;
              if (match$5 && !match$5.tl) {
                var e1$6 = es.hd(true);
                var e2$4 = match$4.hd(false);
                var e3 = match$5.hd(false);
                return {
                        it: [
                          "VecSet",
                          {
                            hd: e1$6,
                            tl: {
                              hd: e2$4,
                              tl: {
                                hd: e3,
                                tl: /* [] */0
                              }
                            }
                          }
                        ],
                        ann: consumeContextStat$1(ctx, ann, s([
                                  "",
                                  "[",
                                  "] = ",
                                  ""
                                ], [
                                  e1$6.ann.print,
                                  e2$4.ann.print,
                                  e3.ann.print
                                ]))
                      };
              }
              
            }
            
          }
          break;
      case "VecLen" :
          if (es && !es.tl) {
            var e1$7 = es.hd(true);
            return {
                    it: [
                      "VecLen",
                      {
                        hd: e1$7,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$1(ctx, ann, s([
                              "",
                              ".length"
                            ], [e1$7.ann.print]))
                  };
          }
          break;
      case "Err" :
          if (es && !es.tl) {
            var e1$8 = es.hd(true);
            return {
                    it: [
                      "Err",
                      {
                        hd: e1$8,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextEscapeWrap$1(ctx, ann, s([
                              "throw ",
                              ""
                            ], [e1$8.ann.print]))
                  };
          }
          break;
      case "Not" :
          if (es && !es.tl) {
            var e1$9 = es.hd(true);
            return {
                    it: [
                      "Not",
                      {
                        hd: e1$9,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextWrap$1(ctx, ann, s([
                              "! ",
                              ""
                            ], [e1$9.ann.print]))
                  };
          }
          break;
      case "ZeroP" :
          if (es && !es.tl) {
            var e1$10 = es.hd(true);
            return {
                    it: [
                      "ZeroP",
                      {
                        hd: e1$10,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextWrap$1(ctx, ann, s([
                              "",
                              " == 0"
                            ], [e1$10.ann.print]))
                  };
          }
          break;
      case "Print" :
          if (es && !es.tl) {
            var e1$11 = es.hd(false);
            return {
                    it: [
                      "Print",
                      {
                        hd: e1$11,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextVoid$1(ctx, ann, s([
                              "console.log(",
                              ")"
                            ], [e1$11.ann.print]))
                  };
          }
          break;
      case "Next" :
          if (es && !es.tl) {
            var e1$12 = es.hd(true);
            return {
                    it: [
                      "Next",
                      {
                        hd: e1$12,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextVoid$1(ctx, ann, s([
                              "",
                              ".next().value"
                            ], [e1$12.ann.print]))
                  };
          }
          break;
      case "Maybe" :
      case "StringAppend" :
          break;
      case "Cons" :
      case "List" :
      case "EmptyP" :
      case "First" :
      case "Rest" :
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "List is not supported by JavaScript",
                Error: new Error()
              };
      
    }
  } else {
    if (p.TAG === "Arith") {
      var o = p._0;
      var es$2 = Belt_List.map(es, (function (e) {
              return e(true);
            }));
      return {
              it: [
                {
                  TAG: "Arith",
                  _0: o
                },
                es$2
              ],
              ann: consumeContextWrap$1(ctx, ann, concat(" " + stringOfArith$1(o) + " ", Belt_List.map(es$2, (function (e) {
                              return e.ann.print;
                            }))))
            };
    }
    if (es) {
      var match$6 = es.tl;
      if (match$6 && !match$6.tl) {
        var o$1 = p._0;
        var e1$13 = es.hd(true);
        var e2$5 = match$6.hd(true);
        var it = stringOfCmp$1(o$1);
        return {
                it: [
                  {
                    TAG: "Cmp",
                    _0: o$1
                  },
                  {
                    hd: e1$13,
                    tl: {
                      hd: e2$5,
                      tl: /* [] */0
                    }
                  }
                ],
                ann: consumeContextWrap$1(ctx, ann, s([
                          "",
                          " ",
                          " ",
                          ""
                        ], [
                          e1$13.ann.print,
                          {
                            it: {
                              TAG: "Plain",
                              _0: it
                            },
                            ann: undefined
                          },
                          e2$5.ann.print
                        ]))
              };
      }
      
    }
    
  }
  var err = "JavaScript doesn't let you use " + toString$1(p) + " on " + String(Belt_List.length(es)) + " parameter(s).";
  throw {
        RE_EXN_ID: SMoLPrintError,
        _1: err,
        Error: new Error()
      };
}

function funLike$1(op, x, xs, e) {
  return s([
              "",
              " ",
              " {",
              "\n}"
            ], [
              {
                it: {
                  TAG: "Plain",
                  _0: op
                },
                ann: undefined
              },
              {
                it: exprAppToString$1(x, xs),
                ann: undefined
              },
              indentBlock(e, 2)
            ]);
}

function defvarToString$2(x, e) {
  return s([
              "let ",
              " = ",
              ";"
            ], [
              x,
              e
            ]);
}

function deffunToString$2(f, xs, b) {
  return funLike$1("function", f, xs, b);
}

function defgenToString$2(f, xs, b) {
  return funLike$1("function*", f, xs, b);
}

function exprSetToString$2(x, e) {
  return s([
              "",
              " = ",
              ""
            ], [
              x,
              e
            ]);
}

function exprLamToString$2(xs, b) {
  return s([
              "(",
              ") => {",
              "\n}"
            ], [
              xs,
              indentBlock(b, 2)
            ]);
}

function exprYieldToString$2(e) {
  return s([
              "yield ",
              ""
            ], [e]);
}

function ifStat$1(cnd, thn, els) {
  return s([
              "if (",
              ") {",
              "\n}",
              ""
            ], [
              cnd,
              indentBlock(thn, 2),
              {
                it: els !== undefined ? s([
                        " else {",
                        "\n}"
                      ], [indentBlock(els, 2)]) : s([""], []),
                ann: undefined
              }
            ]);
}

function exprCndToString$2(ebs, ob) {
  var ebs$1 = Belt_List.map(ebs, (function (param) {
          return {
                  it: ifStat$1(param[0], param[1], undefined),
                  ann: undefined
                };
        }));
  var ebs$2 = ob !== undefined ? Belt_List.concatMany([
          ebs$1,
          {
            hd: {
              it: s([
                    "{",
                    "\n}"
                  ], [indentBlock(ob, 2)]),
              ann: undefined
            },
            tl: /* [] */0
          }
        ]) : ebs$1;
  return concat(" else ", ebs$2);
}

function exprIfToString$2(e_cnd, e_thn, e_els) {
  return s([
              "",
              " ? ",
              " : ",
              ""
            ], [
              e_cnd,
              e_thn,
              e_els
            ]);
}

function exprAndToString$2(e_ns) {
  if (e_ns === /* [] */0) {
    return s(["true"], []);
  } else {
    return concat(" && ", e_ns);
  }
}

function exprOrToString$2(e_ns) {
  if (e_ns === /* [] */0) {
    return s(["false"], []);
  } else {
    return concat(" || ", e_ns);
  }
}

function symbolToString$2(param) {
  var sourceLocation = param.ann;
  var it = param.it;
  return {
          it: it,
          ann: {
            sourceLocation: sourceLocation,
            print: {
              it: {
                TAG: "Plain",
                _0: printName$2(it)
              },
              ann: {
                nodeKind: "Name",
                sourceLocation: sourceLocation
              }
            }
          }
        };
}

function printExp$2(param, ctx) {
  var sourceLocation = param.ann;
  var it = param.it;
  var ann = function (it) {
    return {
            it: it,
            ann: {
              nodeKind: "Expression",
              sourceLocation: sourceLocation
            }
          };
  };
  switch (it.TAG) {
    case "Con" :
        var c = it._0;
        return {
                it: {
                  TAG: "Con",
                  _0: c
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContext$1(ctx, ann, {
                        TAG: "Plain",
                        _0: constantToString$2(c)
                      })
                }
              };
    case "Ref" :
        var x = it._0;
        return {
                it: {
                  TAG: "Ref",
                  _0: x
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContext$1(ctx, ann, {
                        TAG: "Plain",
                        _0: printName$2(x)
                      })
                }
              };
    case "Set" :
        var x$1 = symbolToString$2(it._0);
        var e = printExp$2(it._1, {
              TAG: "Expr",
              _0: false
            });
        return {
                it: {
                  TAG: "Set",
                  _0: x$1,
                  _1: e
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextStat$1(ctx, ann, exprSetToString$2(x$1.ann.print, e.ann.print))
                }
              };
    case "Lam" :
        var xs = Belt_List.map(it._0, symbolToString$2);
        var b = printBlock$2(it._1, {
              TAG: "Stat",
              _0: "Return"
            });
        return {
                it: {
                  TAG: "Lam",
                  _0: xs,
                  _1: b
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrap$1(ctx, ann, exprLamToString$2({
                            it: concat(",", Belt_List.map(xs, (function (x) {
                                        return x.ann.print;
                                      }))),
                            ann: undefined
                          }, b.ann.print))
                }
              };
    case "Let" :
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "let-expressions are not supported by JavaScript",
              Error: new Error()
            };
    case "AppPrm" :
        var es = Belt_List.map(it._1, (function (e) {
                return function (b) {
                  return printExp$2(e, {
                              TAG: "Expr",
                              _0: b
                            });
                };
              }));
        var match = exprAppPrmToString$1(ann, ctx, it._0, es);
        var match$1 = match.it;
        return {
                it: {
                  TAG: "AppPrm",
                  _0: match$1[0],
                  _1: match$1[1]
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: match.ann
                }
              };
    case "App" :
        var e$1 = printExp$2(it._0, {
              TAG: "Expr",
              _0: true
            });
        var es$1 = Belt_List.map(it._1, (function (e) {
                return printExp$2(e, {
                            TAG: "Expr",
                            _0: false
                          });
              }));
        return {
                it: {
                  TAG: "App",
                  _0: e$1,
                  _1: es$1
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContext$1(ctx, ann, exprAppToString$1(e$1.ann.print, Belt_List.map(es$1, (function (e) {
                                  return e.ann.print;
                                }))))
                }
              };
    case "Bgn" :
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "`begin` expressions are not supported by JavaScript",
              Error: new Error()
            };
    case "If" :
        var e_els = it._2;
        var e_thn = it._1;
        var e_cnd = it._0;
        if (ctx.TAG === "Expr") {
          var e_cnd$1 = printExp$2(e_cnd, {
                TAG: "Expr",
                _0: false
              });
          var e_thn$1 = printExp$2(e_thn, {
                TAG: "Expr",
                _0: false
              });
          var e_els$1 = printExp$2(e_els, {
                TAG: "Expr",
                _0: false
              });
          return {
                  it: {
                    TAG: "If",
                    _0: e_cnd$1,
                    _1: e_thn$1,
                    _2: e_els$1
                  },
                  ann: {
                    sourceLocation: sourceLocation,
                    print: consumeContextWrap$1({
                          TAG: "Expr",
                          _0: ctx._0
                        }, ann, exprIfToString$2(e_cnd$1.ann.print, e_thn$1.ann.print, e_els$1.ann.print))
                  }
                };
        }
        var ctx$1 = ctx._0;
        var e_cnd$2 = printExp$2(e_cnd, {
              TAG: "Expr",
              _0: false
            });
        var e_thn$2 = printExp$2(e_thn, {
              TAG: "Stat",
              _0: ctx$1
            });
        var e_els$2 = printExp$2(e_els, {
              TAG: "Stat",
              _0: ctx$1
            });
        return {
                it: {
                  TAG: "If",
                  _0: e_cnd$2,
                  _1: e_thn$2,
                  _2: e_els$2
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: ann(ifStat$1(e_cnd$2.ann.print, e_thn$2.ann.print, e_els$2.ann.print))
                }
              };
    case "And" :
        var e_ns = Belt_List.map(it._0, (function (e_k) {
                return printExp$2(e_k, {
                            TAG: "Expr",
                            _0: false
                          });
              }));
        return {
                it: {
                  TAG: "And",
                  _0: e_ns
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrap$1(ctx, ann, exprAndToString$2(Belt_List.map(e_ns, (function (e_k) {
                                  return e_k.ann.print;
                                }))))
                }
              };
    case "Or" :
        var e_ns$1 = Belt_List.map(it._0, (function (e_k) {
                return printExp$2(e_k, {
                            TAG: "Expr",
                            _0: false
                          });
              }));
        return {
                it: {
                  TAG: "Or",
                  _0: e_ns$1
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrap$1(ctx, ann, exprOrToString$2(Belt_List.map(e_ns$1, (function (e_k) {
                                  return e_k.ann.print;
                                }))))
                }
              };
    case "Cnd" :
        if (ctx.TAG === "Expr") {
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "Multi-armed conditionals in JavaScript is not supported by the translator yet.",
                Error: new Error()
              };
        }
        var ctx$2 = ctx._0;
        var ebs = Belt_List.map(it._0, (function (eb) {
                return [
                        printExp$2(eb[0], {
                              TAG: "Expr",
                              _0: false
                            }),
                        printBlock$2(eb[1], {
                              TAG: "Stat",
                              _0: ctx$2
                            })
                      ];
              }));
        var ob = obToString$1(it._1, ctx$2);
        return {
                it: {
                  TAG: "Cnd",
                  _0: ebs,
                  _1: ob
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: ann(exprCndToString$2(Belt_List.map(ebs, (function (param) {
                                  return [
                                          param[0].ann.print,
                                          param[1].ann.print
                                        ];
                                })), Belt_Option.map(ob, (function (b) {
                                  return b.ann.print;
                                }))))
                }
              };
    case "GLam" :
        var xs$1 = Belt_List.map(it._0, symbolToString$2);
        var b$1 = printBlock$2(it._1, {
              TAG: "Stat",
              _0: "Return"
            });
        return {
                it: {
                  TAG: "GLam",
                  _0: xs$1,
                  _1: b$1
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrap$1(ctx, ann, exprLamToString$2({
                            it: concat(",", Belt_List.map(xs$1, (function (x) {
                                        return x.ann.print;
                                      }))),
                            ann: undefined
                          }, b$1.ann.print))
                }
              };
    case "Yield" :
        var e$2 = printExp$2(it._0, {
              TAG: "Expr",
              _0: false
            });
        return {
                it: {
                  TAG: "Yield",
                  _0: e$2
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrapEvenReturn$1(ctx, ann, exprYieldToString$2(e$2.ann.print))
                }
              };
    
  }
}

function printDef$2(param) {
  var sourceLocation = param.ann;
  var d = param.it;
  var d$1;
  switch (d.TAG) {
    case "Var" :
        var x = symbolToString$2(d._0);
        var e = printExp$2(d._1, {
              TAG: "Expr",
              _0: false
            });
        d$1 = {
          it: {
            TAG: "Var",
            _0: x,
            _1: e
          },
          ann: defvarToString$2(x.ann.print, e.ann.print)
        };
        break;
    case "Fun" :
        var f = symbolToString$2(d._0);
        var xs = Belt_List.map(d._1, symbolToString$2);
        var b = printBlock$2(d._2, {
              TAG: "Stat",
              _0: "Return"
            });
        d$1 = {
          it: {
            TAG: "Fun",
            _0: f,
            _1: xs,
            _2: b
          },
          ann: deffunToString$2(f.ann.print, Belt_List.map(xs, (function (x) {
                      return x.ann.print;
                    })), b.ann.print)
        };
        break;
    case "GFun" :
        var f$1 = symbolToString$2(d._0);
        var xs$1 = Belt_List.map(d._1, symbolToString$2);
        var b$1 = printBlock$2(d._2, {
              TAG: "Stat",
              _0: "Return"
            });
        d$1 = {
          it: {
            TAG: "GFun",
            _0: f$1,
            _1: xs$1,
            _2: b$1
          },
          ann: defgenToString$2(f$1.ann.print, Belt_List.map(xs$1, (function (x) {
                      return x.ann.print;
                    })), b$1.ann.print)
        };
        break;
    
  }
  return {
          it: d$1.it,
          ann: {
            sourceLocation: sourceLocation,
            print: {
              it: d$1.ann,
              ann: {
                nodeKind: "Definition",
                sourceLocation: sourceLocation
              }
            }
          }
        };
}

function obToString$1(ob, ctx) {
  return Belt_Option.map(ob, (function (b) {
                return printBlock$2(b, {
                            TAG: "Stat",
                            _0: ctx
                          });
              }));
}

function printBlockHelper$1(param, ctx) {
  var sourceLocation = param.ann;
  var b = param.it;
  var annPrint = function (print) {
    return {
            it: print,
            ann: {
              nodeKind: "Block",
              sourceLocation: sourceLocation
            }
          };
  };
  if (b.TAG === "BRet") {
    var e = printExp$2(b._0, {
          TAG: "Stat",
          _0: ctx
        });
    var print = annPrint({
          TAG: "Group",
          _0: {
            hd: e.ann.print,
            tl: /* [] */0
          }
        });
    return {
            it: {
              TAG: "BRet",
              _0: e
            },
            ann: {
              sourceLocation: sourceLocation,
              print: print
            }
          };
  }
  var t = printTerm$2(b._0, "Step");
  var b$1 = printBlockHelper$1(b._1, ctx);
  var print$1 = annPrint(s([
            "",
            "\n",
            ""
          ], [
            t.ann.print,
            b$1.ann.print
          ]));
  return {
          it: {
            TAG: "BCons",
            _0: t,
            _1: b$1
          },
          ann: {
            sourceLocation: sourceLocation,
            print: print$1
          }
        };
}

function printBlock$2(b, ctx) {
  var sourceLocation = b.ann;
  var it = b.it;
  if (it.TAG === "BRet" && ctx.TAG === "Expr") {
    var e = printExp$2(it._0, {
          TAG: "Expr",
          _0: ctx._0
        });
    return {
            it: {
              TAG: "BRet",
              _0: e
            },
            ann: {
              sourceLocation: sourceLocation,
              print: {
                it: {
                  TAG: "Group",
                  _0: {
                    hd: e.ann.print,
                    tl: /* [] */0
                  }
                },
                ann: {
                  nodeKind: "Block",
                  sourceLocation: sourceLocation
                }
              }
            }
          };
  }
  if (ctx.TAG !== "Expr") {
    return printBlockHelper$1({
                it: it,
                ann: sourceLocation
              }, ctx._0);
  }
  throw {
        RE_EXN_ID: SMoLPrintError,
        _1: "JavaScript blocks can't be used as expressions in general",
        Error: new Error()
      };
}

function printTerm$2(param, ctx) {
  var sourceLocation = param.ann;
  var it = param.it;
  if (it.TAG === "Def") {
    var it$1 = printDef$2(it._0);
    return {
            it: {
              TAG: "Def",
              _0: it$1
            },
            ann: {
              sourceLocation: sourceLocation,
              print: {
                it: {
                  TAG: "Group",
                  _0: {
                    hd: it$1.ann.print,
                    tl: /* [] */0
                  }
                },
                ann: undefined
              }
            }
          };
  }
  var it$2 = printExp$2(it._0, {
        TAG: "Stat",
        _0: ctx
      });
  return {
          it: {
            TAG: "Exp",
            _0: it$2
          },
          ann: {
            sourceLocation: sourceLocation,
            print: {
              it: {
                TAG: "Group",
                _0: {
                  hd: it$2.ann.print,
                  tl: /* [] */0
                }
              },
              ann: undefined
            }
          }
        };
}

function printOutputlet$2(o) {
  var p = function (v) {
    switch (v.TAG) {
      case "Ref" :
          return "[...]";
      case "Con" :
          return constantToString$2(v._0);
      case "Struct" :
          var content = v._1;
          var i = "";
          var content$1;
          if (content.TAG === "Lst") {
            throw {
                  RE_EXN_ID: SMoLPrintError,
                  _1: "Lists are not supported in JavaScript.",
                  Error: new Error()
                };
          }
          var es = content._0;
          content$1 = es ? "[ " + Belt_List.toArray(Belt_List.map(es, p)).join(", ") + " ]" : "[]";
          return i + content$1;
      
    }
  };
  if (typeof o !== "object") {
    return "error";
  } else {
    return p(o._0);
  }
}

function printOutput$2(sepOpt, os) {
  var sep = sepOpt !== undefined ? sepOpt : " ";
  return Belt_List.toArray(Belt_List.map(os, printOutputlet$2)).join(sep);
}

function printProgramFull$2(insertPrintTopLevel, p) {
  var p$1 = insertPrintTopLevel ? insertTopLevelPrint(p) : p;
  var print = function (param) {
    var sourceLocation = param.ann;
    var it = param.it;
    var annPrint = function (print) {
      return {
              sourceLocation: sourceLocation,
              print: {
                it: print,
                ann: {
                  nodeKind: "Program",
                  sourceLocation: sourceLocation
                }
              }
            };
    };
    if (typeof it !== "object") {
      return {
              it: "PNil",
              ann: {
                sourceLocation: sourceLocation,
                print: {
                  it: {
                    TAG: "Plain",
                    _0: ""
                  },
                  ann: {
                    nodeKind: "Program",
                    sourceLocation: sourceLocation
                  }
                }
              }
            };
    }
    var t = printTerm$2(it._0, "Step");
    var p = print(it._1);
    return {
            it: {
              TAG: "PCons",
              _0: t,
              _1: p
            },
            ann: annPrint({
                  TAG: "Group",
                  _0: {
                    hd: t.ann.print,
                    tl: {
                      hd: {
                        it: {
                          TAG: "Plain",
                          _0: p.it === "PNil" ? "" : "\n"
                        },
                        ann: undefined
                      },
                      tl: {
                        hd: p.ann.print,
                        tl: /* [] */0
                      }
                    }
                  }
                })
          };
  };
  return print(p$1);
}

function printProgram$2(insertPrintTopLevel, p) {
  return toString(printProgramFull$2(insertPrintTopLevel, p).ann.print);
}

function printStandAloneTerm$2(param) {
  var it = param.it;
  var tmp;
  if (it.TAG === "Def") {
    var it$1 = printDef$2(it._0);
    tmp = it$1.ann.print;
  } else {
    var it$2 = printExp$2(it._0, {
          TAG: "Stat",
          _0: "Step"
        });
    var sourceLocation = it$2.ann.sourceLocation;
    tmp = extract(it$2.ann.print, {
          nodeKind: "Expression",
          sourceLocation: sourceLocation
        }, toString$8);
  }
  return toString(tmp);
}

function printName$3(x) {
  return x;
}

function constantToString$3(c) {
  if (typeof c !== "object") {
    if (c === "Uni") {
      return "Nothing";
    } else {
      return "list[]";
    }
  }
  switch (c.TAG) {
    case "Num" :
        return String(c._0);
    case "Lgc" :
        if (c._0) {
          return "True";
        } else {
          return "False";
        }
    case "Str" :
        return JSON.stringify(c._0);
    case "Sym" :
        return c._0;
    
  }
}

function listToString$2(es) {
  if (Belt_List.some(es, containsNL)) {
    return {
            TAG: "Group",
            _0: {
              hd: {
                it: {
                  TAG: "Plain",
                  _0: "("
                },
                ann: undefined
              },
              tl: {
                hd: indentBlock({
                      it: concat(",\n", es),
                      ann: undefined
                    }, 4),
                tl: {
                  hd: {
                    it: {
                      TAG: "Plain",
                      _0: ")"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          };
  } else {
    return {
            TAG: "Group",
            _0: {
              hd: {
                it: {
                  TAG: "Plain",
                  _0: "("
                },
                ann: undefined
              },
              tl: {
                hd: {
                  it: concat(", ", es),
                  ann: undefined
                },
                tl: {
                  hd: {
                    it: {
                      TAG: "Plain",
                      _0: ")"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          };
  }
}

function exprAppToString$2(e, es) {
  return {
          TAG: "Group",
          _0: {
            hd: e,
            tl: {
              hd: {
                it: listToString$2(es),
                ann: undefined
              },
              tl: /* [] */0
            }
          }
        };
}

function consumeContext$2(ctx, ann, e) {
  var e$1 = ann(e);
  if (ctx.TAG === "Expr") {
    return e$1;
  } else if (ctx._0 === "Step") {
    return {
            it: s([
                  "",
                  ""
                ], [e$1]),
            ann: undefined
          };
  } else {
    return {
            it: s([
                  "return ",
                  ""
                ], [e$1]),
            ann: undefined
          };
  }
}

function paren$2(e) {
  return s([
              "(",
              ")"
            ], [{
                it: e,
                ann: undefined
              }]);
}

function consumeContextWrapEvenReturn$2(ctx, ann, e) {
  if (ctx.TAG === "Expr") {
    if (ctx._0) {
      return ann(paren$2(e));
    } else {
      return ann(e);
    }
  } else if (ctx._0 === "Step") {
    return {
            it: s([
                  "",
                  ""
                ], [ann(e)]),
            ann: undefined
          };
  } else {
    return {
            it: s([
                  "return ",
                  ""
                ], [ann(paren$2(e))]),
            ann: undefined
          };
  }
}

function consumeContextWrap$2(ctx, ann, e) {
  if (ctx.TAG === "Expr") {
    if (ctx._0) {
      return ann(paren$2(e));
    } else {
      return ann(e);
    }
  } else if (ctx._0 === "Step") {
    return {
            it: s([
                  "",
                  ""
                ], [ann(e)]),
            ann: undefined
          };
  } else {
    return {
            it: s([
                  "return ",
                  ""
                ], [ann(e)]),
            ann: undefined
          };
  }
}

function consumeContextVoid$2(ctx, ann, e) {
  var e$1 = ann(e);
  if (ctx.TAG === "Expr") {
    return e$1;
  } else if (ctx._0 === "Step") {
    return {
            it: s([
                  "",
                  ""
                ], [e$1]),
            ann: undefined
          };
  } else {
    return {
            it: s([
                  "",
                  "\nreturn"
                ], [e$1]),
            ann: undefined
          };
  }
}

function consumeContextEscapeWrap$2(ctx, ann, e) {
  var e$1 = ann(e);
  if (ctx.TAG === "Expr") {
    return e$1;
  } else {
    return {
            it: s([
                  "",
                  ""
                ], [e$1]),
            ann: undefined
          };
  }
}

function consumeContextStat$2(ctx, ann, e) {
  var e$1 = ann(e);
  if (ctx.TAG !== "Expr") {
    if (ctx._0 === "Step") {
      return {
              it: s([
                    "",
                    ""
                  ], [e$1]),
              ann: undefined
            };
    } else {
      return {
              it: s([
                    "",
                    "\nreturn"
                  ], [e$1]),
              ann: undefined
            };
    }
  }
  var err = toString(e$1) + " can't be used as a expression in Pseudocode";
  throw {
        RE_EXN_ID: SMoLPrintError,
        _1: err,
        Error: new Error()
      };
}

function stringOfArith$2(o) {
  switch (o) {
    case "Add" :
        return "+";
    case "Sub" :
        return "-";
    case "Mul" :
        return "*";
    case "Div" :
        return "/";
    
  }
}

function stringOfCmp$2(o) {
  switch (o) {
    case "Lt" :
        return "<";
    case "Eq" :
        return "===";
    case "Gt" :
        return ">";
    case "Le" :
        return "<=";
    case "Ge" :
        return ">=";
    case "Ne" :
        return "!=";
    case "NumEq" :
    case "Equal" :
        return "==";
    
  }
}

function exprAppPrmToString$2(ann, ctx, p, es) {
  if (typeof p !== "object") {
    switch (p) {
      case "PairNew" :
          if (es) {
            var match = es.tl;
            if (match && !match.tl) {
              var e1 = es.hd(false);
              var e2 = match.hd(false);
              return {
                      it: [
                        "PairNew",
                        {
                          hd: e1,
                          tl: {
                            hd: e2,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContext$2(ctx, ann, s([
                                "vec[ ",
                                ", ",
                                " ]"
                              ], [
                                e1.ann.print,
                                e2.ann.print
                              ]))
                    };
            }
            
          }
          break;
      case "PairRefLeft" :
          if (es && !es.tl) {
            var e1$1 = es.hd(true);
            return {
                    it: [
                      "PairRefLeft",
                      {
                        hd: e1$1,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$2(ctx, ann, s([
                              "",
                              "[0]"
                            ], [e1$1.ann.print]))
                  };
          }
          break;
      case "PairRefRight" :
          if (es && !es.tl) {
            var e1$2 = es.hd(true);
            return {
                    it: [
                      "PairRefRight",
                      {
                        hd: e1$2,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$2(ctx, ann, s([
                              "",
                              "[1]"
                            ], [e1$2.ann.print]))
                  };
          }
          break;
      case "PairSetLeft" :
          if (es) {
            var match$1 = es.tl;
            if (match$1 && !match$1.tl) {
              var e1$3 = es.hd(false);
              var e2$1 = match$1.hd(false);
              return {
                      it: [
                        "PairSetLeft",
                        {
                          hd: e1$3,
                          tl: {
                            hd: e2$1,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContextStat$2(ctx, ann, s([
                                "",
                                "[0] = ",
                                ""
                              ], [
                                e1$3.ann.print,
                                e2$1.ann.print
                              ]))
                    };
            }
            
          }
          break;
      case "PairSetRight" :
          if (es) {
            var match$2 = es.tl;
            if (match$2 && !match$2.tl) {
              var e1$4 = es.hd(false);
              var e2$2 = match$2.hd(false);
              return {
                      it: [
                        "PairSetRight",
                        {
                          hd: e1$4,
                          tl: {
                            hd: e2$2,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContextStat$2(ctx, ann, s([
                                "",
                                "[1] = ",
                                ""
                              ], [
                                e1$4.ann.print,
                                e2$2.ann.print
                              ]))
                    };
            }
            
          }
          break;
      case "VecNew" :
          var es$1 = Belt_List.map(es, (function (e) {
                  return e(false);
                }));
          return {
                  it: [
                    "VecNew",
                    es$1
                  ],
                  ann: consumeContext$2(ctx, ann, s([
                            "vec[ ",
                            " ]"
                          ], [{
                              it: concat(", ", Belt_List.map(es$1, (function (e) {
                                          return e.ann.print;
                                        }))),
                              ann: undefined
                            }]))
                };
      case "VecRef" :
          if (es) {
            var match$3 = es.tl;
            if (match$3 && !match$3.tl) {
              var e1$5 = es.hd(true);
              var e2$3 = match$3.hd(false);
              return {
                      it: [
                        "VecRef",
                        {
                          hd: e1$5,
                          tl: {
                            hd: e2$3,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContext$2(ctx, ann, s([
                                "",
                                "[",
                                "]"
                              ], [
                                e1$5.ann.print,
                                e2$3.ann.print
                              ]))
                    };
            }
            
          }
          break;
      case "VecSet" :
          if (es) {
            var match$4 = es.tl;
            if (match$4) {
              var match$5 = match$4.tl;
              if (match$5 && !match$5.tl) {
                var e1$6 = es.hd(true);
                var e2$4 = match$4.hd(false);
                var e3 = match$5.hd(false);
                return {
                        it: [
                          "VecSet",
                          {
                            hd: e1$6,
                            tl: {
                              hd: e2$4,
                              tl: {
                                hd: e3,
                                tl: /* [] */0
                              }
                            }
                          }
                        ],
                        ann: consumeContextStat$2(ctx, ann, s([
                                  "",
                                  "[",
                                  "] = ",
                                  ""
                                ], [
                                  e1$6.ann.print,
                                  e2$4.ann.print,
                                  e3.ann.print
                                ]))
                      };
              }
              
            }
            
          }
          break;
      case "VecLen" :
          if (es && !es.tl) {
            var e1$7 = es.hd(false);
            return {
                    it: [
                      "VecLen",
                      {
                        hd: e1$7,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$2(ctx, ann, s([
                              "length(",
                              ")"
                            ], [e1$7.ann.print]))
                  };
          }
          break;
      case "Err" :
          if (es && !es.tl) {
            var e1$8 = es.hd(true);
            return {
                    it: [
                      "Err",
                      {
                        hd: e1$8,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextEscapeWrap$2(ctx, ann, s([
                              "raise ",
                              ""
                            ], [e1$8.ann.print]))
                  };
          }
          break;
      case "Not" :
          if (es && !es.tl) {
            var e1$9 = es.hd(true);
            return {
                    it: [
                      "Not",
                      {
                        hd: e1$9,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextWrap$2(ctx, ann, s([
                              "Â¬ ",
                              ""
                            ], [e1$9.ann.print]))
                  };
          }
          break;
      case "ZeroP" :
          if (es && !es.tl) {
            var e1$10 = es.hd(true);
            return {
                    it: [
                      "ZeroP",
                      {
                        hd: e1$10,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextWrap$2(ctx, ann, s([
                              "",
                              " == 0"
                            ], [e1$10.ann.print]))
                  };
          }
          break;
      case "Print" :
          if (es && !es.tl) {
            var e1$11 = es.hd(false);
            return {
                    it: [
                      "Print",
                      {
                        hd: e1$11,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextVoid$2(ctx, ann, s([
                              "print(",
                              ")"
                            ], [e1$11.ann.print]))
                  };
          }
          break;
      case "Next" :
          if (es && !es.tl) {
            var e1$12 = es.hd(false);
            return {
                    it: [
                      "Next",
                      {
                        hd: e1$12,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextVoid$2(ctx, ann, s([
                              "next(",
                              ")"
                            ], [e1$12.ann.print]))
                  };
          }
          break;
      case "Maybe" :
      case "StringAppend" :
          break;
      case "Cons" :
          if (es) {
            var match$6 = es.tl;
            if (match$6 && !match$6.tl) {
              var e1$13 = es.hd(false);
              var e2$5 = match$6.hd(false);
              return {
                      it: [
                        "Cons",
                        {
                          hd: e1$13,
                          tl: {
                            hd: e2$5,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContext$2(ctx, ann, s([
                                "list[ ",
                                ", ...",
                                " ]"
                              ], [
                                e1$13.ann.print,
                                e2$5.ann.print
                              ]))
                    };
            }
            
          }
          break;
      case "List" :
          var es$2 = Belt_List.map(es, (function (e) {
                  return e(false);
                }));
          return {
                  it: [
                    "List",
                    es$2
                  ],
                  ann: consumeContext$2(ctx, ann, s([
                            "list[ ",
                            " ]"
                          ], [{
                              it: concat(", ", Belt_List.map(es$2, (function (e) {
                                          return e.ann.print;
                                        }))),
                              ann: undefined
                            }]))
                };
      case "EmptyP" :
          if (es && !es.tl) {
            var e1$14 = es.hd(false);
            return {
                    it: [
                      "EmptyP",
                      {
                        hd: e1$14,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$2(ctx, ann, s([
                              "is-empty(",
                              ")"
                            ], [e1$14.ann.print]))
                  };
          }
          break;
      case "First" :
          if (es && !es.tl) {
            var e1$15 = es.hd(true);
            return {
                    it: [
                      "First",
                      {
                        hd: e1$15,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$2(ctx, ann, s([
                              "",
                              ".first"
                            ], [e1$15.ann.print]))
                  };
          }
          break;
      case "Rest" :
          if (es && !es.tl) {
            var e1$16 = es.hd(true);
            return {
                    it: [
                      "Rest",
                      {
                        hd: e1$16,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$2(ctx, ann, s([
                              "",
                              ".rest"
                            ], [e1$16.ann.print]))
                  };
          }
          break;
      
    }
  } else {
    if (p.TAG === "Arith") {
      var o = p._0;
      var es$3 = Belt_List.map(es, (function (e) {
              return e(true);
            }));
      return {
              it: [
                {
                  TAG: "Arith",
                  _0: o
                },
                es$3
              ],
              ann: consumeContextWrap$2(ctx, ann, concat(" " + stringOfArith$2(o) + " ", Belt_List.map(es$3, (function (e) {
                              return e.ann.print;
                            }))))
            };
    }
    if (es) {
      var match$7 = es.tl;
      if (match$7 && !match$7.tl) {
        var o$1 = p._0;
        var e1$17 = es.hd(true);
        var e2$6 = match$7.hd(true);
        var it = stringOfCmp$2(o$1);
        return {
                it: [
                  {
                    TAG: "Cmp",
                    _0: o$1
                  },
                  {
                    hd: e1$17,
                    tl: {
                      hd: e2$6,
                      tl: /* [] */0
                    }
                  }
                ],
                ann: consumeContextWrap$2(ctx, ann, s([
                          "",
                          " ",
                          " ",
                          ""
                        ], [
                          e1$17.ann.print,
                          {
                            it: {
                              TAG: "Plain",
                              _0: it
                            },
                            ann: undefined
                          },
                          e2$6.ann.print
                        ]))
              };
      }
      
    }
    
  }
  var err = "Pseudocode doesn't let you use " + toString$1(p) + " on " + String(Belt_List.length(es)) + " parameter(s).";
  throw {
        RE_EXN_ID: SMoLPrintError,
        _1: err,
        Error: new Error()
      };
}

function funLike$2(op, x, xs, e) {
  return s([
              "",
              " ",
              ":",
              "\nend"
            ], [
              {
                it: {
                  TAG: "Plain",
                  _0: op
                },
                ann: undefined
              },
              {
                it: exprAppToString$2(x, xs),
                ann: undefined
              },
              indentBlock(e, 2)
            ]);
}

function defvarToString$3(x, e) {
  return s([
              "let ",
              " = ",
              ""
            ], [
              x,
              e
            ]);
}

function deffunToString$3(f, xs, b) {
  return funLike$2("fun", f, xs, b);
}

function defgenToString$3(f, xs, b) {
  return funLike$2("gen fun", f, xs, b);
}

function exprSetToString$3(x, e) {
  return s([
              "",
              " = ",
              ""
            ], [
              x,
              e
            ]);
}

function exprLamToString$3(xs, b) {
  return s([
              "lam (",
              "):",
              "\nend"
            ], [
              xs,
              indentBlock(b, 2)
            ]);
}

function exprYieldToString$3(e) {
  return s([
              "yield ",
              ""
            ], [e]);
}

function exprBeginToString(es, e) {
  return s([
              "begin:",
              "\nend"
            ], [indentBlock({
                    it: concat("\n", Belt_List.concatMany([
                              es,
                              {
                                hd: e,
                                tl: /* [] */0
                              }
                            ])),
                    ann: undefined
                  }, 2)]);
}

function ifStat$2(cnd, thn, els) {
  return s([
              "if ",
              ":",
              "",
              "\nend"
            ], [
              cnd,
              indentBlock(thn, 2),
              {
                it: els !== undefined ? s([
                        "\nelse:",
                        ""
                      ], [indentBlock(els, 2)]) : s([""], []),
                ann: undefined
              }
            ]);
}

function exprCndToString$3(ebs, ob) {
  if (ebs === /* [] */0) {
    throw {
          RE_EXN_ID: SMoLPrintError,
          _1: "`else`-only conditional is not supported by Pseudo.",
          Error: new Error()
        };
  }
  var ebs$1 = Belt_List.map(ebs, (function (param) {
          return {
                  it: s([
                        "if ",
                        ":",
                        ""
                      ], [
                        param[0],
                        indentBlock(param[1], 2)
                      ]),
                  ann: undefined
                };
        }));
  var ebs$2 = ob !== undefined ? Belt_List.concatMany([
          ebs$1,
          {
            hd: {
              it: s([
                    "e:",
                    ""
                  ], [indentBlock(ob, 2)]),
              ann: undefined
            },
            tl: /* [] */0
          }
        ]) : ebs$1;
  return s([
              "",
              "\nend"
            ], [{
                it: concat("\nels", ebs$2),
                ann: undefined
              }]);
}

function exprIfToString$3(e_cnd, e_thn, e_els) {
  return s([
              "",
              " if ",
              " else ",
              ""
            ], [
              e_thn,
              e_cnd,
              e_els
            ]);
}

function exprAndToString$3(e_ns) {
  if (e_ns === /* [] */0) {
    return s(["True"], []);
  } else {
    return concat(" â§ ", e_ns);
  }
}

function exprOrToString$3(e_ns) {
  if (e_ns === /* [] */0) {
    return s(["False"], []);
  } else {
    return concat(" â¨ ", e_ns);
  }
}

function symbolToString$3(param) {
  var sourceLocation = param.ann;
  var it = param.it;
  return {
          it: it,
          ann: {
            sourceLocation: sourceLocation,
            print: {
              it: {
                TAG: "Plain",
                _0: it
              },
              ann: {
                nodeKind: "Name",
                sourceLocation: sourceLocation
              }
            }
          }
        };
}

function exprLetToString(k, xes, b) {
  var ann;
  switch (k) {
    case "Plain" :
        ann = "";
        break;
    case "Nested" :
        ann = "*";
        break;
    case "Recursive" :
        ann = "rec";
        break;
    
  }
  var xes_it = concat("\n", xes);
  var xes$1 = {
    it: xes_it,
    ann: undefined
  };
  return s([
              "let",
              ":",
              "\ndo:",
              "\nend"
            ], [
              {
                it: {
                  TAG: "Plain",
                  _0: ann
                },
                ann: undefined
              },
              indentBlock(xes$1, 2),
              indentBlock(b, 2)
            ]);
}

function printBind(param) {
  var sourceLocation = param.ann;
  var match = param.it;
  var x = symbolToString$3(match[0]);
  var e = printExp$3(match[1], {
        TAG: "Expr",
        _0: false
      });
  var print_it = s([
        "",
        " = ",
        ""
      ], [
        x.ann.print,
        e.ann.print
      ]);
  var print_ann = {
    nodeKind: "Bind",
    sourceLocation: sourceLocation
  };
  var print = {
    it: print_it,
    ann: print_ann
  };
  return {
          it: [
            x,
            e
          ],
          ann: {
            sourceLocation: sourceLocation,
            print: print
          }
        };
}

function printExp$3(param, ctx) {
  var sourceLocation = param.ann;
  var it = param.it;
  var ann = function (it) {
    return {
            it: it,
            ann: {
              nodeKind: "Expression",
              sourceLocation: sourceLocation
            }
          };
  };
  switch (it.TAG) {
    case "Con" :
        var c = it._0;
        return {
                it: {
                  TAG: "Con",
                  _0: c
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContext$2(ctx, ann, {
                        TAG: "Plain",
                        _0: constantToString$3(c)
                      })
                }
              };
    case "Ref" :
        var x = it._0;
        return {
                it: {
                  TAG: "Ref",
                  _0: x
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContext$2(ctx, ann, {
                        TAG: "Plain",
                        _0: x
                      })
                }
              };
    case "Set" :
        var x$1 = symbolToString$3(it._0);
        var e = printExp$3(it._1, {
              TAG: "Expr",
              _0: false
            });
        return {
                it: {
                  TAG: "Set",
                  _0: x$1,
                  _1: e
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextStat$2(ctx, ann, exprSetToString$3(x$1.ann.print, e.ann.print))
                }
              };
    case "Lam" :
        var xs = Belt_List.map(it._0, symbolToString$3);
        var b = printBlock$3(it._1, {
              TAG: "Stat",
              _0: "Return"
            });
        return {
                it: {
                  TAG: "Lam",
                  _0: xs,
                  _1: b
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrap$2(ctx, ann, exprLamToString$3({
                            it: concat(",", Belt_List.map(xs, (function (x) {
                                        return x.ann.print;
                                      }))),
                            ann: undefined
                          }, b.ann.print))
                }
              };
    case "Let" :
        var k = it._0;
        var xes = Belt_List.map(it._1, printBind);
        var b$1 = printBlock$3(it._2, ctx);
        return {
                it: {
                  TAG: "Let",
                  _0: k,
                  _1: xes,
                  _2: b$1
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContext$2(ctx, ann, exprLetToString(k, Belt_List.map(xes, (function (xe) {
                                  return xe.ann.print;
                                })), b$1.ann.print))
                }
              };
    case "AppPrm" :
        var es = Belt_List.map(it._1, (function (e) {
                return function (b) {
                  return printExp$3(e, {
                              TAG: "Expr",
                              _0: b
                            });
                };
              }));
        var match = exprAppPrmToString$2(ann, ctx, it._0, es);
        var match$1 = match.it;
        return {
                it: {
                  TAG: "AppPrm",
                  _0: match$1[0],
                  _1: match$1[1]
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: match.ann
                }
              };
    case "App" :
        var e$1 = printExp$3(it._0, {
              TAG: "Expr",
              _0: true
            });
        var es$1 = Belt_List.map(it._1, (function (e) {
                return printExp$3(e, {
                            TAG: "Expr",
                            _0: false
                          });
              }));
        return {
                it: {
                  TAG: "App",
                  _0: e$1,
                  _1: es$1
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContext$2(ctx, ann, exprAppToString$2(e$1.ann.print, Belt_List.map(es$1, (function (e) {
                                  return e.ann.print;
                                }))))
                }
              };
    case "Bgn" :
        var es$2 = Belt_List.map(it._0, (function (e_k) {
                return printExp$3(e_k, {
                            TAG: "Expr",
                            _0: false
                          });
              }));
        var e$2 = printExp$3(it._1, {
              TAG: "Expr",
              _0: false
            });
        return {
                it: {
                  TAG: "Bgn",
                  _0: es$2,
                  _1: e$2
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrap$2(ctx, ann, exprBeginToString(Belt_List.map(es$2, (function (e) {
                                  return e.ann.print;
                                })), e$2.ann.print))
                }
              };
    case "If" :
        var e_els = it._2;
        var e_thn = it._1;
        var e_cnd = it._0;
        if (ctx.TAG === "Expr") {
          var e_cnd$1 = printExp$3(e_cnd, {
                TAG: "Expr",
                _0: false
              });
          var e_thn$1 = printExp$3(e_thn, {
                TAG: "Expr",
                _0: false
              });
          var e_els$1 = printExp$3(e_els, {
                TAG: "Expr",
                _0: false
              });
          return {
                  it: {
                    TAG: "If",
                    _0: e_cnd$1,
                    _1: e_thn$1,
                    _2: e_els$1
                  },
                  ann: {
                    sourceLocation: sourceLocation,
                    print: consumeContextWrap$2({
                          TAG: "Expr",
                          _0: ctx._0
                        }, ann, exprIfToString$3(e_cnd$1.ann.print, e_thn$1.ann.print, e_els$1.ann.print))
                  }
                };
        }
        var ctx$1 = ctx._0;
        var e_cnd$2 = printExp$3(e_cnd, {
              TAG: "Expr",
              _0: false
            });
        var e_thn$2 = printExp$3(e_thn, {
              TAG: "Stat",
              _0: ctx$1
            });
        var e_els$2 = printExp$3(e_els, {
              TAG: "Stat",
              _0: ctx$1
            });
        return {
                it: {
                  TAG: "If",
                  _0: e_cnd$2,
                  _1: e_thn$2,
                  _2: e_els$2
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: ann(ifStat$2(e_cnd$2.ann.print, e_thn$2.ann.print, e_els$2.ann.print))
                }
              };
    case "And" :
        var e_ns = Belt_List.map(it._0, (function (e_k) {
                return printExp$3(e_k, {
                            TAG: "Expr",
                            _0: false
                          });
              }));
        return {
                it: {
                  TAG: "And",
                  _0: e_ns
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrap$2(ctx, ann, exprAndToString$3(Belt_List.map(e_ns, (function (e_k) {
                                  return e_k.ann.print;
                                }))))
                }
              };
    case "Or" :
        var e_ns$1 = Belt_List.map(it._0, (function (e_k) {
                return printExp$3(e_k, {
                            TAG: "Expr",
                            _0: false
                          });
              }));
        return {
                it: {
                  TAG: "Or",
                  _0: e_ns$1
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrap$2(ctx, ann, exprOrToString$3(Belt_List.map(e_ns$1, (function (e_k) {
                                  return e_k.ann.print;
                                }))))
                }
              };
    case "Cnd" :
        if (ctx.TAG === "Expr") {
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "Multi-armed conditionals in Pseudocode is not supported by the translator yet.",
                Error: new Error()
              };
        }
        var ctx$2 = ctx._0;
        var ebs = Belt_List.map(it._0, (function (eb) {
                return [
                        printExp$3(eb[0], {
                              TAG: "Expr",
                              _0: false
                            }),
                        printBlock$3(eb[1], {
                              TAG: "Stat",
                              _0: ctx$2
                            })
                      ];
              }));
        var ob = obToString$2(it._1, ctx$2);
        return {
                it: {
                  TAG: "Cnd",
                  _0: ebs,
                  _1: ob
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: ann(exprCndToString$3(Belt_List.map(ebs, (function (param) {
                                  return [
                                          param[0].ann.print,
                                          param[1].ann.print
                                        ];
                                })), Belt_Option.map(ob, (function (b) {
                                  return b.ann.print;
                                }))))
                }
              };
    case "GLam" :
        var xs$1 = Belt_List.map(it._0, symbolToString$3);
        var b$2 = printBlock$3(it._1, {
              TAG: "Stat",
              _0: "Return"
            });
        return {
                it: {
                  TAG: "GLam",
                  _0: xs$1,
                  _1: b$2
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrap$2(ctx, ann, exprLamToString$3({
                            it: concat(",", Belt_List.map(xs$1, (function (x) {
                                        return x.ann.print;
                                      }))),
                            ann: undefined
                          }, b$2.ann.print))
                }
              };
    case "Yield" :
        var e$3 = printExp$3(it._0, {
              TAG: "Expr",
              _0: false
            });
        return {
                it: {
                  TAG: "Yield",
                  _0: e$3
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrapEvenReturn$2(ctx, ann, exprYieldToString$3(e$3.ann.print))
                }
              };
    
  }
}

function printDef$3(param) {
  var sourceLocation = param.ann;
  var d = param.it;
  var d$1;
  switch (d.TAG) {
    case "Var" :
        var x = symbolToString$3(d._0);
        var e = printExp$3(d._1, {
              TAG: "Expr",
              _0: false
            });
        d$1 = {
          it: {
            TAG: "Var",
            _0: x,
            _1: e
          },
          ann: defvarToString$3(x.ann.print, e.ann.print)
        };
        break;
    case "Fun" :
        var f = symbolToString$3(d._0);
        var xs = Belt_List.map(d._1, symbolToString$3);
        var b = printBlock$3(d._2, {
              TAG: "Stat",
              _0: "Return"
            });
        d$1 = {
          it: {
            TAG: "Fun",
            _0: f,
            _1: xs,
            _2: b
          },
          ann: deffunToString$3(f.ann.print, Belt_List.map(xs, (function (x) {
                      return x.ann.print;
                    })), b.ann.print)
        };
        break;
    case "GFun" :
        var f$1 = symbolToString$3(d._0);
        var xs$1 = Belt_List.map(d._1, symbolToString$3);
        var b$1 = printBlock$3(d._2, {
              TAG: "Stat",
              _0: "Return"
            });
        d$1 = {
          it: {
            TAG: "GFun",
            _0: f$1,
            _1: xs$1,
            _2: b$1
          },
          ann: defgenToString$3(f$1.ann.print, Belt_List.map(xs$1, (function (x) {
                      return x.ann.print;
                    })), b$1.ann.print)
        };
        break;
    
  }
  return {
          it: d$1.it,
          ann: {
            sourceLocation: sourceLocation,
            print: {
              it: d$1.ann,
              ann: {
                nodeKind: "Definition",
                sourceLocation: sourceLocation
              }
            }
          }
        };
}

function obToString$2(ob, ctx) {
  return Belt_Option.map(ob, (function (b) {
                return printBlock$3(b, {
                            TAG: "Stat",
                            _0: ctx
                          });
              }));
}

function printBlockHelper$2(param, ctx) {
  var sourceLocation = param.ann;
  var b = param.it;
  var annPrint = function (print) {
    return {
            it: print,
            ann: {
              nodeKind: "Block",
              sourceLocation: sourceLocation
            }
          };
  };
  if (b.TAG === "BRet") {
    var e = printExp$3(b._0, {
          TAG: "Stat",
          _0: ctx
        });
    var print = annPrint({
          TAG: "Group",
          _0: {
            hd: e.ann.print,
            tl: /* [] */0
          }
        });
    return {
            it: {
              TAG: "BRet",
              _0: e
            },
            ann: {
              sourceLocation: sourceLocation,
              print: print
            }
          };
  }
  var t = printTerm$3(b._0, "Step");
  var b$1 = printBlockHelper$2(b._1, ctx);
  var print$1 = annPrint(s([
            "",
            "\n",
            ""
          ], [
            t.ann.print,
            b$1.ann.print
          ]));
  return {
          it: {
            TAG: "BCons",
            _0: t,
            _1: b$1
          },
          ann: {
            sourceLocation: sourceLocation,
            print: print$1
          }
        };
}

function printBlock$3(b, ctx) {
  var sourceLocation = b.ann;
  var it = b.it;
  var annOfPrint = function (print) {
    return {
            sourceLocation: sourceLocation,
            print: {
              it: print,
              ann: {
                nodeKind: "Block",
                sourceLocation: sourceLocation
              }
            }
          };
  };
  if (it.TAG === "BRet" && ctx.TAG === "Expr") {
    var e = printExp$3(it._0, {
          TAG: "Expr",
          _0: ctx._0
        });
    return {
            it: {
              TAG: "BRet",
              _0: e
            },
            ann: annOfPrint({
                  TAG: "Group",
                  _0: {
                    hd: e.ann.print,
                    tl: /* [] */0
                  }
                })
          };
  }
  if (ctx.TAG !== "Expr") {
    return printBlockHelper$2({
                it: it,
                ann: sourceLocation
              }, ctx._0);
  }
  throw {
        RE_EXN_ID: SMoLPrintError,
        _1: "Pseudocode blocks can't be used as expressions in general.",
        Error: new Error()
      };
}

function printTerm$3(param, ctx) {
  var sourceLocation = param.ann;
  var it = param.it;
  if (it.TAG === "Def") {
    var it$1 = printDef$3(it._0);
    return {
            it: {
              TAG: "Def",
              _0: it$1
            },
            ann: {
              sourceLocation: sourceLocation,
              print: {
                it: {
                  TAG: "Group",
                  _0: {
                    hd: it$1.ann.print,
                    tl: /* [] */0
                  }
                },
                ann: undefined
              }
            }
          };
  }
  var it$2 = printExp$3(it._0, {
        TAG: "Stat",
        _0: ctx
      });
  return {
          it: {
            TAG: "Exp",
            _0: it$2
          },
          ann: {
            sourceLocation: sourceLocation,
            print: {
              it: {
                TAG: "Group",
                _0: {
                  hd: it$2.ann.print,
                  tl: /* [] */0
                }
              },
              ann: undefined
            }
          }
        };
}

function printOutputlet$3(o) {
  var p = function (v) {
    switch (v.TAG) {
      case "Ref" :
          return "[...]";
      case "Con" :
          return constantToString$3(v._0);
      case "Struct" :
          var content = v._1;
          var i = "";
          var content$1;
          content$1 = content.TAG === "Lst" ? "list[ " + Belt_List.toArray(Belt_List.map(content._0, p)).join(", ") + " ]" : "vec[ " + Belt_List.toArray(Belt_List.map(content._0, p)).join(", ") + " ]";
          return i + content$1;
      
    }
  };
  if (typeof o !== "object") {
    return "error";
  } else {
    return p(o._0);
  }
}

function printOutput$3(sepOpt, os) {
  var sep = sepOpt !== undefined ? sepOpt : " ";
  return Belt_List.toArray(Belt_List.map(os, printOutputlet$3)).join(sep);
}

function printProgramFull$3(insertPrintTopLevel, p) {
  var p$1 = insertPrintTopLevel ? insertTopLevelPrint(p) : p;
  var print = function (param) {
    var sourceLocation = param.ann;
    var it = param.it;
    var annPrint = function (print) {
      return {
              sourceLocation: sourceLocation,
              print: {
                it: print,
                ann: {
                  nodeKind: "Program",
                  sourceLocation: sourceLocation
                }
              }
            };
    };
    if (typeof it !== "object") {
      return {
              it: "PNil",
              ann: {
                sourceLocation: sourceLocation,
                print: {
                  it: {
                    TAG: "Plain",
                    _0: ""
                  },
                  ann: {
                    nodeKind: "Program",
                    sourceLocation: sourceLocation
                  }
                }
              }
            };
    }
    var t = printTerm$3(it._0, "Step");
    var p = print(it._1);
    return {
            it: {
              TAG: "PCons",
              _0: t,
              _1: p
            },
            ann: annPrint({
                  TAG: "Group",
                  _0: {
                    hd: t.ann.print,
                    tl: {
                      hd: p.it === "PNil" ? ({
                            it: {
                              TAG: "Plain",
                              _0: ""
                            },
                            ann: undefined
                          }) : ({
                            it: {
                              TAG: "Plain",
                              _0: "\n"
                            },
                            ann: undefined
                          }),
                      tl: {
                        hd: p.ann.print,
                        tl: /* [] */0
                      }
                    }
                  }
                })
          };
  };
  return print(p$1);
}

function printProgram$3(insertPrintTopLevel, p) {
  return toString(printProgramFull$3(insertPrintTopLevel, p).ann.print);
}

function printStandAloneTerm$3(t) {
  return toString(printTerm$3(t, "Step").ann.print);
}

var involveMutation = {
  contents: false
};

var type_assignment = {
  contents: Object.fromEntries([])
};

function stringFromType(t) {
  if (typeof t !== "object") {
    switch (t) {
      case "Uni" :
          return "Unit";
      case "Num" :
          return "Int";
      case "Lgc" :
          return "Boolean";
      case "Str" :
          return "String";
      
    }
  } else {
    switch (t.TAG) {
      case "Var" :
          return "Int";
      case "Vecof" :
          return "Buffer[" + stringFromType(t._0) + "]";
      case "Lstof" :
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "List",
                Error: new Error()
              };
      case "Funof" :
          return "(" + Caml_splice_call.spliceObjApply(", ", "concat", [Belt_List.toArray(Belt_List.map(t.args, stringFromType))]) + ") => " + stringFromType(t.out);
      
    }
  }
}

function lookup_type(srcLoc) {
  return stringFromType(Belt_Option.getWithDefault(type_assignment.contents[SExpression.SourceLocation.toString(srcLoc)], "Num"));
}

function makeVec(es) {
  if (involveMutation.contents) {
    return s([
                "Buffer(",
                ")"
              ], [{
                  it: concat(", ", es),
                  ann: undefined
                }]);
  } else {
    return s([
                "(",
                ")"
              ], [{
                  it: concat(", ", es),
                  ann: undefined
                }]);
  }
}

function printName$4(x) {
  var re = /-./g;
  var matchFn = function (matchPart, _offset, _wholeString) {
    return matchPart.substring(1).toUpperCase();
  };
  var x$1 = x.replace(re, matchFn);
  if (x$1 === "var") {
    return "$var";
  } else {
    return x$1;
  }
}

function constantToString$4(c) {
  if (typeof c !== "object") {
    if (c === "Uni") {
      return "undefined";
    }
    throw {
          RE_EXN_ID: SMoLPrintError,
          _1: "Lists are not supported in JavaScript.",
          Error: new Error()
        };
  } else {
    switch (c.TAG) {
      case "Num" :
          return String(c._0);
      case "Lgc" :
          if (c._0) {
            return "true";
          } else {
            return "false";
          }
      case "Str" :
          return JSON.stringify(c._0);
      case "Sym" :
          return c._0;
      
    }
  }
}

function listToString$3(es) {
  if (es === /* [] */0) {
    if (involveMutation.contents) {
      return {
              TAG: "Plain",
              _0: "()"
            };
    } else {
      return {
              TAG: "Plain",
              _0: ""
            };
    }
  } else if (Belt_List.some(es, containsNL)) {
    return {
            TAG: "Group",
            _0: {
              hd: {
                it: {
                  TAG: "Plain",
                  _0: "("
                },
                ann: undefined
              },
              tl: {
                hd: indentBlock({
                      it: concat(",\n", es),
                      ann: undefined
                    }, 4),
                tl: {
                  hd: {
                    it: {
                      TAG: "Plain",
                      _0: ")"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          };
  } else {
    return {
            TAG: "Group",
            _0: {
              hd: {
                it: {
                  TAG: "Plain",
                  _0: "("
                },
                ann: undefined
              },
              tl: {
                hd: {
                  it: concat(", ", es),
                  ann: undefined
                },
                tl: {
                  hd: {
                    it: {
                      TAG: "Plain",
                      _0: ")"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          };
  }
}

function exprAppToString$3(e, es) {
  return {
          TAG: "Group",
          _0: {
            hd: e,
            tl: {
              hd: {
                it: listToString$3(es),
                ann: undefined
              },
              tl: /* [] */0
            }
          }
        };
}

function paren$3(e) {
  return s([
              "(",
              ")"
            ], [{
                it: e,
                ann: undefined
              }]);
}

function consumeContextWrap$3(ctx, ann, e) {
  if (ctx) {
    return ann(paren$3(e));
  } else {
    return ann(e);
  }
}

function stringOfArith$3(o) {
  switch (o) {
    case "Add" :
        return "+";
    case "Sub" :
        return "-";
    case "Mul" :
        return "*";
    case "Div" :
        return "/";
    
  }
}

function stringOfCmp$3(o) {
  switch (o) {
    case "Lt" :
        return "<";
    case "Eq" :
        return "eq";
    case "Gt" :
        return ">";
    case "Le" :
        return "<=";
    case "Ge" :
        return ">=";
    case "Ne" :
        return "!=";
    case "NumEq" :
    case "Equal" :
        return "==";
    
  }
}

function exprAppPrmToString$3(ann, ctx, p, es) {
  if (typeof p !== "object") {
    switch (p) {
      case "PairNew" :
          if (es) {
            var match = es.tl;
            if (match && !match.tl) {
              var e1 = es.hd(false);
              var e2 = match.hd(false);
              return {
                      it: [
                        "PairNew",
                        {
                          hd: e1,
                          tl: {
                            hd: e2,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: ann(makeVec({
                                hd: e1.ann.print,
                                tl: {
                                  hd: e2.ann.print,
                                  tl: /* [] */0
                                }
                              }))
                    };
            }
            
          }
          break;
      case "PairRefLeft" :
          if (es && !es.tl) {
            var e1$1 = es.hd(true);
            return {
                    it: [
                      "PairRefLeft",
                      {
                        hd: e1$1,
                        tl: /* [] */0
                      }
                    ],
                    ann: ann(s([
                              "",
                              "(0)"
                            ], [e1$1.ann.print]))
                  };
          }
          break;
      case "PairRefRight" :
          if (es && !es.tl) {
            var e1$2 = es.hd(true);
            return {
                    it: [
                      "PairRefRight",
                      {
                        hd: e1$2,
                        tl: /* [] */0
                      }
                    ],
                    ann: ann(s([
                              "",
                              "(1)"
                            ], [e1$2.ann.print]))
                  };
          }
          break;
      case "PairSetLeft" :
          if (es) {
            var match$1 = es.tl;
            if (match$1 && !match$1.tl) {
              var e1$3 = es.hd(false);
              var e2$1 = match$1.hd(false);
              return {
                      it: [
                        "PairSetLeft",
                        {
                          hd: e1$3,
                          tl: {
                            hd: e2$1,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: ann(s([
                                "",
                                "(0) = ",
                                ""
                              ], [
                                e1$3.ann.print,
                                e2$1.ann.print
                              ]))
                    };
            }
            
          }
          break;
      case "PairSetRight" :
          if (es) {
            var match$2 = es.tl;
            if (match$2 && !match$2.tl) {
              var e1$4 = es.hd(false);
              var e2$2 = match$2.hd(false);
              return {
                      it: [
                        "PairSetRight",
                        {
                          hd: e1$4,
                          tl: {
                            hd: e2$2,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: ann(s([
                                "",
                                "(1) = ",
                                ""
                              ], [
                                e1$4.ann.print,
                                e2$2.ann.print
                              ]))
                    };
            }
            
          }
          break;
      case "VecNew" :
          var es$1 = Belt_List.map(es, (function (e) {
                  return e(false);
                }));
          return {
                  it: [
                    "VecNew",
                    es$1
                  ],
                  ann: ann(makeVec(Belt_List.map(es$1, (function (e) {
                                  return e.ann.print;
                                }))))
                };
      case "VecRef" :
          if (es) {
            var match$3 = es.tl;
            if (match$3 && !match$3.tl) {
              var e1$5 = es.hd(true);
              var e2$3 = match$3.hd(false);
              return {
                      it: [
                        "VecRef",
                        {
                          hd: e1$5,
                          tl: {
                            hd: e2$3,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: ann(s([
                                "",
                                "(",
                                ")"
                              ], [
                                e1$5.ann.print,
                                e2$3.ann.print
                              ]))
                    };
            }
            
          }
          break;
      case "VecSet" :
          if (es) {
            var match$4 = es.tl;
            if (match$4) {
              var match$5 = match$4.tl;
              if (match$5 && !match$5.tl) {
                var e1$6 = es.hd(true);
                var e2$4 = match$4.hd(false);
                var e3 = match$5.hd(false);
                return {
                        it: [
                          "VecSet",
                          {
                            hd: e1$6,
                            tl: {
                              hd: e2$4,
                              tl: {
                                hd: e3,
                                tl: /* [] */0
                              }
                            }
                          }
                        ],
                        ann: ann(s([
                                  "",
                                  "(",
                                  ") = ",
                                  ""
                                ], [
                                  e1$6.ann.print,
                                  e2$4.ann.print,
                                  e3.ann.print
                                ]))
                      };
              }
              
            }
            
          }
          break;
      case "VecLen" :
          if (es && !es.tl) {
            var e1$7 = es.hd(true);
            return {
                    it: [
                      "VecLen",
                      {
                        hd: e1$7,
                        tl: /* [] */0
                      }
                    ],
                    ann: ann(s([
                              "",
                              ".length"
                            ], [e1$7.ann.print]))
                  };
          }
          break;
      case "Err" :
          if (es && !es.tl) {
            var e1$8 = es.hd(true);
            return {
                    it: [
                      "Err",
                      {
                        hd: e1$8,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextWrap$3(ctx, ann, s([
                              "throw new RuntimeException(",
                              ")"
                            ], [e1$8.ann.print]))
                  };
          }
          break;
      case "Not" :
          if (es && !es.tl) {
            var e1$9 = es.hd(true);
            return {
                    it: [
                      "Not",
                      {
                        hd: e1$9,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextWrap$3(ctx, ann, s([
                              "! ",
                              ""
                            ], [e1$9.ann.print]))
                  };
          }
          break;
      case "ZeroP" :
          if (es && !es.tl) {
            var e1$10 = es.hd(true);
            return {
                    it: [
                      "ZeroP",
                      {
                        hd: e1$10,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextWrap$3(ctx, ann, s([
                              "",
                              " == 0"
                            ], [e1$10.ann.print]))
                  };
          }
          break;
      case "Print" :
          if (es && !es.tl) {
            var e1$11 = es.hd(false);
            return {
                    it: [
                      "Print",
                      {
                        hd: e1$11,
                        tl: /* [] */0
                      }
                    ],
                    ann: ann(s([
                              "println(",
                              ")"
                            ], [e1$11.ann.print]))
                  };
          }
          break;
      case "Next" :
          if (es && !es.tl) {
            var e1$12 = es.hd(true);
            return {
                    it: [
                      "Next",
                      {
                        hd: e1$12,
                        tl: /* [] */0
                      }
                    ],
                    ann: ann(s([
                              "",
                              ".next()"
                            ], [e1$12.ann.print]))
                  };
          }
          break;
      case "Maybe" :
      case "StringAppend" :
          break;
      case "Cons" :
      case "List" :
      case "EmptyP" :
      case "First" :
      case "Rest" :
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "List is not supported by Scala.",
                Error: new Error()
              };
      
    }
  } else {
    if (p.TAG === "Arith") {
      var o = p._0;
      var es$2 = Belt_List.map(es, (function (e) {
              return e(true);
            }));
      return {
              it: [
                {
                  TAG: "Arith",
                  _0: o
                },
                es$2
              ],
              ann: consumeContextWrap$3(ctx, ann, concat(" " + stringOfArith$3(o) + " ", Belt_List.map(es$2, (function (e) {
                              return e.ann.print;
                            }))))
            };
    }
    if (es) {
      var match$6 = es.tl;
      if (match$6 && !match$6.tl) {
        var o$1 = p._0;
        var e1$13 = es.hd(true);
        var e2$5 = match$6.hd(true);
        var it = stringOfCmp$3(o$1);
        return {
                it: [
                  {
                    TAG: "Cmp",
                    _0: o$1
                  },
                  {
                    hd: e1$13,
                    tl: {
                      hd: e2$5,
                      tl: /* [] */0
                    }
                  }
                ],
                ann: consumeContextWrap$3(ctx, ann, s([
                          "",
                          " ",
                          " ",
                          ""
                        ], [
                          e1$13.ann.print,
                          {
                            it: {
                              TAG: "Plain",
                              _0: it
                            },
                            ann: undefined
                          },
                          e2$5.ann.print
                        ]))
              };
      }
      
    }
    
  }
  var err = "Scala doesn't let you use " + toString$1(p) + " on " + String(Belt_List.length(es)) + " parameter(s).";
  throw {
        RE_EXN_ID: SMoLPrintError,
        _1: err,
        Error: new Error()
      };
}

function defvarToString$4(x, e) {
  if (involveMutation.contents) {
    return s([
                "var ",
                " = ",
                ""
              ], [
                x,
                e
              ]);
  } else {
    return s([
                "val ",
                " = ",
                ""
              ], [
                x,
                e
              ]);
  }
}

function deffunToString$4(f, xs, ts, b) {
  var op = "def";
  return s([
              "",
              " ",
              " =",
              ""
            ], [
              {
                it: {
                  TAG: "Plain",
                  _0: op
                },
                ann: undefined
              },
              {
                it: exprAppToString$3(f, Belt_List.map(Belt_List.zip(xs, ts), (function (param) {
                            return {
                                    it: s([
                                          "",
                                          " : ",
                                          ""
                                        ], [
                                          param[0],
                                          param[1]
                                        ]),
                                    ann: undefined
                                  };
                          }))),
                ann: undefined
              },
              indentBlock(b, 2)
            ]);
}

function exprSetToString$4(x, e) {
  return s([
              "",
              " = ",
              ""
            ], [
              x,
              e
            ]);
}

function exprLamToString$4(xs, b) {
  return s([
              "(",
              ") =>",
              ""
            ], [
              xs,
              indentBlock(b, 2)
            ]);
}

function ifStat$3(cnd, thn, els) {
  return s([
              "if (",
              ") {",
              "\n}",
              ""
            ], [
              cnd,
              indentBlock(thn, 2),
              {
                it: els !== undefined ? s([
                        " else {",
                        "\n}"
                      ], [indentBlock(els, 2)]) : s([""], []),
                ann: undefined
              }
            ]);
}

function exprCndToString$4(ebs, ob) {
  var ebs$1 = Belt_List.map(ebs, (function (param) {
          return {
                  it: ifStat$3(param[0], param[1], undefined),
                  ann: undefined
                };
        }));
  var ebs$2 = ob !== undefined ? Belt_List.concatMany([
          ebs$1,
          {
            hd: {
              it: s([
                    "{",
                    "\n}"
                  ], [indentBlock(ob, 2)]),
              ann: undefined
            },
            tl: /* [] */0
          }
        ]) : ebs$1;
  return concat(" else ", ebs$2);
}

function exprIfToString$4(e_cnd, e_thn, e_els) {
  return s([
              "if (",
              ") {",
              "\n} else {",
              "\n}"
            ], [
              e_cnd,
              indentBlock(e_thn, 2),
              indentBlock(e_els, 2)
            ]);
}

function exprAndToString$4(e_ns) {
  if (e_ns === /* [] */0) {
    return s(["true"], []);
  } else {
    return concat(" && ", e_ns);
  }
}

function exprOrToString$4(e_ns) {
  if (e_ns === /* [] */0) {
    return s(["false"], []);
  } else {
    return concat(" || ", e_ns);
  }
}

function symbolToString$4(param) {
  var sourceLocation = param.ann;
  var it = param.it;
  return {
          it: it,
          ann: {
            sourceLocation: sourceLocation,
            print: {
              it: {
                TAG: "Plain",
                _0: printName$4(it)
              },
              ann: {
                nodeKind: "Name",
                sourceLocation: sourceLocation
              }
            }
          }
        };
}

function printExp$4(param, ctx) {
  var sourceLocation = param.ann;
  var it = param.it;
  var ann = function (it) {
    return {
            it: it,
            ann: {
              nodeKind: "Expression",
              sourceLocation: sourceLocation
            }
          };
  };
  switch (it.TAG) {
    case "Con" :
        var c = it._0;
        return {
                it: {
                  TAG: "Con",
                  _0: c
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: ann({
                        TAG: "Plain",
                        _0: constantToString$4(c)
                      })
                }
              };
    case "Ref" :
        var x = it._0;
        return {
                it: {
                  TAG: "Ref",
                  _0: x
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: ann({
                        TAG: "Plain",
                        _0: printName$4(x)
                      })
                }
              };
    case "Set" :
        var x$1 = symbolToString$4(it._0);
        var e = printExp$4(it._1, false);
        return {
                it: {
                  TAG: "Set",
                  _0: x$1,
                  _1: e
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: ann(exprSetToString$4(x$1.ann.print, e.ann.print))
                }
              };
    case "Lam" :
        var xs = Belt_List.map(it._0, symbolToString$4);
        var b = printBlock$4(it._1, false);
        return {
                it: {
                  TAG: "Lam",
                  _0: xs,
                  _1: b
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrap$3(ctx, ann, exprLamToString$4({
                            it: concat(", ", Belt_List.map(xs, (function (x) {
                                        var it = lookup_type(x.ann.sourceLocation);
                                        return {
                                                it: s([
                                                      "",
                                                      " : ",
                                                      ""
                                                    ], [
                                                      x.ann.print,
                                                      {
                                                        it: {
                                                          TAG: "Plain",
                                                          _0: it
                                                        },
                                                        ann: undefined
                                                      }
                                                    ]),
                                                ann: undefined
                                              };
                                      }))),
                            ann: undefined
                          }, b.ann.print))
                }
              };
    case "Let" :
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "let-expressions are not supported by Scala.",
              Error: new Error()
            };
    case "AppPrm" :
        var es = Belt_List.map(it._1, (function (e) {
                return function (b) {
                  return printExp$4(e, b);
                };
              }));
        var match = exprAppPrmToString$3(ann, ctx, it._0, es);
        var match$1 = match.it;
        return {
                it: {
                  TAG: "AppPrm",
                  _0: match$1[0],
                  _1: match$1[1]
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: match.ann
                }
              };
    case "App" :
        var e$1 = printExp$4(it._0, true);
        var es$1 = Belt_List.map(it._1, (function (e) {
                return printExp$4(e, false);
              }));
        return {
                it: {
                  TAG: "App",
                  _0: e$1,
                  _1: es$1
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: ann(exprAppToString$3(e$1.ann.print, Belt_List.map(es$1, (function (e) {
                                  return e.ann.print;
                                }))))
                }
              };
    case "Bgn" :
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "`begin` expressions are not supported by Scala.",
              Error: new Error()
            };
    case "If" :
        var e_cnd = printExp$4(it._0, false);
        var e_thn = printExp$4(it._1, false);
        var e_els = printExp$4(it._2, false);
        return {
                it: {
                  TAG: "If",
                  _0: e_cnd,
                  _1: e_thn,
                  _2: e_els
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrap$3(ctx, ann, exprIfToString$4(e_cnd.ann.print, e_thn.ann.print, e_els.ann.print))
                }
              };
    case "And" :
        var e_ns = Belt_List.map(it._0, (function (e_k) {
                return printExp$4(e_k, false);
              }));
        return {
                it: {
                  TAG: "And",
                  _0: e_ns
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrap$3(ctx, ann, exprAndToString$4(Belt_List.map(e_ns, (function (e_k) {
                                  return e_k.ann.print;
                                }))))
                }
              };
    case "Or" :
        var e_ns$1 = Belt_List.map(it._0, (function (e_k) {
                return printExp$4(e_k, false);
              }));
        return {
                it: {
                  TAG: "Or",
                  _0: e_ns$1
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: consumeContextWrap$3(ctx, ann, exprOrToString$4(Belt_List.map(e_ns$1, (function (e_k) {
                                  return e_k.ann.print;
                                }))))
                }
              };
    case "Cnd" :
        var ebs = Belt_List.map(it._0, (function (eb) {
                return [
                        printExp$4(eb[0], false),
                        printBlock$4(eb[1], false)
                      ];
              }));
        var ob = obToString$3(it._1);
        return {
                it: {
                  TAG: "Cnd",
                  _0: ebs,
                  _1: ob
                },
                ann: {
                  sourceLocation: sourceLocation,
                  print: ann(exprCndToString$4(Belt_List.map(ebs, (function (param) {
                                  return [
                                          param[0].ann.print,
                                          param[1].ann.print
                                        ];
                                })), Belt_Option.map(ob, (function (b) {
                                  return b.ann.print;
                                }))))
                }
              };
    case "GLam" :
    case "Yield" :
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "Generators are not supported by Scala.",
              Error: new Error()
            };
    
  }
}

function printDef$4(param) {
  var sourceLocation = param.ann;
  var d = param.it;
  var d$1;
  switch (d.TAG) {
    case "Var" :
        var x = symbolToString$4(d._0);
        var e = printExp$4(d._1, false);
        d$1 = {
          it: {
            TAG: "Var",
            _0: x,
            _1: e
          },
          ann: defvarToString$4(x.ann.print, e.ann.print)
        };
        break;
    case "Fun" :
        var f = symbolToString$4(d._0);
        var xs = Belt_List.map(d._1, symbolToString$4);
        var b = printBlock$4(d._2, false);
        d$1 = {
          it: {
            TAG: "Fun",
            _0: f,
            _1: xs,
            _2: b
          },
          ann: deffunToString$4(f.ann.print, Belt_List.map(xs, (function (x) {
                      return x.ann.print;
                    })), Belt_List.map(xs, (function (x) {
                      var it = lookup_type(x.ann.sourceLocation);
                      return {
                              it: {
                                TAG: "Plain",
                                _0: it
                              },
                              ann: undefined
                            };
                    })), b.ann.print)
        };
        break;
    case "GFun" :
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "Generators are not supported by Scala.",
              Error: new Error()
            };
    
  }
  return {
          it: d$1.it,
          ann: {
            sourceLocation: sourceLocation,
            print: {
              it: d$1.ann,
              ann: {
                nodeKind: "Definition",
                sourceLocation: sourceLocation
              }
            }
          }
        };
}

function obToString$3(ob) {
  return Belt_Option.map(ob, (function (b) {
                return printBlock$4(b, false);
              }));
}

function printBlock$4(b, _ctx) {
  var p = function (param) {
    var sourceLocation = param.ann;
    var it = param.it;
    var tmp;
    if (it.TAG === "BRet") {
      var e = printExp$4(it._0, false);
      tmp = {
        it: {
          TAG: "BRet",
          _0: e
        },
        ann: {
          TAG: "Group",
          _0: {
            hd: e.ann.print,
            tl: /* [] */0
          }
        }
      };
    } else {
      var t = printTerm$4(it._0);
      var b = p(it._1);
      tmp = {
        it: {
          TAG: "BCons",
          _0: t,
          _1: b
        },
        ann: s([
              "",
              "\n",
              ""
            ], [
              t.ann.print,
              b.ann.print
            ])
      };
    }
    return {
            it: tmp.it,
            ann: {
              sourceLocation: sourceLocation,
              print: {
                it: tmp.ann,
                ann: {
                  nodeKind: "Block",
                  sourceLocation: sourceLocation
                }
              }
            }
          };
  };
  return p(b);
}

function printTerm$4(param) {
  var sourceLocation = param.ann;
  var it = param.it;
  if (it.TAG === "Def") {
    var it$1 = printDef$4(it._0);
    return {
            it: {
              TAG: "Def",
              _0: it$1
            },
            ann: {
              sourceLocation: sourceLocation,
              print: {
                it: {
                  TAG: "Group",
                  _0: {
                    hd: it$1.ann.print,
                    tl: /* [] */0
                  }
                },
                ann: undefined
              }
            }
          };
  }
  var it$2 = printExp$4(it._0, false);
  return {
          it: {
            TAG: "Exp",
            _0: it$2
          },
          ann: {
            sourceLocation: sourceLocation,
            print: {
              it: {
                TAG: "Group",
                _0: {
                  hd: it$2.ann.print,
                  tl: /* [] */0
                }
              },
              ann: undefined
            }
          }
        };
}

function printOutputlet$4(o) {
  var p = function (v) {
    switch (v.TAG) {
      case "Ref" :
          return "(...)";
      case "Con" :
          return constantToString$4(v._0);
      case "Struct" :
          var content = v._1;
          var i = "";
          var content$1;
          if (content.TAG === "Lst") {
            throw {
                  RE_EXN_ID: SMoLPrintError,
                  _1: "Lists are not supported in Scala.",
                  Error: new Error()
                };
          }
          content$1 = toString({
                it: makeVec(Belt_List.map(Belt_List.map(content._0, p), fromString)),
                ann: undefined
              });
          return i + content$1;
      
    }
  };
  if (typeof o !== "object") {
    return "error";
  } else {
    return p(o._0);
  }
}

function printOutput$4(sepOpt, os) {
  var sep = sepOpt !== undefined ? sepOpt : " ";
  involveMutation.contents = true;
  return Belt_List.toArray(Belt_List.map(os, printOutputlet$4)).join(sep);
}

function printProgramFull$4(insertPrintTopLevel, p) {
  var p$1 = insertPrintTopLevel ? insertTopLevelPrint(p) : p;
  var s = printProgram(insertPrintTopLevel, p$1);
  var mutVar = Js_string.includes("(set! ", s);
  var mutVec = Js_string.includes("(vec-set! ", s) || Js_string.includes("(set-left! ", s) || Js_string.includes("(set-right! ", s);
  involveMutation.contents = mutVar || mutVec;
  type_assignment.contents = Object.fromEntries([]);
  var print = function (param) {
    var sourceLocation = param.ann;
    var it = param.it;
    var annPrint = function (print) {
      return {
              sourceLocation: sourceLocation,
              print: {
                it: print,
                ann: {
                  nodeKind: "Program",
                  sourceLocation: sourceLocation
                }
              }
            };
    };
    if (typeof it !== "object") {
      return {
              it: "PNil",
              ann: {
                sourceLocation: sourceLocation,
                print: {
                  it: {
                    TAG: "Plain",
                    _0: ""
                  },
                  ann: {
                    nodeKind: "Program",
                    sourceLocation: sourceLocation
                  }
                }
              }
            };
    }
    var t = printTerm$4(it._0);
    var p = print(it._1);
    return {
            it: {
              TAG: "PCons",
              _0: t,
              _1: p
            },
            ann: annPrint({
                  TAG: "Group",
                  _0: {
                    hd: t.ann.print,
                    tl: {
                      hd: p.it === "PNil" ? ({
                            it: {
                              TAG: "Plain",
                              _0: ""
                            },
                            ann: undefined
                          }) : ({
                            it: {
                              TAG: "Plain",
                              _0: "\n"
                            },
                            ann: undefined
                          }),
                      tl: {
                        hd: p.ann.print,
                        tl: /* [] */0
                      }
                    }
                  }
                })
          };
  };
  return print(p$1);
}

function printProgram$4(insertPrintTopLevel, p) {
  return toString(printProgramFull$4(insertPrintTopLevel, p).ann.print);
}

function printStandAloneTerm$4(param) {
  var it = param.it;
  var tmp;
  if (it.TAG === "Def") {
    var it$1 = printDef$4(it._0);
    tmp = it$1.ann.print;
  } else {
    var it$2 = printExp$4(it._0, false);
    tmp = it$2.ann.print;
  }
  return toString(tmp);
}

function toString$10(t) {
  switch (t.TAG) {
    case "ParseError" :
        return "ParseError: " + toString$7(t._0);
    case "PrintError" :
        return "PrintError: " + t._0;
    case "KindError" :
        return "KindError: " + t._0;
    
  }
}

var TranslateError = {
  toString: toString$10
};

var SMoLTranslateError = /* @__PURE__ */Caml_exceptions.create("SMoL.SMoLTranslateError");

function programAsTerm(p) {
  var match = p.it;
  if (typeof match !== "object") {
    throw {
          RE_EXN_ID: SMoLTranslateError,
          _1: {
            TAG: "KindError",
            _0: "Expecting a term, given a program"
          },
          Error: new Error()
        };
  }
  var tmp = match._1.it;
  if (typeof tmp !== "object") {
    return match._0;
  }
  throw {
        RE_EXN_ID: SMoLTranslateError,
        _1: {
          TAG: "KindError",
          _0: "Expecting a term, given a program"
        },
        Error: new Error()
      };
}

function translateOutput(src, sepOpt) {
  var sep = sepOpt !== undefined ? sepOpt : " ";
  var output;
  try {
    output = parseOutput(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printOutput(sep, output);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateStandAloneTerm(src) {
  var p;
  try {
    p = parseProgram(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printStandAloneTerm(programAsTerm(p));
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgram(printTopLevel, src) {
  var p;
  try {
    p = parseProgram(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgram(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgramFull(printTopLevel, src) {
  var p;
  try {
    p = parseProgram(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgramFull(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

var SMoLTranslator = {
  translateName: printName,
  translateOutput: translateOutput,
  translateStandAloneTerm: translateStandAloneTerm,
  translateProgram: translateProgram,
  translateProgramFull: translateProgramFull
};

function translateOutput$1(src, sepOpt) {
  var sep = sepOpt !== undefined ? sepOpt : " ";
  var output;
  try {
    output = parseOutput(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printOutput$1(sep, output);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateStandAloneTerm$1(src) {
  var p;
  try {
    p = parseProgram(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printStandAloneTerm$1(programAsTerm(p));
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgram$1(printTopLevel, src) {
  var p;
  try {
    p = parseProgram(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgram$1(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgramFull$1(printTopLevel, src) {
  var p;
  try {
    p = parseProgram(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgramFull$1(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

var PYTranslator = {
  translateName: printName$1,
  translateOutput: translateOutput$1,
  translateStandAloneTerm: translateStandAloneTerm$1,
  translateProgram: translateProgram$1,
  translateProgramFull: translateProgramFull$1
};

function translateOutput$2(src, sepOpt) {
  var sep = sepOpt !== undefined ? sepOpt : " ";
  var output;
  try {
    output = parseOutput(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printOutput$2(sep, output);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateStandAloneTerm$2(src) {
  var p;
  try {
    p = parseProgram(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printStandAloneTerm$2(programAsTerm(p));
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgram$2(printTopLevel, src) {
  var p;
  try {
    p = parseProgram(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgram$2(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgramFull$2(printTopLevel, src) {
  var p;
  try {
    p = parseProgram(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgramFull$2(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

var JSTranslator = {
  translateName: printName$2,
  translateOutput: translateOutput$2,
  translateStandAloneTerm: translateStandAloneTerm$2,
  translateProgram: translateProgram$2,
  translateProgramFull: translateProgramFull$2
};

function translateOutput$3(src, sepOpt) {
  var sep = sepOpt !== undefined ? sepOpt : " ";
  var output;
  try {
    output = parseOutput(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printOutput$3(sep, output);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateStandAloneTerm$3(src) {
  var p;
  try {
    p = parseProgram(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printStandAloneTerm$3(programAsTerm(p));
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgram$3(printTopLevel, src) {
  var p;
  try {
    p = parseProgram(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgram$3(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgramFull$3(printTopLevel, src) {
  var p;
  try {
    p = parseProgram(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgramFull$3(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

var PCTranslator = {
  translateName: printName$3,
  translateOutput: translateOutput$3,
  translateStandAloneTerm: translateStandAloneTerm$3,
  translateProgram: translateProgram$3,
  translateProgramFull: translateProgramFull$3
};

function translateOutput$4(src, sepOpt) {
  var sep = sepOpt !== undefined ? sepOpt : " ";
  var output;
  try {
    output = parseOutput(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printOutput$4(sep, output);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateStandAloneTerm$4(src) {
  var p;
  try {
    p = parseProgram(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printStandAloneTerm$4(programAsTerm(p));
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgram$4(printTopLevel, src) {
  var p;
  try {
    p = parseProgram(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgram$4(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgramFull$4(printTopLevel, src) {
  var p;
  try {
    p = parseProgram(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "ParseError",
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgramFull$4(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: "PrintError",
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

var SCTranslator = {
  translateName: printName$4,
  translateOutput: translateOutput$4,
  translateStandAloneTerm: translateStandAloneTerm$4,
  translateProgram: translateProgram$4,
  translateProgramFull: translateProgramFull$4
};

var Print = {
  toString: toString,
  toSourceMap: toSourceMap,
  fromString: fromString,
  map: map,
  concat2: concat2,
  concat: concat,
  wrap: wrap,
  dummy: dummy,
  includes: includes,
  s: s
};

var Parser = {
  parseOutput: parseOutput,
  parseProgram: parseProgram
};

var SMoLPrinter = {
  printName: printName,
  printOutputlet: printOutputlet,
  printOutput: printOutput,
  printStandAloneTerm: printStandAloneTerm,
  printProgram: printProgram,
  printProgramFull: printProgramFull
};

var PYPrinter = {
  printName: printName$1,
  printOutputlet: printOutputlet$1,
  printOutput: printOutput$1,
  printStandAloneTerm: printStandAloneTerm$1,
  printProgram: printProgram$1,
  printProgramFull: printProgramFull$1
};

var JSPrinter = {
  printName: printName$2,
  printOutputlet: printOutputlet$2,
  printOutput: printOutput$2,
  printStandAloneTerm: printStandAloneTerm$2,
  printProgram: printProgram$2,
  printProgramFull: printProgramFull$2
};

var PCPrinter = {
  printName: printName$3,
  printOutputlet: printOutputlet$3,
  printOutput: printOutput$3,
  printStandAloneTerm: printStandAloneTerm$3,
  printProgram: printProgram$3,
  printProgramFull: printProgramFull$3
};

var SCPrinter = {
  printName: printName$4,
  printOutputlet: printOutputlet$4,
  printOutput: printOutput$4,
  printStandAloneTerm: printStandAloneTerm$4,
  printProgram: printProgram$4,
  printProgramFull: printProgramFull$4
};

export {
  Print ,
  Primitive ,
  LetKind ,
  xsOfBlock ,
  xsOfProgram ,
  NodeKind ,
  SExprKind ,
  Arity ,
  TermKind ,
  ParseError ,
  SMoLParseError ,
  Parser ,
  SMoLPrintError ,
  KindedSourceLocation ,
  SMoLPrinter ,
  PYPrinter ,
  JSPrinter ,
  PCPrinter ,
  SCPrinter ,
  TranslateError ,
  SMoLTranslateError ,
  SMoLTranslator ,
  PYTranslator ,
  JSTranslator ,
  PCTranslator ,
  SCTranslator ,
}
/* type_assignment Not a pure module */
