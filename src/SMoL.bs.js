// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as $$String from "rescript/lib/es6/string.js";
import * as Belt_Map from "rescript/lib/es6/belt_Map.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Js_string from "rescript/lib/es6/js_string.js";
import * as Belt_Float from "rescript/lib/es6/belt_Float.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as SExpression from "@brownplt/s-expression/src/SExpression.bs.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Belt_HashMapString from "rescript/lib/es6/belt_HashMapString.js";
import * as Belt_HashSetString from "rescript/lib/es6/belt_HashSetString.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function mapAnn(f, param) {
  return {
          it: Curry._1(f, param.it),
          ann: param.ann
        };
}

function toSourceMap(t, id) {
  var hMap = {
    contents: Belt_Map.make(id)
  };
  var ln = {
    contents: 0
  };
  var ch = {
    contents: 0
  };
  var f = function (param) {
    var it = param.it;
    var begin_ln = ln.contents;
    var begin_ch = ch.contents;
    var begin = {
      ln: begin_ln,
      ch: begin_ch
    };
    if (it.TAG === /* Plain */0) {
      $$String.iter((function (c) {
              if (c !== 10) {
                ch.contents = ch.contents + 1 | 0;
              } else {
                ln.contents = ln.contents + 1 | 0;
                ch.contents = 0;
              }
            }), it._0);
    } else {
      Belt_List.forEach(it._0, f);
    }
    var end_ln = ln.contents;
    var end_ch = ch.contents;
    var end = {
      ln: end_ln,
      ch: end_ch
    };
    Belt_Option.forEach(param.ann, (function (ann) {
            hMap.contents = Belt_Map.set(hMap.contents, ann, {
                  begin: begin,
                  end: end
                });
          }));
  };
  f(t);
  return hMap.contents;
}

function toString(it) {
  if (it.TAG === /* Plain */0) {
    return it._0;
  } else {
    return $$String.concat("", Belt_List.map(it._0, (function (param) {
                      return toString(param.it);
                    })));
  }
}

function map(f, it) {
  if (it.TAG === /* Plain */0) {
    return {
            TAG: /* Plain */0,
            _0: Curry._1(f, it._0)
          };
  } else {
    return {
            TAG: /* Group */1,
            _0: Belt_List.map(it._0, (function (param) {
                    return mapAnn((function (param) {
                                  return map(f, param);
                                }), param);
                  }))
          };
  }
}

function concat2(p1, s, p2) {
  return {
          TAG: /* Group */1,
          _0: {
            hd: p1,
            tl: {
              hd: {
                it: {
                  TAG: /* Plain */0,
                  _0: s
                },
                ann: undefined
              },
              tl: {
                hd: p2,
                tl: /* [] */0
              }
            }
          }
        };
}

function concat(s, ts) {
  var intersperse = function (x, ys) {
    if (!ys) {
      return /* [] */0;
    }
    var ys$1 = ys.tl;
    var y = ys.hd;
    if (!ys$1) {
      return {
              hd: y,
              tl: /* [] */0
            };
    }
    var loop = function (ys) {
      if (ys) {
        return {
                hd: x,
                tl: {
                  hd: ys.hd,
                  tl: loop(ys.tl)
                }
              };
      } else {
        return /* [] */0;
      }
    };
    return {
            hd: y,
            tl: loop(ys$1)
          };
  };
  return {
          TAG: /* Group */1,
          _0: intersperse({
                it: {
                  TAG: /* Plain */0,
                  _0: s
                },
                ann: undefined
              }, ts)
        };
}

function pad(prefix, it, suffix) {
  var prefix_it = {
    TAG: /* Plain */0,
    _0: prefix
  };
  var prefix$1 = {
    it: prefix_it,
    ann: undefined
  };
  var suffix_it = {
    TAG: /* Plain */0,
    _0: suffix
  };
  var suffix$1 = {
    it: suffix_it,
    ann: undefined
  };
  return {
          TAG: /* Group */1,
          _0: {
            hd: prefix$1,
            tl: {
              hd: it,
              tl: {
                hd: suffix$1,
                tl: /* [] */0
              }
            }
          }
        };
}

function dummyAnn(it) {
  return {
          it: it,
          ann: undefined
        };
}

function containsNL(it) {
  if (it.TAG === /* Plain */0) {
    return $$String.contains(it._0, /* '\n' */10);
  } else {
    return Belt_List.some(it._0, (function (param) {
                  return containsNL(param.it);
                }));
  }
}

function group2(s1, s2) {
  return {
          it: {
            TAG: /* Group */1,
            _0: {
              hd: s1,
              tl: {
                hd: s2,
                tl: /* [] */0
              }
            }
          },
          ann: undefined
        };
}

function surround(prefix, s, suffix) {
  return {
          TAG: /* Group */1,
          _0: {
            hd: {
              it: {
                TAG: /* Plain */0,
                _0: prefix
              },
              ann: undefined
            },
            tl: {
              hd: s,
              tl: {
                hd: {
                  it: {
                    TAG: /* Plain */0,
                    _0: suffix
                  },
                  ann: undefined
                },
                tl: /* [] */0
              }
            }
          }
        };
}

function toString$1(t) {
  if (typeof t === "number") {
    switch (t) {
      case /* PairNew */0 :
          return "mpair";
      case /* PairRefLeft */1 :
          return "left";
      case /* PairRefRight */2 :
          return "right";
      case /* PairSetLeft */3 :
          return "set-left!";
      case /* PairSetRight */4 :
          return "set-right!";
      case /* VecNew */5 :
          return "mvec";
      case /* VecRef */6 :
          return "vec-ref";
      case /* VecSet */7 :
          return "vec-set!";
      case /* VecLen */8 :
          return "vec-len";
      case /* Err */9 :
          return "error";
      case /* Not */10 :
          return "not";
      case /* Print */11 :
          return "print";
      case /* Next */12 :
          return "next";
      case /* Cons */13 :
          return "cons";
      
    }
  } else if (t.TAG === /* Arith */0) {
    switch (t._0) {
      case /* Add */0 :
          return "+";
      case /* Sub */1 :
          return "-";
      case /* Mul */2 :
          return "*";
      case /* Div */3 :
          return "/";
      
    }
  } else {
    switch (t._0) {
      case /* Lt */0 :
          return "<";
      case /* Eq */1 :
          return "eq?";
      case /* Gt */2 :
          return ">";
      case /* Le */3 :
          return "<=";
      case /* Ge */4 :
          return ">=";
      case /* Ne */5 :
          return "!=";
      
    }
  }
}

var Primitive = {
  toString: toString$1
};

function termsOfBlock(param) {
  var it = param.it;
  if (it.TAG === /* BRet */0) {
    return /* [] */0;
  } else {
    return {
            hd: it._0,
            tl: termsOfBlock(it._1)
          };
  }
}

function termsOfProgram(param) {
  var it = param.it;
  if (it) {
    return {
            hd: it._0,
            tl: termsOfProgram(it._1)
          };
  } else {
    return /* [] */0;
  }
}

function xsOfTerm(t) {
  var match = t.it;
  if (match.TAG === /* Def */0) {
    return {
            hd: match._0._0,
            tl: /* [] */0
          };
  } else {
    return /* [] */0;
  }
}

function xsOfBlock(b) {
  return Belt_List.flatten(Belt_List.map(termsOfBlock(b), xsOfTerm));
}

function xsOfProgram(p) {
  return Belt_List.flatten(Belt_List.map(termsOfProgram(p), xsOfTerm));
}

function toString$2(t) {
  if (t) {
    return "list";
  } else {
    return "atom";
  }
}

var SExprKind = {
  toString: toString$2
};

function toString$3(t) {
  switch (t) {
    case /* ExactlyOne */0 :
        return "exactly one";
    case /* ExactlyTwo */1 :
        return "exactly two";
    case /* ExactlyThree */2 :
        return "exactly three";
    case /* OneThenMany */3 :
        return "one followed by many";
    case /* ManyThenOne */4 :
        return "many followed by one";
    case /* OneThenManyThenOne */5 :
        return "one followed by several followed by one";
    
  }
}

var Arity = {
  toString: toString$3
};

function toString$4(t) {
  if (t) {
    return "expression";
  } else {
    return "definition";
  }
}

var TermKind = {
  toString: toString$4
};

function toString$5(t) {
  switch (t.TAG | 0) {
    case /* SExprParseError */0 :
        return "expecting a (valid) s-expression, but the input is not: " + t._0 + "";
    case /* SExprKindError */1 :
        return "expecting a " + t._1 + ", given " + SExpression.SExpr.toString(t._2) + "";
    case /* SExprArityError */2 :
        return "expecting " + t._1 + ", given " + $$String.concat(" ", Belt_List.map(t._2, SExpression.SExpr.toString)) + "";
    case /* LiteralSymbolError */3 :
        return "expecting a literal value, given a symbol " + t._0 + "";
    case /* LiteralListError */4 :
        return "expecting a constant or a vector, given " + SExpression.SExpr.toString(t._0) + "";
    case /* TermKindError */5 :
        var term = t._2;
        return "expecting " + t._1 + ", given something else at " + SExpression.SourcePoint.toString(term.ann.begin) + "-" + SExpression.SourcePoint.toString(term.ann.end) + "";
    
  }
}

var ParseError = {
  toString: toString$5
};

var SMoLParseError = /* @__PURE__ */Caml_exceptions.create("SMoL.SMoLParseError");

function makeProgram(ts) {
  if (!ts) {
    return {
            it: /* PNil */0,
            ann: {
              begin: {
                ln: 0,
                ch: 0
              },
              end: {
                ln: 0,
                ch: 0
              }
            }
          };
  }
  var ts$1 = ts.tl;
  var t = ts.hd;
  if (ts$1) {
    var p = makeProgram(ts$1);
    return {
            it: /* PCons */{
              _0: t,
              _1: p
            },
            ann: {
              begin: t.ann.begin,
              end: p.ann.end
            }
          };
  }
  var rest_ann = {
    begin: t.ann.end,
    end: t.ann.end
  };
  var rest = {
    it: /* PNil */0,
    ann: rest_ann
  };
  return {
          it: /* PCons */{
            _0: t,
            _1: rest
          },
          ann: t.ann
        };
}

function makeBlock(ts, e) {
  if (!ts) {
    return mapAnn((function (e) {
                  return {
                          TAG: /* BRet */0,
                          _0: e
                        };
                }), e);
  }
  var t = ts.hd;
  var b = makeBlock(ts.tl, e);
  return {
          it: {
            TAG: /* BCons */1,
            _0: t,
            _1: b
          },
          ann: {
            begin: t.ann.begin,
            end: b.ann.end
          }
        };
}

function constant_of_atom(atom) {
  if (atom.TAG === /* Str */0) {
    return {
            TAG: /* Str */2,
            _0: atom._0
          };
  }
  var x = atom._0;
  switch (x) {
    case "#f" :
        return {
                TAG: /* Lgc */1,
                _0: false
              };
    case "#t" :
        return {
                TAG: /* Lgc */1,
                _0: true
              };
    default:
      var tryNum = Belt_Float.fromString(x);
      if (tryNum !== undefined) {
        return {
                TAG: /* Num */0,
                _0: tryNum
              };
      }
      throw {
            RE_EXN_ID: SMoLParseError,
            _1: {
              TAG: /* LiteralSymbolError */3,
              _0: x
            },
            Error: new Error()
          };
  }
}

function outputletOfSExpr(e) {
  var it = e.it;
  if (it.TAG === /* Atom */0) {
    var match = it._0;
    if (match.TAG !== /* Str */0 && match._0 === "error") {
      return /* OErr */0;
    }
    
  }
  var p = function (e) {
    var atom = e.it;
    if (atom.TAG === /* Atom */0) {
      return {
              TAG: /* Con */1,
              _0: constant_of_atom(atom._0)
            };
    } else if (atom._0) {
      return {
              TAG: /* Struct */2,
              _0: undefined,
              _1: {
                TAG: /* Vec */1,
                _0: Belt_List.map(atom._2, p)
              }
            };
    } else {
      return {
              TAG: /* Struct */2,
              _0: undefined,
              _1: {
                TAG: /* Lst */0,
                _0: Belt_List.map(atom._2, p)
              }
            };
    }
  };
  return /* OVal */{
          _0: p(e)
        };
}

function parseValue(e) {
  var ann = e.ann;
  var it = e.it;
  if (it.TAG === /* Atom */0) {
    return {
            it: {
              TAG: /* Con */0,
              _0: constant_of_atom(it._0)
            },
            ann: ann
          };
  }
  if (it._0) {
    var es = Belt_List.map(it._2, parseValue);
    return {
            it: {
              TAG: /* AppPrm */6,
              _0: /* VecNew */5,
              _1: es
            },
            ann: ann
          };
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* LiteralListError */4,
          _0: e
        },
        Error: new Error()
      };
}

function as_id(context, e) {
  var match = e.it;
  if (match.TAG === /* Atom */0) {
    var x = match._0;
    if (x.TAG !== /* Str */0) {
      return {
              it: x._0,
              ann: e.ann
            };
    }
    throw {
          RE_EXN_ID: SMoLParseError,
          _1: {
            TAG: /* SExprKindError */1,
            _0: /* Atom */0,
            _1: context,
            _2: e
          },
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprKindError */1,
          _0: /* Atom */0,
          _1: context,
          _2: e
        },
        Error: new Error()
      };
}

function as_list(context, e) {
  var it = e.it;
  if (it.TAG === /* Atom */0) {
    throw {
          RE_EXN_ID: SMoLParseError,
          _1: {
            TAG: /* SExprKindError */1,
            _0: /* List */1,
            _1: context,
            _2: e
          },
          Error: new Error()
        };
  }
  if (it._0) {
    throw {
          RE_EXN_ID: SMoLParseError,
          _1: {
            TAG: /* SExprKindError */1,
            _0: /* List */1,
            _1: context,
            _2: e
          },
          Error: new Error()
        };
  }
  return {
          it: it._2,
          ann: e.ann
        };
}

function as_one_then_many(context, es) {
  if (es) {
    return [
            es.hd,
            es.tl
          ];
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* OneThenMany */3,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_many_then_one(context, es) {
  if (es) {
    var e1 = es.hd;
    var match = Belt_List.reverse(es.tl);
    if (match) {
      return [
              {
                hd: e1,
                tl: Belt_List.reverse(match.tl)
              },
              match.hd
            ];
    } else {
      return [
              /* [] */0,
              e1
            ];
    }
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* ManyThenOne */4,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_one(context, es) {
  if (es) {
    if (es.tl) {
      throw {
            RE_EXN_ID: SMoLParseError,
            _1: {
              TAG: /* SExprArityError */2,
              _0: /* ExactlyOne */0,
              _1: context,
              _2: es
            },
            Error: new Error()
          };
    }
    return es.hd;
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* ExactlyOne */0,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_two(context, es) {
  if (es) {
    var match = es.tl;
    if (match && !match.tl) {
      return [
              es.hd,
              match.hd
            ];
    }
    
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* ExactlyTwo */1,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_three(context, es) {
  if (es) {
    var match = es.tl;
    if (match) {
      var match$1 = match.tl;
      if (match$1 && !match$1.tl) {
        return [
                es.hd,
                match.hd,
                match$1.hd
              ];
      }
      
    }
    
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* ExactlyThree */2,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_one_then_many_then_one(context, es) {
  if (es) {
    var match = es.tl;
    if (match) {
      var e2 = match.hd;
      var e1 = es.hd;
      var match$1 = Belt_List.reverse(match.tl);
      if (match$1) {
        return [
                e1,
                {
                  hd: e2,
                  tl: Belt_List.reverse(match$1.tl)
                },
                match$1.hd
              ];
      } else {
        return [
                e1,
                /* [] */0,
                e2
              ];
      }
    }
    throw {
          RE_EXN_ID: SMoLParseError,
          _1: {
            TAG: /* SExprArityError */2,
            _0: /* OneThenManyThenOne */5,
            _1: context,
            _2: es
          },
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* OneThenManyThenOne */5,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_expr(context, e) {
  var it = e.it;
  if (it.TAG !== /* Def */0) {
    return {
            it: it._0,
            ann: e.ann
          };
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* TermKindError */5,
          _0: /* Expression */1,
          _1: context,
          _2: e
        },
        Error: new Error()
      };
}

function expr_of_atom(atom) {
  if (atom.TAG === /* Str */0) {
    return {
            TAG: /* Con */0,
            _0: {
              TAG: /* Str */2,
              _0: atom._0
            }
          };
  }
  var x = atom._0;
  switch (x) {
    case "#f" :
        return {
                TAG: /* Con */0,
                _0: {
                  TAG: /* Lgc */1,
                  _0: false
                }
              };
    case "#t" :
        return {
                TAG: /* Con */0,
                _0: {
                  TAG: /* Lgc */1,
                  _0: true
                }
              };
    default:
      var tryNum = Belt_Option.map(Belt_Float.fromString(x), (function (n) {
              return {
                      TAG: /* Con */0,
                      _0: {
                        TAG: /* Num */0,
                        _0: n
                      }
                    };
            }));
      return Belt_Option.getWithDefault(tryNum, {
                  TAG: /* Ref */1,
                  _0: x
                });
  }
}

function letstar(ann, xes, body) {
  if (xes) {
    var xes$1 = xes.tl;
    var xe = xes.hd;
    if (xes$1) {
      return {
              it: {
                TAG: /* Let */4,
                _0: {
                  hd: xe,
                  tl: /* [] */0
                },
                _1: makeBlock(/* [] */0, letstar({
                          begin: Belt_Option.getWithDefault(Belt_Option.map(Belt_List.head(xes$1), (function (xe) {
                                      return xe.ann.begin;
                                    })), body.ann.begin),
                          end: body.ann.end
                        }, xes$1, body))
              },
              ann: ann
            };
    } else {
      return {
              it: {
                TAG: /* Let */4,
                _0: {
                  hd: xe,
                  tl: /* [] */0
                },
                _1: body
              },
              ann: ann
            };
    }
  }
  var e = body.it;
  if (e.TAG === /* BRet */0) {
    return {
            it: e._0,
            ann: body.ann
          };
  } else {
    return {
            it: {
              TAG: /* Let */4,
              _0: /* [] */0,
              _1: body
            },
            ann: ann
          };
  }
}

function parseTerm(e) {
  var ann = e.ann;
  var atom = e.it;
  if (atom.TAG === /* Atom */0) {
    return {
            it: {
              TAG: /* Exp */1,
              _0: expr_of_atom(atom._0)
            },
            ann: ann
          };
  }
  if (atom._0) {
    var es = Belt_List.map(atom._2, parseValue);
    return {
            it: {
              TAG: /* Exp */1,
              _0: {
                TAG: /* AppPrm */6,
                _0: /* VecNew */5,
                _1: es
              }
            },
            ann: ann
          };
  }
  var es$1 = atom._2;
  if (es$1) {
    var match = es$1.hd.it;
    if (match.TAG === /* Atom */0) {
      var match$1 = match._0;
      if (match$1.TAG !== /* Str */0) {
        switch (match$1._0) {
          case "!=" :
              return makeAppPrm(ann, {
                          TAG: /* Cmp */1,
                          _0: /* Ne */5
                        }, es$1.tl);
          case "*" :
              return makeAppPrm(ann, {
                          TAG: /* Arith */0,
                          _0: /* Mul */2
                        }, es$1.tl);
          case "+" :
              return makeAppPrm(ann, {
                          TAG: /* Arith */0,
                          _0: /* Add */0
                        }, es$1.tl);
          case "-" :
              return makeAppPrm(ann, {
                          TAG: /* Arith */0,
                          _0: /* Sub */1
                        }, es$1.tl);
          case "/" :
              return makeAppPrm(ann, {
                          TAG: /* Arith */0,
                          _0: /* Div */3
                        }, es$1.tl);
          case "<" :
              return makeAppPrm(ann, {
                          TAG: /* Cmp */1,
                          _0: /* Lt */0
                        }, es$1.tl);
          case "<=" :
              return makeAppPrm(ann, {
                          TAG: /* Cmp */1,
                          _0: /* Le */3
                        }, es$1.tl);
          case ">" :
              return makeAppPrm(ann, {
                          TAG: /* Cmp */1,
                          _0: /* Gt */2
                        }, es$1.tl);
          case ">=" :
              return makeAppPrm(ann, {
                          TAG: /* Cmp */1,
                          _0: /* Ge */4
                        }, es$1.tl);
          case "begin" :
              var match$2 = as_many_then_one("one or more expressions", es$1.tl);
              var terms = Belt_List.map(Belt_List.map(match$2[0], parseTerm), (function (param) {
                      return as_expr("an expression", param);
                    }));
              var result = as_expr("an expression", parseTerm(match$2[1]));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* Bgn */8,
                          _0: terms,
                          _1: result
                        }
                      },
                      ann: ann
                    };
          case "cond" :
              var branches = Belt_List.map(Belt_List.map(es$1.tl, (function (v) {
                          return as_list("a `cond` branch", v).it;
                        })), (function (param) {
                      return as_one_then_many_then_one("the condition followed by the branch", param);
                    }));
              var _parsed = /* [] */0;
              var _branches = branches;
              while(true) {
                var branches$1 = _branches;
                var parsed = _parsed;
                if (!branches$1) {
                  return {
                          it: {
                            TAG: /* Exp */1,
                            _0: {
                              TAG: /* Cnd */10,
                              _0: Belt_List.reverse(parsed),
                              _1: undefined
                            }
                          },
                          ann: ann
                        };
                }
                var match$3 = branches$1.hd;
                var $$case = match$3[0];
                var match$4 = $$case.it;
                if (match$4.TAG === /* Atom */0) {
                  var match$5 = match$4._0;
                  if (match$5.TAG !== /* Str */0 && match$5._0 === "else" && !branches$1.tl) {
                    var terms$1 = Belt_List.map(match$3[1], parseTerm);
                    var result$1 = as_expr("an expression", parseTerm(match$3[2]));
                    return {
                            it: {
                              TAG: /* Exp */1,
                              _0: {
                                TAG: /* Cnd */10,
                                _0: Belt_List.reverse(parsed),
                                _1: makeBlock(terms$1, result$1)
                              }
                            },
                            ann: ann
                          };
                  }
                  
                }
                var $$case$1 = as_expr("a (conditional) expression", parseTerm($$case));
                var terms$2 = Belt_List.map(match$3[1], parseTerm);
                var result$2 = as_expr("an expression", parseTerm(match$3[2]));
                _branches = branches$1.tl;
                _parsed = {
                  hd: [
                    $$case$1,
                    makeBlock(terms$2, result$2)
                  ],
                  tl: parsed
                };
                continue ;
              };
          case "deffun" :
              var match$6 = as_one_then_many_then_one("a function header and a body", es$1.tl);
              var match$7 = as_one_then_many("function name followed by parameters", as_list("function name and parameters", match$6[0]).it);
              var fun = as_id("a function name", match$7[0]);
              var args = Belt_List.map(match$7[1], (function (param) {
                      return as_id("a parameter", param);
                    }));
              var terms$3 = Belt_List.map(match$6[1], parseTerm);
              var result$3 = as_expr("an expression to be returned", parseTerm(match$6[2]));
              return {
                      it: {
                        TAG: /* Def */0,
                        _0: {
                          TAG: /* Fun */1,
                          _0: fun,
                          _1: args,
                          _2: makeBlock(terms$3, result$3)
                        }
                      },
                      ann: ann
                    };
          case "defgen" :
              var match$8 = as_one_then_many_then_one("a generator header and a body", es$1.tl);
              var match$9 = as_one_then_many("generator name followed by parameters", as_list("generator name and parameters", match$8[0]).it);
              var fun$1 = as_id("a generator name", match$9[0]);
              var args$1 = Belt_List.map(match$9[1], (function (param) {
                      return as_id("a parameter", param);
                    }));
              var terms$4 = Belt_List.map(match$8[1], parseTerm);
              var result$4 = as_expr("an expression to be returned", parseTerm(match$8[2]));
              return {
                      it: {
                        TAG: /* Def */0,
                        _0: {
                          TAG: /* GFun */2,
                          _0: fun$1,
                          _1: args$1,
                          _2: makeBlock(terms$4, result$4)
                        }
                      },
                      ann: ann
                    };
          case "defvar" :
              var match$10 = as_two("a variable and an expression", es$1.tl);
              var x = as_id("a variable name", match$10[0]);
              var e$1 = as_expr("an expression", parseTerm(match$10[1]));
              return {
                      it: {
                        TAG: /* Def */0,
                        _0: {
                          TAG: /* Var */0,
                          _0: x,
                          _1: e$1
                        }
                      },
                      ann: ann
                    };
          case "=" :
          case "eq?" :
              return makeAppPrm(ann, {
                          TAG: /* Cmp */1,
                          _0: /* Eq */1
                        }, es$1.tl);
          case "error" :
              return makeAppPrm(ann, /* Err */9, es$1.tl);
          case "generator" :
              var match$11 = as_one_then_many_then_one("the generator signature followed by the function body", es$1.tl);
              var args$2 = Belt_List.map(as_list("generator parameters", match$11[0]).it, (function (param) {
                      return as_id("a parameter", param);
                    }));
              var terms$5 = Belt_List.map(match$11[1], parseTerm);
              var result$5 = as_expr("an expression to be returned", parseTerm(match$11[2]));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* GLam */11,
                          _0: args$2,
                          _1: makeBlock(terms$5, result$5)
                        }
                      },
                      ann: ann
                    };
          case "if" :
              var match$12 = as_three("three expressions (i.e., a condition, the \"then\" branch, and the \"else\" branch)", es$1.tl);
              var e_cnd = as_expr("a (conditional) expression", parseTerm(match$12[0]));
              var e_thn = as_expr("an expression", parseTerm(match$12[1]));
              var e_els = as_expr("an expression", parseTerm(match$12[2]));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* If */9,
                          _0: e_cnd,
                          _1: e_thn,
                          _2: e_els
                        }
                      },
                      ann: ann
                    };
          case "lambda" :
              var match$13 = as_one_then_many_then_one("the function signature followed by the function body", es$1.tl);
              var args$3 = Belt_List.map(as_list("function parameters", match$13[0]).it, (function (param) {
                      return as_id("a parameter", param);
                    }));
              var terms$6 = Belt_List.map(match$13[1], parseTerm);
              var result$6 = as_expr("an expression to be returned", parseTerm(match$13[2]));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* Lam */3,
                          _0: args$3,
                          _1: makeBlock(terms$6, result$6)
                        }
                      },
                      ann: ann
                    };
          case "left" :
              return makeAppPrm(ann, /* PairRefLeft */1, es$1.tl);
          case "let" :
              var match$14 = as_one_then_many_then_one("the bindings followed by the body", es$1.tl);
              var xes = Belt_List.map(Belt_List.map(as_list("variable-expression pairs", match$14[0]).it, (function (param) {
                          return as_list("a variable and an expression", param);
                        })), (function (param) {
                      return mapAnn((function (xe) {
                                    return as_two("a variable and an expression", xe);
                                  }), param);
                    }));
              var xes$1 = Belt_List.map(xes, (function (param) {
                      return mapAnn((function (param) {
                                    var x = as_id("a variable to be bound", param[0]);
                                    var e = as_expr("an expression", parseTerm(param[1]));
                                    return [
                                            x,
                                            e
                                          ];
                                  }), param);
                    }));
              var ts = Belt_List.map(match$14[1], parseTerm);
              var result$7 = as_expr("an expression to be return", parseTerm(match$14[2]));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* Let */4,
                          _0: xes$1,
                          _1: makeBlock(ts, result$7)
                        }
                      },
                      ann: ann
                    };
          case "let*" :
              var match$15 = as_one_then_many_then_one("the bindings followed by the body", es$1.tl);
              var xes$2 = Belt_List.map(Belt_List.map(as_list("variable-expression pairs", match$15[0]).it, (function (param) {
                          return as_list("a variable and an expression", param);
                        })), (function (param) {
                      return mapAnn((function (param) {
                                    return as_two("a variable and an expression", param);
                                  }), param);
                    }));
              var xes$3 = Belt_List.map(xes$2, (function (param) {
                      return mapAnn((function (param) {
                                    var x = as_id("a variable to be bound", param[0]);
                                    var e = as_expr("an expression", parseTerm(param[1]));
                                    return [
                                            x,
                                            e
                                          ];
                                  }), param);
                    }));
              var ts$1 = Belt_List.map(match$15[1], parseTerm);
              var result$8 = as_expr("an expression to be return", parseTerm(match$15[2]));
              return mapAnn((function (v) {
                            return {
                                    TAG: /* Exp */1,
                                    _0: v
                                  };
                          }), letstar(ann, xes$3, makeBlock(ts$1, result$8)));
          case "letrec" :
              var match$16 = as_one_then_many_then_one("the bindings followed by the body", es$1.tl);
              var xes$4 = Belt_List.map(Belt_List.map(as_list("variable-expression pairs", match$16[0]).it, (function (param) {
                          return as_list("a variable and an expression", param);
                        })), (function (param) {
                      return mapAnn((function (param) {
                                    return as_two("a variable and an expression", param);
                                  }), param);
                    }));
              var xes$5 = Belt_List.map(xes$4, (function (param) {
                      return mapAnn((function (param) {
                                    var x = as_id("a variable to be bound", param[0]);
                                    var e = as_expr("an expression", parseTerm(param[1]));
                                    return [
                                            x,
                                            e
                                          ];
                                  }), param);
                    }));
              var ts$2 = Belt_List.map(match$16[1], parseTerm);
              var result$9 = as_expr("an expression to be return", parseTerm(match$16[2]));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* Letrec */5,
                          _0: xes$5,
                          _1: makeBlock(ts$2, result$9)
                        }
                      },
                      ann: ann
                    };
          case "mvec" :
              return makeAppPrm(ann, /* VecNew */5, es$1.tl);
          case "next" :
              return makeAppPrm(ann, /* Next */12, es$1.tl);
          case "not" :
              return makeAppPrm(ann, /* Not */10, es$1.tl);
          case "mpair" :
          case "pair" :
              return makeAppPrm(ann, /* PairNew */0, es$1.tl);
          case "print" :
              return makeAppPrm(ann, /* Print */11, es$1.tl);
          case "quote" :
              var e$2 = as_one("a quoted value", es$1.tl);
              return mapAnn((function (v) {
                            return {
                                    TAG: /* Exp */1,
                                    _0: v
                                  };
                          }), parseValue(e$2));
          case "right" :
              return makeAppPrm(ann, /* PairRefRight */2, es$1.tl);
          case "set!" :
              var match$17 = as_two("a variable and an expression", es$1.tl);
              var x$1 = as_id("a variable to be set", match$17[0]);
              var e$3 = as_expr("an expression", parseTerm(match$17[1]));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* Set */2,
                          _0: x$1,
                          _1: e$3
                        }
                      },
                      ann: ann
                    };
          case "set-left!" :
              return makeAppPrm(ann, /* PairSetLeft */3, es$1.tl);
          case "set-right!" :
              return makeAppPrm(ann, /* PairSetRight */4, es$1.tl);
          case "vec-len" :
          case "vlen" :
              return makeAppPrm(ann, /* VecLen */8, es$1.tl);
          case "vec-ref" :
          case "vref" :
              return makeAppPrm(ann, /* VecRef */6, es$1.tl);
          case "vec-set!" :
          case "vset!" :
              return makeAppPrm(ann, /* VecSet */7, es$1.tl);
          case "yield" :
              var e$4 = as_one("an expression", es$1.tl);
              var e$5 = as_expr("an expression", parseTerm(e$4));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* Yield */12,
                          _0: e$5
                        }
                      },
                      ann: ann
                    };
          case "Î»" :
              var match$18 = as_one_then_many_then_one("the function signature followed by the function body", es$1.tl);
              var args$4 = Belt_List.map(as_list("function parameters", match$18[0]).it, (function (param) {
                      return as_id("a parameter", param);
                    }));
              var terms$7 = Belt_List.map(match$18[1], parseTerm);
              var result$10 = as_expr("an expression to be returned", parseTerm(match$18[2]));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* Lam */3,
                          _0: args$4,
                          _1: makeBlock(terms$7, result$10)
                        }
                      },
                      ann: ann
                    };
          default:
            
        }
      }
      
    }
    
  }
  var match$19 = as_one_then_many("a function call/application, which includes a function and then zero or more arguments", es$1);
  var e$6 = as_expr("a function", parseTerm(match$19[0]));
  var es$2 = Belt_List.map(Belt_List.map(match$19[1], parseTerm), (function (param) {
          return as_expr("an argument", param);
        }));
  return {
          it: {
            TAG: /* Exp */1,
            _0: {
              TAG: /* App */7,
              _0: e$6,
              _1: es$2
            }
          },
          ann: ann
        };
}

function makeAppPrm(ann, p, es) {
  var es$1 = Belt_List.map(Belt_List.map(es, parseTerm), (function (param) {
          return as_expr("an argument", param);
        }));
  return {
          it: {
            TAG: /* Exp */1,
            _0: {
              TAG: /* AppPrm */6,
              _0: p,
              _1: es$1
            }
          },
          ann: ann
        };
}

function parseTerms(src) {
  try {
    return Belt_List.map(SExpression.SExpr.fromString(src), parseTerm);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SExpression.SExpressionError) {
      var err$1 = {
        TAG: /* SExprParseError */0,
        _0: SExpression.$$Error.toString(err._1)
      };
      throw {
            RE_EXN_ID: SMoLParseError,
            _1: err$1,
            Error: new Error()
          };
    }
    throw err;
  }
}

function parseProgram(src) {
  return makeProgram(parseTerms(src));
}

function parseOutput(src) {
  try {
    return Belt_List.map(SExpression.SExpr.fromString(src), outputletOfSExpr);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SExpression.SExpressionError) {
      var err$1 = {
        TAG: /* SExprParseError */0,
        _0: SExpression.$$Error.toString(err._1)
      };
      throw {
            RE_EXN_ID: SMoLParseError,
            _1: err$1,
            Error: new Error()
          };
    }
    throw err;
  }
}

var SMoLPrintError = /* @__PURE__ */Caml_exceptions.create("SMoL.SMoLPrintError");

function getPrint(param) {
  var match = param.ann;
  return {
          it: match.print,
          ann: match.sourceLocation
        };
}

function indent(t, i) {
  var pad = Js_string.repeat(i, " ");
  return mapAnn((function (param) {
                return map((function (s) {
                              return Js_string.replaceByRe(/\n/g, "\n" + pad, s);
                            }), param);
              }), t);
}

function indentBlock(s, i) {
  var ss_0 = {
    it: {
      TAG: /* Plain */0,
      _0: "\n"
    },
    ann: undefined
  };
  var ss_1 = {
    hd: s,
    tl: /* [] */0
  };
  var ss = {
    hd: ss_0,
    tl: ss_1
  };
  return indent({
              it: {
                TAG: /* Group */1,
                _0: ss
              },
              ann: undefined
            }, i);
}

function hcat(s1, s2) {
  return {
          TAG: /* Group */1,
          _0: {
            hd: s1,
            tl: {
              hd: indent(s2, toString(s1.it).length),
              tl: /* [] */0
            }
          }
        };
}

function printName(x) {
  return x;
}

function constantToString(c) {
  if (typeof c === "number") {
    if (c === /* Uni */0) {
      return "#<void>";
    } else {
      return "#<empty>";
    }
  }
  switch (c.TAG | 0) {
    case /* Num */0 :
        return String(c._0);
    case /* Lgc */1 :
        if (c._0) {
          return "#t";
        } else {
          return "#f";
        }
    case /* Str */2 :
        return "\"" + $$String.escaped(c._0) + "\"";
    case /* Sym */3 :
        return c._0;
    
  }
}

function listToString(ss) {
  return pad("(", {
              it: concat(" ", ss),
              ann: undefined
            }, ")");
}

function defvarLike(op, x, e) {
  if (containsNL(e.it) || op === "deffun" || op === "defgen") {
    return {
            TAG: /* Group */1,
            _0: {
              hd: {
                it: {
                  TAG: /* Plain */0,
                  _0: "("
                },
                ann: undefined
              },
              tl: {
                hd: {
                  it: {
                    TAG: /* Plain */0,
                    _0: op
                  },
                  ann: undefined
                },
                tl: {
                  hd: {
                    it: {
                      TAG: /* Plain */0,
                      _0: " "
                    },
                    ann: undefined
                  },
                  tl: {
                    hd: x,
                    tl: {
                      hd: indentBlock(e, 2),
                      tl: {
                        hd: {
                          it: {
                            TAG: /* Plain */0,
                            _0: ")"
                          },
                          ann: undefined
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                }
              }
            }
          };
  } else {
    return listToString({
                hd: {
                  it: {
                    TAG: /* Plain */0,
                    _0: op
                  },
                  ann: undefined
                },
                tl: {
                  hd: x,
                  tl: {
                    hd: e,
                    tl: /* [] */0
                  }
                }
              });
  }
}

function deffunToString(f, xs, b) {
  return defvarLike("deffun", {
              it: listToString({
                    hd: f,
                    tl: xs
                  }),
              ann: undefined
            }, b);
}

function defgenToString(f, xs, b) {
  return defvarLike("defgen", {
              it: listToString({
                    hd: f,
                    tl: xs
                  }),
              ann: undefined
            }, b);
}

function exprLamToString(xs, b) {
  return defvarLike("lambda", {
              it: listToString(xs),
              ann: undefined
            }, b);
}

function exprGenToString(xs, b) {
  return defvarLike("generator", {
              it: listToString(xs),
              ann: undefined
            }, b);
}

function exprYieldToString(e) {
  return {
          TAG: /* Group */1,
          _0: {
            hd: {
              it: {
                TAG: /* Plain */0,
                _0: "(yield "
              },
              ann: undefined
            },
            tl: {
              hd: e,
              tl: {
                hd: {
                  it: {
                    TAG: /* Plain */0,
                    _0: ")"
                  },
                  ann: undefined
                },
                tl: /* [] */0
              }
            }
          }
        };
}

function beginLike(op, ts) {
  return {
          TAG: /* Group */1,
          _0: {
            hd: {
              it: {
                TAG: /* Plain */0,
                _0: "("
              },
              ann: undefined
            },
            tl: {
              hd: {
                it: {
                  TAG: /* Plain */0,
                  _0: op
                },
                ann: undefined
              },
              tl: {
                hd: indentBlock({
                      it: concat("\n", ts),
                      ann: undefined
                    }, 2),
                tl: {
                  hd: {
                    it: {
                      TAG: /* Plain */0,
                      _0: ")"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        };
}

function exprBgnToString(es, e) {
  return beginLike("begin", Belt_List.concatMany([
                  es,
                  {
                    hd: e,
                    tl: /* [] */0
                  }
                ]));
}

function exprCndToString(ebs, ob) {
  var ebs$1 = ob !== undefined ? Belt_List.concatMany([
          ebs,
          {
            hd: [
              {
                it: {
                  TAG: /* Plain */0,
                  _0: "else"
                },
                ann: undefined
              },
              ob
            ],
            tl: /* [] */0
          }
        ]) : ebs;
  var ebs$2 = Belt_List.map(ebs$1, (function (param) {
          var ss_0 = {
            it: {
              TAG: /* Plain */0,
              _0: "["
            },
            ann: undefined
          };
          var ss_1 = {
            hd: param[0],
            tl: {
              hd: indentBlock(param[1], 1),
              tl: {
                hd: {
                  it: {
                    TAG: /* Plain */0,
                    _0: "]"
                  },
                  ann: undefined
                },
                tl: /* [] */0
              }
            }
          };
          var ss = {
            hd: ss_0,
            tl: ss_1
          };
          return {
                  it: {
                    TAG: /* Group */1,
                    _0: ss
                  },
                  ann: undefined
                };
        }));
  return beginLike("cond", ebs$2);
}

function exprIfToString(e_cnd, e_thn, e_els) {
  return hcat({
              it: {
                TAG: /* Plain */0,
                _0: "(if "
              },
              ann: undefined
            }, group2({
                  it: concat("\n", {
                        hd: e_cnd,
                        tl: {
                          hd: e_thn,
                          tl: {
                            hd: e_els,
                            tl: /* [] */0
                          }
                        }
                      }),
                  ann: undefined
                }, {
                  it: {
                    TAG: /* Plain */0,
                    _0: ")"
                  },
                  ann: undefined
                }));
}

function letLike(op, xes, b) {
  var xes_it = concat("\n", xes);
  var xes$1 = {
    it: xes_it,
    ann: undefined
  };
  var ss_0 = {
    it: {
      TAG: /* Plain */0,
      _0: "("
    },
    ann: undefined
  };
  var ss_1 = {
    hd: indent(xes$1, 1),
    tl: {
      hd: {
        it: {
          TAG: /* Plain */0,
          _0: ")"
        },
        ann: undefined
      },
      tl: /* [] */0
    }
  };
  var ss = {
    hd: ss_0,
    tl: ss_1
  };
  var xes_it$1 = {
    TAG: /* Group */1,
    _0: ss
  };
  var xes$2 = {
    it: xes_it$1,
    ann: undefined
  };
  var ss_0$1 = {
    it: {
      TAG: /* Plain */0,
      _0: "("
    },
    ann: undefined
  };
  var ss_1$1 = {
    hd: {
      it: {
        TAG: /* Plain */0,
        _0: op
      },
      ann: undefined
    },
    tl: {
      hd: {
        it: {
          TAG: /* Plain */0,
          _0: " "
        },
        ann: undefined
      },
      tl: /* [] */0
    }
  };
  var ss$1 = {
    hd: ss_0$1,
    tl: ss_1$1
  };
  return {
          TAG: /* Group */1,
          _0: {
            hd: {
              it: hcat({
                    it: {
                      TAG: /* Group */1,
                      _0: ss$1
                    },
                    ann: undefined
                  }, xes$2),
              ann: undefined
            },
            tl: {
              hd: indentBlock(b, 2),
              tl: {
                hd: {
                  it: {
                    TAG: /* Plain */0,
                    _0: ")"
                  },
                  ann: undefined
                },
                tl: /* [] */0
              }
            }
          }
        };
}

function symbolToString(param) {
  var it = param.it;
  return {
          it: it,
          ann: {
            sourceLocation: param.ann,
            print: {
              TAG: /* Plain */0,
              _0: it
            }
          }
        };
}

function printExp(param) {
  var it = param.it;
  var e;
  switch (it.TAG | 0) {
    case /* Con */0 :
        var c = it._0;
        e = {
          it: {
            TAG: /* Con */0,
            _0: c
          },
          ann: {
            TAG: /* Plain */0,
            _0: constantToString(c)
          }
        };
        break;
    case /* Ref */1 :
        var x = it._0;
        e = {
          it: {
            TAG: /* Ref */1,
            _0: x
          },
          ann: {
            TAG: /* Plain */0,
            _0: x
          }
        };
        break;
    case /* Set */2 :
        var x$1 = symbolToString(it._0);
        var e$1 = printExp(it._1);
        e = {
          it: {
            TAG: /* Set */2,
            _0: x$1,
            _1: e$1
          },
          ann: defvarLike("set!", getPrint(x$1), getPrint(e$1))
        };
        break;
    case /* Lam */3 :
        var xs = Belt_List.map(it._0, symbolToString);
        var b = printBlock(it._1);
        e = {
          it: {
            TAG: /* Lam */3,
            _0: xs,
            _1: b
          },
          ann: exprLamToString(Belt_List.map(xs, getPrint), getPrint(b))
        };
        break;
    case /* Let */4 :
        var xes = Belt_List.map(it._0, xeToString);
        var b$1 = printBlock(it._1);
        e = {
          it: {
            TAG: /* Let */4,
            _0: xes,
            _1: b$1
          },
          ann: letLike("let", Belt_List.map(xes, getPrint), getPrint(b$1))
        };
        break;
    case /* Letrec */5 :
        var xes$1 = Belt_List.map(it._0, xeToString);
        var b$2 = printBlock(it._1);
        e = {
          it: {
            TAG: /* Letrec */5,
            _0: xes$1,
            _1: b$2
          },
          ann: letLike("letrec", Belt_List.map(xes$1, getPrint), getPrint(b$2))
        };
        break;
    case /* AppPrm */6 :
        var p = it._0;
        var es = Belt_List.map(it._1, printExp);
        var es$1 = Belt_List.map(es, getPrint);
        var it$1 = toString$1(p);
        var e_it = {
          TAG: /* Plain */0,
          _0: it$1
        };
        var e$2 = {
          it: e_it,
          ann: undefined
        };
        e = {
          it: {
            TAG: /* AppPrm */6,
            _0: p,
            _1: es
          },
          ann: listToString({
                hd: e$2,
                tl: es$1
              })
        };
        break;
    case /* App */7 :
        var e$3 = printExp(it._0);
        var es$2 = Belt_List.map(it._1, printExp);
        var es$3 = Belt_List.map(es$2, getPrint);
        var e$4 = getPrint(e$3);
        e = {
          it: {
            TAG: /* App */7,
            _0: e$3,
            _1: es$2
          },
          ann: listToString({
                hd: e$4,
                tl: es$3
              })
        };
        break;
    case /* Bgn */8 :
        var es$4 = Belt_List.map(it._0, printExp);
        var e$5 = printExp(it._1);
        e = {
          it: {
            TAG: /* Bgn */8,
            _0: es$4,
            _1: e$5
          },
          ann: exprBgnToString(Belt_List.map(es$4, getPrint), getPrint(e$5))
        };
        break;
    case /* If */9 :
        var e_cnd = printExp(it._0);
        var e_thn = printExp(it._1);
        var e_els = printExp(it._2);
        e = {
          it: {
            TAG: /* If */9,
            _0: e_cnd,
            _1: e_thn,
            _2: e_els
          },
          ann: exprIfToString(getPrint(e_cnd), getPrint(e_thn), getPrint(e_els))
        };
        break;
    case /* Cnd */10 :
        var ebs = Belt_List.map(it._0, ebToString);
        var ob = Belt_Option.map(it._1, printBlock);
        e = {
          it: {
            TAG: /* Cnd */10,
            _0: ebs,
            _1: ob
          },
          ann: exprCndToString(Belt_List.map(ebs, (function (param) {
                      return [
                              getPrint(param[0]),
                              getPrint(param[1])
                            ];
                    })), Belt_Option.map(ob, getPrint))
        };
        break;
    case /* GLam */11 :
        var xs$1 = Belt_List.map(it._0, symbolToString);
        var b$3 = printBlock(it._1);
        e = {
          it: {
            TAG: /* Lam */3,
            _0: xs$1,
            _1: b$3
          },
          ann: exprGenToString(Belt_List.map(xs$1, getPrint), getPrint(b$3))
        };
        break;
    case /* Yield */12 :
        var e$6 = printExp(it._0);
        e = {
          it: {
            TAG: /* Yield */12,
            _0: e$6
          },
          ann: exprYieldToString(getPrint(e$6))
        };
        break;
    
  }
  return {
          it: e.it,
          ann: {
            sourceLocation: param.ann,
            print: e.ann
          }
        };
}

function printDef(param) {
  var d = param.it;
  var d$1;
  switch (d.TAG | 0) {
    case /* Var */0 :
        var x = symbolToString(d._0);
        var e = printExp(d._1);
        d$1 = {
          it: {
            TAG: /* Var */0,
            _0: x,
            _1: e
          },
          ann: defvarLike("defvar", getPrint(x), getPrint(e))
        };
        break;
    case /* Fun */1 :
        var f = symbolToString(d._0);
        var xs = Belt_List.map(d._1, symbolToString);
        var b = printBlock(d._2);
        d$1 = {
          it: {
            TAG: /* Fun */1,
            _0: f,
            _1: xs,
            _2: b
          },
          ann: deffunToString(getPrint(f), Belt_List.map(xs, getPrint), getPrint(b))
        };
        break;
    case /* GFun */2 :
        var f$1 = symbolToString(d._0);
        var xs$1 = Belt_List.map(d._1, symbolToString);
        var b$1 = printBlock(d._2);
        d$1 = {
          it: {
            TAG: /* GFun */2,
            _0: f$1,
            _1: xs$1,
            _2: b$1
          },
          ann: defgenToString(getPrint(f$1), Belt_List.map(xs$1, getPrint), getPrint(b$1))
        };
        break;
    
  }
  return {
          it: d$1.it,
          ann: {
            sourceLocation: param.ann,
            print: d$1.ann
          }
        };
}

function xeToString(param) {
  var xe = param.it;
  var x = symbolToString(xe[0]);
  var e = printExp(xe[1]);
  var print = hcat(group2({
            it: {
              TAG: /* Plain */0,
              _0: "["
            },
            ann: undefined
          }, getPrint(x)), group2(getPrint(e), {
            it: {
              TAG: /* Plain */0,
              _0: "]"
            },
            ann: undefined
          }));
  return {
          it: [
            x,
            e
          ],
          ann: {
            sourceLocation: param.ann,
            print: print
          }
        };
}

function ebToString(eb) {
  return [
          printExp(eb[0]),
          printBlock(eb[1])
        ];
}

function printBlock(param) {
  var sourceLocation = param.ann;
  var b = param.it;
  if (b.TAG === /* BRet */0) {
    return mapAnn((function (e) {
                  return {
                          TAG: /* BRet */0,
                          _0: e
                        };
                }), printExp({
                    it: b._0,
                    ann: sourceLocation
                  }));
  }
  var t = printTerm(b._0);
  var b$1 = printBlock(b._1);
  var print = {
    TAG: /* Group */1,
    _0: {
      hd: getPrint(t),
      tl: {
        hd: {
          it: {
            TAG: /* Plain */0,
            _0: "\n"
          },
          ann: undefined
        },
        tl: {
          hd: getPrint(b$1),
          tl: /* [] */0
        }
      }
    }
  };
  return {
          it: {
            TAG: /* BCons */1,
            _0: t,
            _1: b$1
          },
          ann: {
            sourceLocation: sourceLocation,
            print: print
          }
        };
}

function printTerm(param) {
  var sourceLocation = param.ann;
  var t = param.it;
  if (t.TAG === /* Def */0) {
    return mapAnn((function (v) {
                  return {
                          TAG: /* Def */0,
                          _0: v
                        };
                }), printDef({
                    it: t._0,
                    ann: sourceLocation
                  }));
  } else {
    return mapAnn((function (v) {
                  return {
                          TAG: /* Exp */1,
                          _0: v
                        };
                }), printExp({
                    it: t._0,
                    ann: sourceLocation
                  }));
  }
}

function printOutputlet(o) {
  var p = function (v) {
    switch (v.TAG | 0) {
      case /* Ref */0 :
          return "#" + String(v._0) + "#";
      case /* Con */1 :
          return constantToString(v._0);
      case /* Struct */2 :
          var content = v._1;
          var i = v._0;
          var i$1 = i !== undefined ? "#" + String(i) + "=" : "";
          var content$1;
          content$1 = content.TAG === /* Lst */0 ? "(" + $$String.concat(" ", Belt_List.map(content._0, p)) + ")" : "#(" + $$String.concat(" ", Belt_List.map(content._0, p)) + ")";
          return "" + i$1 + "" + content$1 + "";
      
    }
  };
  if (o) {
    return p(o._0);
  } else {
    return "error";
  }
}

function printOutput(sepOpt, os) {
  var sep = sepOpt !== undefined ? sepOpt : " ";
  return $$String.concat(sep, Belt_List.map(os, printOutputlet));
}

function printProgramFull(_insertPrintTopLevel, p) {
  var print = function (param) {
    var sourceLocation = param.ann;
    var it = param.it;
    if (!it) {
      return {
              it: /* PNil */0,
              ann: {
                sourceLocation: sourceLocation,
                print: {
                  TAG: /* Group */1,
                  _0: /* [] */0
                }
              }
            };
    }
    var p = it._1;
    var t = printTerm(it._0);
    if (!p.it) {
      return {
              it: /* PCons */{
                _0: t,
                _1: {
                  it: /* PNil */0,
                  ann: {
                    sourceLocation: {
                      begin: sourceLocation.end,
                      end: sourceLocation.end
                    },
                    print: {
                      TAG: /* Plain */0,
                      _0: ""
                    }
                  }
                }
              },
              ann: {
                sourceLocation: sourceLocation,
                print: getPrint(t).it
              }
            };
    }
    var p$1 = print(p);
    return {
            it: /* PCons */{
              _0: t,
              _1: p$1
            },
            ann: {
              sourceLocation: sourceLocation,
              print: concat2(getPrint(t), "\n", getPrint(p$1))
            }
          };
  };
  return print(p);
}

function printProgram(insertPrintTopLevel, p) {
  return toString(printProgramFull(insertPrintTopLevel, p).ann.print);
}

function printStandAloneTerm(t) {
  return toString(printTerm(t).ann.print);
}

function op1(s1, p1, s2) {
  var ss_0 = {
    it: {
      TAG: /* Plain */0,
      _0: s1
    },
    ann: undefined
  };
  var ss_1 = {
    hd: p1,
    tl: {
      hd: {
        it: {
          TAG: /* Plain */0,
          _0: s2
        },
        ann: undefined
      },
      tl: /* [] */0
    }
  };
  var ss = {
    hd: ss_0,
    tl: ss_1
  };
  return {
          it: {
            TAG: /* Group */1,
            _0: ss
          },
          ann: undefined
        };
}

function op2(s1, p1, s2, p2, s3) {
  var ss_0 = {
    it: {
      TAG: /* Plain */0,
      _0: s1
    },
    ann: undefined
  };
  var ss_1 = {
    hd: p1,
    tl: {
      hd: {
        it: {
          TAG: /* Plain */0,
          _0: s2
        },
        ann: undefined
      },
      tl: {
        hd: p2,
        tl: {
          hd: {
            it: {
              TAG: /* Plain */0,
              _0: s3
            },
            ann: undefined
          },
          tl: /* [] */0
        }
      }
    }
  };
  var ss = {
    hd: ss_0,
    tl: ss_1
  };
  return {
          it: {
            TAG: /* Group */1,
            _0: ss
          },
          ann: undefined
        };
}

function op3(s1, p1, s2, p2, s3, p3, s4) {
  var ss_0 = {
    it: {
      TAG: /* Plain */0,
      _0: s1
    },
    ann: undefined
  };
  var ss_1 = {
    hd: p1,
    tl: {
      hd: {
        it: {
          TAG: /* Plain */0,
          _0: s2
        },
        ann: undefined
      },
      tl: {
        hd: p2,
        tl: {
          hd: {
            it: {
              TAG: /* Plain */0,
              _0: s3
            },
            ann: undefined
          },
          tl: {
            hd: p3,
            tl: {
              hd: {
                it: {
                  TAG: /* Plain */0,
                  _0: s4
                },
                ann: undefined
              },
              tl: /* [] */0
            }
          }
        }
      }
    }
  };
  var ss = {
    hd: ss_0,
    tl: ss_1
  };
  return {
          it: {
            TAG: /* Group */1,
            _0: ss
          },
          ann: undefined
        };
}

function printName$1(x) {
  var re = /-./g;
  var matchFn = function (matchPart, _offset, _wholeString) {
    return matchPart.substring(1).toUpperCase();
  };
  var x$1 = x.replace(re, matchFn);
  if (x$1 === "var") {
    return "$var";
  } else {
    return x$1;
  }
}

function constantToString$1(c) {
  if (typeof c === "number") {
    if (c === /* Uni */0) {
      return "null";
    }
    throw {
          RE_EXN_ID: SMoLPrintError,
          _1: "Lists are not supported in JavaScript.",
          Error: new Error()
        };
  } else {
    switch (c.TAG | 0) {
      case /* Num */0 :
          return String(c._0);
      case /* Lgc */1 :
          if (c._0) {
            return "true";
          } else {
            return "false";
          }
      case /* Str */2 :
          return "\"" + $$String.escaped(c._0) + "\"";
      case /* Sym */3 :
          return c._0;
      
    }
  }
}

function listToString$1(es) {
  if (Belt_List.some(es, (function (e) {
            return containsNL(e.it);
          }))) {
    return {
            TAG: /* Group */1,
            _0: {
              hd: {
                it: {
                  TAG: /* Plain */0,
                  _0: "("
                },
                ann: undefined
              },
              tl: {
                hd: indentBlock({
                      it: concat(",\n", es),
                      ann: undefined
                    }, 2),
                tl: {
                  hd: {
                    it: {
                      TAG: /* Plain */0,
                      _0: ")"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          };
  } else {
    return {
            TAG: /* Group */1,
            _0: {
              hd: {
                it: {
                  TAG: /* Plain */0,
                  _0: "("
                },
                ann: undefined
              },
              tl: {
                hd: {
                  it: concat(", ", es),
                  ann: undefined
                },
                tl: {
                  hd: {
                    it: {
                      TAG: /* Plain */0,
                      _0: ")"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          };
  }
}

function defvarLike$1(op, x, e) {
  var ss_0 = {
    it: {
      TAG: /* Plain */0,
      _0: op
    },
    ann: undefined
  };
  var ss_1 = {
    hd: x,
    tl: {
      hd: {
        it: {
          TAG: /* Plain */0,
          _0: " = "
        },
        ann: undefined
      },
      tl: {
        hd: indent(e, 2),
        tl: /* [] */0
      }
    }
  };
  var ss = {
    hd: ss_0,
    tl: ss_1
  };
  return {
          it: {
            TAG: /* Group */1,
            _0: ss
          },
          ann: undefined
        };
}

function exprAppToString(e, es) {
  return group2(e, {
              it: listToString$1(es),
              ann: undefined
            });
}

var printingTopLevel = {
  contents: false
};

function consumeContext(e, context) {
  if (context.TAG === /* Expr */0) {
    return surround("", e, "");
  }
  switch (context._0) {
    case /* Step */0 :
        return surround("", e, "");
    case /* Return */1 :
        return surround("return ", e, "");
    case /* TopLevel */2 :
        if (printingTopLevel.contents) {
          return surround("console.log(", e, ")");
        } else {
          return surround("", e, "");
        }
    
  }
}

function consumeContextWrap(e, context) {
  if (context.TAG === /* Expr */0 && context._0) {
    return surround("(", e, ")");
  } else {
    return consumeContext(e, context);
  }
}

function consumeContextVoid(e, context) {
  if (context.TAG === /* Expr */0) {
    return consumeContext(e, context);
  }
  switch (context._0) {
    case /* Step */0 :
        return consumeContext(e, context);
    case /* Return */1 :
        return surround("", e, "\nreturn");
    case /* TopLevel */2 :
        return surround("", e, "");
    
  }
}

function consumeContextStat(e, context) {
  if (context.TAG !== /* Expr */0) {
    return consumeContextVoid(e, context);
  }
  var err = "" + toString(e.it) + " can't be used as a expression in JavaScript";
  throw {
        RE_EXN_ID: SMoLPrintError,
        _1: err,
        Error: new Error()
      };
}

function exprAppPrmToString(p, es, context) {
  if (typeof p === "number") {
    switch (p) {
      case /* PairNew */0 :
          if (es) {
            var match = es.tl;
            if (match && !match.tl) {
              var e1 = Curry._1(es.hd, false);
              var e2 = Curry._1(match.hd, false);
              return {
                      it: [
                        /* PairNew */0,
                        {
                          hd: e1,
                          tl: {
                            hd: e2,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContext(op2("[ ", getPrint(e1), ", ", getPrint(e2), " ]"), context)
                    };
            }
            
          }
          break;
      case /* PairRefLeft */1 :
          if (es && !es.tl) {
            var e1$1 = Curry._1(es.hd, true);
            return {
                    it: [
                      /* PairRefLeft */1,
                      {
                        hd: e1$1,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext(op1("", getPrint(e1$1), "[0]"), context)
                  };
          }
          break;
      case /* PairRefRight */2 :
          if (es && !es.tl) {
            var e1$2 = Curry._1(es.hd, true);
            return {
                    it: [
                      /* PairRefRight */2,
                      {
                        hd: e1$2,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext(op1("", getPrint(e1$2), "[1]"), context)
                  };
          }
          break;
      case /* PairSetLeft */3 :
          if (es) {
            var match$1 = es.tl;
            if (match$1 && !match$1.tl) {
              var e1$3 = Curry._1(es.hd, false);
              var e2$1 = Curry._1(match$1.hd, false);
              return {
                      it: [
                        /* PairSetLeft */3,
                        {
                          hd: e1$3,
                          tl: {
                            hd: e2$1,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContextStat(op2("", getPrint(e1$3), "[0] = ", getPrint(e2$1), ""), context)
                    };
            }
            
          }
          break;
      case /* PairSetRight */4 :
          if (es) {
            var match$2 = es.tl;
            if (match$2 && !match$2.tl) {
              var e1$4 = Curry._1(es.hd, false);
              var e2$2 = Curry._1(match$2.hd, false);
              return {
                      it: [
                        /* PairSetRight */4,
                        {
                          hd: e1$4,
                          tl: {
                            hd: e2$2,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContextStat(op2("", getPrint(e1$4), "[1] = ", getPrint(e2$2), ""), context)
                    };
            }
            
          }
          break;
      case /* VecNew */5 :
          var es$1 = Belt_List.map(es, (function (e) {
                  return Curry._1(e, false);
                }));
          return {
                  it: [
                    /* VecNew */5,
                    es$1
                  ],
                  ann: consumeContext(op1("[ ", {
                            it: concat(", ", Belt_List.map(es$1, getPrint)),
                            ann: undefined
                          }, " ]"), context)
                };
      case /* VecRef */6 :
          if (es) {
            var match$3 = es.tl;
            if (match$3 && !match$3.tl) {
              var e1$5 = Curry._1(es.hd, true);
              var e2$3 = Curry._1(match$3.hd, false);
              return {
                      it: [
                        /* VecRef */6,
                        {
                          hd: e1$5,
                          tl: {
                            hd: e2$3,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContext(op2("", getPrint(e1$5), "[", getPrint(e2$3), "]"), context)
                    };
            }
            
          }
          break;
      case /* VecSet */7 :
          if (es) {
            var match$4 = es.tl;
            if (match$4) {
              var match$5 = match$4.tl;
              if (match$5 && !match$5.tl) {
                var e1$6 = Curry._1(es.hd, true);
                var e2$4 = Curry._1(match$4.hd, false);
                var e3 = Curry._1(match$5.hd, false);
                return {
                        it: [
                          /* VecSet */7,
                          {
                            hd: e1$6,
                            tl: {
                              hd: e2$4,
                              tl: {
                                hd: e3,
                                tl: /* [] */0
                              }
                            }
                          }
                        ],
                        ann: consumeContextStat(op3("", getPrint(e1$6), "[", getPrint(e2$4), "] = ", getPrint(e3), ""), context)
                      };
              }
              
            }
            
          }
          break;
      case /* VecLen */8 :
          if (es && !es.tl) {
            var e1$7 = Curry._1(es.hd, false);
            return {
                    it: [
                      /* VecLen */8,
                      {
                        hd: e1$7,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext(op1("", getPrint(e1$7), ".length"), context)
                  };
          }
          break;
      case /* Err */9 :
          if (es && !es.tl) {
            var e1$8 = Curry._1(es.hd, true);
            return {
                    it: [
                      /* Err */9,
                      {
                        hd: e1$8,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextWrap(op1("throw ", getPrint(e1$8), ""), context)
                  };
          }
          break;
      case /* Not */10 :
          if (es && !es.tl) {
            var e1$9 = Curry._1(es.hd, true);
            return {
                    it: [
                      /* Not */10,
                      {
                        hd: e1$9,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextWrap(op1("! ", getPrint(e1$9), ""), context)
                  };
          }
          break;
      case /* Print */11 :
          if (es && !es.tl) {
            var e1$10 = Curry._1(es.hd, false);
            return {
                    it: [
                      /* Print */11,
                      {
                        hd: e1$10,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextVoid(op1("console.log(", getPrint(e1$10), ")"), context)
                  };
          }
          break;
      case /* Next */12 :
          if (es && !es.tl) {
            var e1$11 = Curry._1(es.hd, false);
            return {
                    it: [
                      /* Next */12,
                      {
                        hd: e1$11,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextVoid(op1("", getPrint(e1$11), ".next()"), context)
                  };
          }
          break;
      case /* Cons */13 :
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "List is not supported by JavaScript",
                Error: new Error()
              };
      
    }
  } else {
    if (p.TAG === /* Arith */0) {
      var o = p._0;
      var os;
      switch (o) {
        case /* Add */0 :
            os = "+";
            break;
        case /* Sub */1 :
            os = "-";
            break;
        case /* Mul */2 :
            os = "*";
            break;
        case /* Div */3 :
            os = "/";
            break;
        
      }
      var es$2 = Belt_List.map(es, (function (e) {
              return Curry._1(e, true);
            }));
      return {
              it: [
                {
                  TAG: /* Arith */0,
                  _0: o
                },
                es$2
              ],
              ann: consumeContextWrap({
                    it: concat(" " + os + " ", Belt_List.map(es$2, getPrint)),
                    ann: undefined
                  }, context)
            };
    }
    if (es) {
      var match$6 = es.tl;
      if (match$6 && !match$6.tl) {
        var o$1 = p._0;
        var os$1;
        switch (o$1) {
          case /* Lt */0 :
              os$1 = "<";
              break;
          case /* Eq */1 :
              os$1 = "==";
              break;
          case /* Gt */2 :
              os$1 = ">";
              break;
          case /* Le */3 :
              os$1 = "<=";
              break;
          case /* Ge */4 :
              os$1 = ">=";
              break;
          case /* Ne */5 :
              os$1 = "!=";
              break;
          
        }
        var e1$12 = Curry._1(es.hd, true);
        var e2$5 = Curry._1(match$6.hd, true);
        return {
                it: [
                  {
                    TAG: /* Cmp */1,
                    _0: o$1
                  },
                  {
                    hd: e1$12,
                    tl: {
                      hd: e2$5,
                      tl: /* [] */0
                    }
                  }
                ],
                ann: consumeContext(op2("", getPrint(e1$12), " " + os$1 + " ", getPrint(e2$5), ""), context)
              };
      }
      
    }
    
  }
  var err = "JavaScript doesn't let you use " + toString$1(p) + " on " + String(Belt_List.length(es)) + " parameter(s).";
  throw {
        RE_EXN_ID: SMoLPrintError,
        _1: err,
        Error: new Error()
      };
}

function funLike(op, x, xs, e) {
  return op2("" + op + " ", exprAppToString(x, xs), " {", indentBlock(e, 2), "\n}");
}

function defvarToString(x, e) {
  return op1("", defvarLike$1("let ", x, e), "");
}

function deffunToString$1(f, xs, b) {
  return funLike("function", f, xs, b);
}

function defgenToString$1(f, xs, b) {
  return funLike("function*", f, xs, b);
}

function exprLamToString$1(xs, b) {
  return funLike("function", {
              it: {
                TAG: /* Plain */0,
                _0: ""
              },
              ann: undefined
            }, xs, b);
}

function exprGenToString$1(xs, b) {
  return funLike("function*", {
              it: {
                TAG: /* Plain */0,
                _0: ""
              },
              ann: undefined
            }, xs, b);
}

function exprBgnToString$1(es, e) {
  return {
          it: listToString$1(Belt_List.concatMany([
                    es,
                    {
                      hd: e,
                      tl: /* [] */0
                    }
                  ])),
          ann: undefined
        };
}

function exprCndToString$1(ebs, ob) {
  var ebs$1 = ob !== undefined ? Belt_List.concatMany([
          ebs,
          {
            hd: [
              {
                it: {
                  TAG: /* Plain */0,
                  _0: ""
                },
                ann: undefined
              },
              ob
            ],
            tl: /* [] */0
          }
        ]) : ebs;
  var ebs$2 = Belt_List.map(ebs$1, (function (param) {
          return op2("if (", param[0], ") {", indentBlock(param[1], 2), "\n}");
        }));
  return concat(" else ", ebs$2);
}

function exprIfToString$1(e_cnd, e_thn, e_els) {
  return op3("", e_cnd, " ? ", e_thn, " : ", e_els, "");
}

function symbolToString$1(param) {
  var it = param.it;
  return {
          it: it,
          ann: {
            sourceLocation: param.ann,
            print: {
              TAG: /* Plain */0,
              _0: printName$1(it)
            }
          }
        };
}

function printExp$1(param, context) {
  var it = param.it;
  var e;
  switch (it.TAG | 0) {
    case /* Con */0 :
        var c = it._0;
        var it$1 = constantToString$1(c);
        e = {
          it: {
            TAG: /* Con */0,
            _0: c
          },
          ann: consumeContext({
                it: {
                  TAG: /* Plain */0,
                  _0: it$1
                },
                ann: undefined
              }, context)
        };
        break;
    case /* Ref */1 :
        var x = it._0;
        var it$2 = printName$1(x);
        e = {
          it: {
            TAG: /* Ref */1,
            _0: x
          },
          ann: consumeContext({
                it: {
                  TAG: /* Plain */0,
                  _0: it$2
                },
                ann: undefined
              }, context)
        };
        break;
    case /* Set */2 :
        var x$1 = symbolToString$1(it._0);
        var e$1 = printExp$1(it._1, {
              TAG: /* Expr */0,
              _0: false
            });
        e = {
          it: {
            TAG: /* Set */2,
            _0: x$1,
            _1: e$1
          },
          ann: consumeContextStat(defvarLike$1("", getPrint(x$1), getPrint(e$1)), context)
        };
        break;
    case /* Lam */3 :
        var xs = Belt_List.map(it._0, symbolToString$1);
        var b = printBlock$1(it._1, /* Return */1);
        e = {
          it: {
            TAG: /* Lam */3,
            _0: xs,
            _1: b
          },
          ann: consumeContextWrap(exprLamToString$1(Belt_List.map(xs, getPrint), getPrint(b)), context)
        };
        break;
    case /* Let */4 :
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "let-expressions are not supported by JavaScript",
              Error: new Error()
            };
    case /* Letrec */5 :
        if (context.TAG === /* Expr */0) {
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "letrec-expressions are not supported by JavaScript",
                Error: new Error()
              };
        }
        var xes = Belt_List.map(it._0, xeToString$1);
        var b$1 = printBlock$1(it._1, context._0);
        e = {
          it: {
            TAG: /* Letrec */5,
            _0: xes,
            _1: b$1
          },
          ann: {
            TAG: /* Group */1,
            _0: {
              hd: {
                it: {
                  TAG: /* Plain */0,
                  _0: "{\n"
                },
                ann: undefined
              },
              tl: {
                hd: indentBlock({
                      it: concat("\n", Belt_List.concatMany([
                                Belt_List.map(xes, getPrint),
                                {
                                  hd: getPrint(b$1),
                                  tl: /* [] */0
                                }
                              ])),
                      ann: undefined
                    }, 2),
                tl: {
                  hd: {
                    it: {
                      TAG: /* Plain */0,
                      _0: "\n}"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        };
        break;
    case /* AppPrm */6 :
        var es = Belt_List.map(it._1, (function (e, b) {
                return printExp$1(e, {
                            TAG: /* Expr */0,
                            _0: b
                          });
              }));
        var match = exprAppPrmToString(it._0, es, context);
        var match$1 = match.it;
        e = {
          it: {
            TAG: /* AppPrm */6,
            _0: match$1[0],
            _1: match$1[1]
          },
          ann: match.ann
        };
        break;
    case /* App */7 :
        var e$2 = printExp$1(it._0, {
              TAG: /* Expr */0,
              _0: true
            });
        var es$1 = Belt_List.map(it._1, (function (e) {
                return printExp$1(e, {
                            TAG: /* Expr */0,
                            _0: false
                          });
              }));
        e = {
          it: {
            TAG: /* App */7,
            _0: e$2,
            _1: es$1
          },
          ann: consumeContext(exprAppToString(getPrint(e$2), Belt_List.map(es$1, getPrint)), context)
        };
        break;
    case /* Bgn */8 :
        var es$2 = Belt_List.map(it._0, (function (e) {
                return printExp$1(e, {
                            TAG: /* Expr */0,
                            _0: false
                          });
              }));
        var e$3 = printExp$1(it._1, {
              TAG: /* Expr */0,
              _0: false
            });
        e = {
          it: {
            TAG: /* Bgn */8,
            _0: es$2,
            _1: e$3
          },
          ann: consumeContext(exprBgnToString$1(Belt_List.map(es$2, getPrint), getPrint(e$3)), context)
        };
        break;
    case /* If */9 :
        var e_cnd = printExp$1(it._0, {
              TAG: /* Expr */0,
              _0: true
            });
        var e_thn = printExp$1(it._1, {
              TAG: /* Expr */0,
              _0: true
            });
        var e_els = printExp$1(it._2, {
              TAG: /* Expr */0,
              _0: true
            });
        e = {
          it: {
            TAG: /* If */9,
            _0: e_cnd,
            _1: e_thn,
            _2: e_els
          },
          ann: consumeContextWrap(exprIfToString$1(getPrint(e_cnd), getPrint(e_thn), getPrint(e_els)), context)
        };
        break;
    case /* Cnd */10 :
        if (context.TAG === /* Expr */0) {
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "Multi-armed conditionals in JavaScript is not supported by the translator yet.",
                Error: new Error()
              };
        }
        var context$1 = context._0;
        var ebs = Belt_List.map(it._0, (function (eb) {
                return [
                        printExp$1(eb[0], {
                              TAG: /* Expr */0,
                              _0: false
                            }),
                        printBlock$1(eb[1], context$1)
                      ];
              }));
        var ob = obToString(it._1, context$1);
        e = {
          it: {
            TAG: /* Cnd */10,
            _0: ebs,
            _1: ob
          },
          ann: exprCndToString$1(Belt_List.map(ebs, (function (param) {
                      return [
                              getPrint(param[0]),
                              getPrint(param[1])
                            ];
                    })), Belt_Option.map(ob, getPrint))
        };
        break;
    case /* GLam */11 :
        var xs$1 = Belt_List.map(it._0, symbolToString$1);
        var b$2 = printBlock$1(it._1, /* Return */1);
        e = {
          it: {
            TAG: /* Lam */3,
            _0: xs$1,
            _1: b$2
          },
          ann: consumeContextWrap(exprGenToString$1(Belt_List.map(xs$1, getPrint), getPrint(b$2)), context)
        };
        break;
    case /* Yield */12 :
        var e$4 = printExp$1(it._0, {
              TAG: /* Expr */0,
              _0: false
            });
        e = {
          it: {
            TAG: /* Yield */12,
            _0: e$4
          },
          ann: consumeContextWrap(op1("yield ", getPrint(e$4), ""), context)
        };
        break;
    
  }
  return {
          it: e.it,
          ann: {
            sourceLocation: param.ann,
            print: e.ann
          }
        };
}

function defToString(param) {
  var d = param.it;
  var d$1;
  switch (d.TAG | 0) {
    case /* Var */0 :
        var x = symbolToString$1(d._0);
        var e = printExp$1(d._1, {
              TAG: /* Expr */0,
              _0: false
            });
        d$1 = {
          it: {
            TAG: /* Var */0,
            _0: x,
            _1: e
          },
          ann: defvarToString(getPrint(x), getPrint(e))
        };
        break;
    case /* Fun */1 :
        var f = symbolToString$1(d._0);
        var xs = Belt_List.map(d._1, symbolToString$1);
        var b = printBlock$1(d._2, /* Return */1);
        d$1 = {
          it: {
            TAG: /* Fun */1,
            _0: f,
            _1: xs,
            _2: b
          },
          ann: deffunToString$1(getPrint(f), Belt_List.map(xs, getPrint), getPrint(b))
        };
        break;
    case /* GFun */2 :
        var f$1 = symbolToString$1(d._0);
        var xs$1 = Belt_List.map(d._1, symbolToString$1);
        var b$1 = printBlock$1(d._2, /* Return */1);
        d$1 = {
          it: {
            TAG: /* GFun */2,
            _0: f$1,
            _1: xs$1,
            _2: b$1
          },
          ann: defgenToString$1(getPrint(f$1), Belt_List.map(xs$1, getPrint), getPrint(b$1))
        };
        break;
    
  }
  return {
          it: d$1.it,
          ann: {
            sourceLocation: param.ann,
            print: d$1.ann.it
          }
        };
}

function xeToString$1(param) {
  var xe = param.it;
  var x = symbolToString$1(xe[0]);
  var e = printExp$1(xe[1], {
        TAG: /* Expr */0,
        _0: false
      });
  var print = defvarToString(getPrint(x), getPrint(e)).it;
  return {
          it: [
            x,
            e
          ],
          ann: {
            sourceLocation: param.ann,
            print: print
          }
        };
}

function obToString(ob, ctx) {
  return Belt_Option.map(ob, (function (b) {
                return printBlock$1(b, ctx);
              }));
}

function printBlock$1(param, context) {
  var sourceLocation = param.ann;
  var b = param.it;
  if (b.TAG === /* BRet */0) {
    return mapAnn((function (e) {
                  return {
                          TAG: /* BRet */0,
                          _0: e
                        };
                }), printExp$1({
                    it: b._0,
                    ann: sourceLocation
                  }, {
                    TAG: /* Stat */1,
                    _0: context
                  }));
  }
  var t = printTerm$1(b._0, /* Step */0);
  var b$1 = printBlock$1(b._1, context);
  var print = {
    TAG: /* Group */1,
    _0: {
      hd: getPrint(t),
      tl: {
        hd: {
          it: {
            TAG: /* Plain */0,
            _0: "\n"
          },
          ann: undefined
        },
        tl: {
          hd: getPrint(b$1),
          tl: /* [] */0
        }
      }
    }
  };
  return {
          it: {
            TAG: /* BCons */1,
            _0: t,
            _1: b$1
          },
          ann: {
            sourceLocation: sourceLocation,
            print: print
          }
        };
}

function printTerm$1(param, ctx) {
  var sourceLocation = param.ann;
  var t = param.it;
  if (t.TAG === /* Def */0) {
    return mapAnn((function (v) {
                  return {
                          TAG: /* Def */0,
                          _0: v
                        };
                }), defToString({
                    it: t._0,
                    ann: sourceLocation
                  }));
  } else {
    return mapAnn((function (v) {
                  return {
                          TAG: /* Exp */1,
                          _0: v
                        };
                }), printExp$1({
                    it: t._0,
                    ann: sourceLocation
                  }, {
                    TAG: /* Stat */1,
                    _0: ctx
                  }));
  }
}

function printOutputlet$1(o) {
  var p = function (v) {
    switch (v.TAG | 0) {
      case /* Ref */0 :
          return "[Circular *" + String(v._0) + "]";
      case /* Con */1 :
          return constantToString$1(v._0);
      case /* Struct */2 :
          var content = v._1;
          var i = v._0;
          var i$1 = i !== undefined ? "<ref *" + String(i) + "> " : "";
          var content$1;
          if (content.TAG === /* Lst */0) {
            throw {
                  RE_EXN_ID: SMoLPrintError,
                  _1: "Lists are not supported in JavaScript.",
                  Error: new Error()
                };
          }
          content$1 = "[ " + $$String.concat(", ", Belt_List.map(content._0, p)) + " ]";
          return "" + i$1 + "" + content$1 + "";
      
    }
  };
  if (o) {
    return p(o._0);
  } else {
    return "error";
  }
}

function printOutput$1(sepOpt, os) {
  var sep = sepOpt !== undefined ? sepOpt : " ";
  return $$String.concat(sep, Belt_List.map(os, printOutputlet$1));
}

function printProgramFull$1(insertPrintTopLevel, p) {
  printingTopLevel.contents = insertPrintTopLevel;
  var print = function (param) {
    var sourceLocation = param.ann;
    var it = param.it;
    if (!it) {
      return {
              it: /* PNil */0,
              ann: {
                sourceLocation: sourceLocation,
                print: {
                  TAG: /* Group */1,
                  _0: /* [] */0
                }
              }
            };
    }
    var p = it._1;
    var t = printTerm$1(it._0, /* TopLevel */2);
    if (!p.it) {
      return {
              it: /* PCons */{
                _0: t,
                _1: {
                  it: /* PNil */0,
                  ann: {
                    sourceLocation: {
                      begin: sourceLocation.end,
                      end: sourceLocation.end
                    },
                    print: {
                      TAG: /* Plain */0,
                      _0: ""
                    }
                  }
                }
              },
              ann: {
                sourceLocation: sourceLocation,
                print: getPrint(t).it
              }
            };
    }
    var p$1 = print(p);
    return {
            it: /* PCons */{
              _0: t,
              _1: p$1
            },
            ann: {
              sourceLocation: sourceLocation,
              print: concat2(getPrint(t), "\n", getPrint(p$1))
            }
          };
  };
  return print(p);
}

function printProgram$1(insertPrintTopLevel, p) {
  return toString(printProgramFull$1(insertPrintTopLevel, p).ann.print);
}

function printStandAloneTerm$1(param) {
  var ann = param.ann;
  var it = param.it;
  var tmp;
  tmp = it.TAG === /* Def */0 ? defToString({
          it: it._0,
          ann: ann
        }).ann.print : printExp$1({
          it: it._0,
          ann: ann
        }, {
          TAG: /* Stat */1,
          _0: /* Step */0
        }).ann.print;
  return toString(tmp);
}

var JSPrinter = {
  printName: printName$1,
  printOutputlet: printOutputlet$1,
  printOutput: printOutput$1,
  printStandAloneTerm: printStandAloneTerm$1,
  printProgram: printProgram$1,
  printProgramFull: printProgramFull$1
};

function refMut(env, x) {
  if (env.TAG === /* G */0) {
    return ;
  }
  var decl = env._2;
  if (!Belt_HashSetString.has(env._0, x)) {
    var _env = env._1;
    while(true) {
      var env$1 = _env;
      if (env$1.TAG === /* G */0) {
        if (Belt_HashSetString.has(env$1._0, x)) {
          return Belt_HashMapString.set(decl, x, /* Global */1);
        } else {
          return ;
        }
      }
      if (Belt_HashSetString.has(env$1._0, x)) {
        return Belt_HashMapString.set(decl, x, /* Nonlocal */0);
      }
      _env = env$1._1;
      continue ;
    };
  }
  
}

function extend(ss, env) {
  var refs = Belt_HashMapString.make(0);
  return [
          refs,
          {
            TAG: /* E */1,
            _0: Belt_HashSetString.fromArray(Belt_List.toArray(ss)),
            _1: env,
            _2: refs
          }
        ];
}

function printName$2(x) {
  var re = /-/g;
  var matchFn = function (_matchPart, _offset, _wholeString) {
    return "_";
  };
  return x.replace(re, matchFn);
}

function constantToString$2(c) {
  if (typeof c === "number") {
    if (c === /* Uni */0) {
      return "None";
    }
    throw {
          RE_EXN_ID: SMoLPrintError,
          _1: "Lists are not supported in Python.",
          Error: new Error()
        };
  } else {
    switch (c.TAG | 0) {
      case /* Num */0 :
          return String(c._0);
      case /* Lgc */1 :
          if (c._0) {
            return "True";
          } else {
            return "False";
          }
      case /* Str */2 :
          return "\"" + $$String.escaped(c._0) + "\"";
      case /* Sym */3 :
          return c._0;
      
    }
  }
}

function listToString$2(es) {
  if (Belt_List.some(es, (function (e) {
            return containsNL(e.it);
          }))) {
    return {
            TAG: /* Group */1,
            _0: {
              hd: {
                it: {
                  TAG: /* Plain */0,
                  _0: "("
                },
                ann: undefined
              },
              tl: {
                hd: indentBlock({
                      it: concat(",\n", es),
                      ann: undefined
                    }, 4),
                tl: {
                  hd: {
                    it: {
                      TAG: /* Plain */0,
                      _0: ")"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          };
  } else {
    return {
            TAG: /* Group */1,
            _0: {
              hd: {
                it: {
                  TAG: /* Plain */0,
                  _0: "("
                },
                ann: undefined
              },
              tl: {
                hd: {
                  it: concat(", ", es),
                  ann: undefined
                },
                tl: {
                  hd: {
                    it: {
                      TAG: /* Plain */0,
                      _0: ")"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          };
  }
}

function defvarLike$2(op, x, e) {
  var ss_0 = {
    it: {
      TAG: /* Plain */0,
      _0: op
    },
    ann: undefined
  };
  var ss_1 = {
    hd: x,
    tl: {
      hd: {
        it: {
          TAG: /* Plain */0,
          _0: " = "
        },
        ann: undefined
      },
      tl: {
        hd: indent(e, 2),
        tl: /* [] */0
      }
    }
  };
  var ss = {
    hd: ss_0,
    tl: ss_1
  };
  return {
          it: {
            TAG: /* Group */1,
            _0: ss
          },
          ann: undefined
        };
}

function exprAppToString$1(e, es) {
  return group2(e, {
              it: listToString$2(es),
              ann: undefined
            });
}

var printingTopLevel$1 = {
  contents: false
};

function consumeContext$1(e, context) {
  if (context.TAG === /* Expr */0) {
    return surround("", e, "");
  }
  switch (context._0) {
    case /* Step */0 :
        return surround("", e, "");
    case /* Return */1 :
        return surround("return ", e, "");
    case /* TopLevel */2 :
        if (printingTopLevel$1.contents) {
          return surround("print(", e, ")");
        } else {
          return surround("", e, "");
        }
    
  }
}

function consumeContextWrap$1(e, context) {
  if (context.TAG === /* Expr */0 && context._0) {
    return surround("(", e, ")");
  } else {
    return consumeContext$1(e, context);
  }
}

function consumeContextVoid$1(e, context) {
  if (context.TAG === /* Expr */0) {
    return consumeContext$1(e, context);
  }
  switch (context._0) {
    case /* Step */0 :
        return consumeContext$1(e, context);
    case /* Return */1 :
        return surround("", e, "\nreturn");
    case /* TopLevel */2 :
        return surround("", e, "");
    
  }
}

function consumeContextStat$1(e, context) {
  if (context.TAG !== /* Expr */0) {
    return consumeContextVoid$1(e, context);
  }
  var err = "" + toString(e.it) + " can't be used as a expression in Python";
  throw {
        RE_EXN_ID: SMoLPrintError,
        _1: err,
        Error: new Error()
      };
}

function exprAppPrmToString$1(p, es, context) {
  if (typeof p === "number") {
    switch (p) {
      case /* PairNew */0 :
          if (es) {
            var match = es.tl;
            if (match && !match.tl) {
              var e1 = Curry._1(es.hd, false);
              var e2 = Curry._1(match.hd, false);
              return {
                      it: [
                        /* PairNew */0,
                        {
                          hd: e1,
                          tl: {
                            hd: e2,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContext$1(op2("[ ", getPrint(e1), ", ", getPrint(e2), " ]"), context)
                    };
            }
            
          }
          break;
      case /* PairRefLeft */1 :
          if (es && !es.tl) {
            var e1$1 = Curry._1(es.hd, true);
            return {
                    it: [
                      /* PairRefLeft */1,
                      {
                        hd: e1$1,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$1(op1("", getPrint(e1$1), "[0]"), context)
                  };
          }
          break;
      case /* PairRefRight */2 :
          if (es && !es.tl) {
            var e1$2 = Curry._1(es.hd, true);
            return {
                    it: [
                      /* PairRefRight */2,
                      {
                        hd: e1$2,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$1(op1("", getPrint(e1$2), "[1]"), context)
                  };
          }
          break;
      case /* PairSetLeft */3 :
          if (es) {
            var match$1 = es.tl;
            if (match$1 && !match$1.tl) {
              var e1$3 = Curry._1(es.hd, false);
              var e2$1 = Curry._1(match$1.hd, false);
              return {
                      it: [
                        /* PairSetLeft */3,
                        {
                          hd: e1$3,
                          tl: {
                            hd: e2$1,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContextStat$1(op2("", getPrint(e1$3), "[0] = ", getPrint(e2$1), ""), context)
                    };
            }
            
          }
          break;
      case /* PairSetRight */4 :
          if (es) {
            var match$2 = es.tl;
            if (match$2 && !match$2.tl) {
              var e1$4 = Curry._1(es.hd, false);
              var e2$2 = Curry._1(match$2.hd, false);
              return {
                      it: [
                        /* PairSetRight */4,
                        {
                          hd: e1$4,
                          tl: {
                            hd: e2$2,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContextStat$1(op2("", getPrint(e1$4), "[1] = ", getPrint(e2$2), ""), context)
                    };
            }
            
          }
          break;
      case /* VecNew */5 :
          var es$1 = Belt_List.map(es, (function (e) {
                  return Curry._1(e, false);
                }));
          return {
                  it: [
                    /* VecNew */5,
                    es$1
                  ],
                  ann: consumeContext$1(op1("[ ", {
                            it: concat(", ", Belt_List.map(es$1, getPrint)),
                            ann: undefined
                          }, " ]"), context)
                };
      case /* VecRef */6 :
          if (es) {
            var match$3 = es.tl;
            if (match$3 && !match$3.tl) {
              var e1$5 = Curry._1(es.hd, true);
              var e2$3 = Curry._1(match$3.hd, false);
              return {
                      it: [
                        /* VecRef */6,
                        {
                          hd: e1$5,
                          tl: {
                            hd: e2$3,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContext$1(op2("", getPrint(e1$5), "[", getPrint(e2$3), "]"), context)
                    };
            }
            
          }
          break;
      case /* VecSet */7 :
          if (es) {
            var match$4 = es.tl;
            if (match$4) {
              var match$5 = match$4.tl;
              if (match$5 && !match$5.tl) {
                var e1$6 = Curry._1(es.hd, true);
                var e2$4 = Curry._1(match$4.hd, false);
                var e3 = Curry._1(match$5.hd, false);
                return {
                        it: [
                          /* VecSet */7,
                          {
                            hd: e1$6,
                            tl: {
                              hd: e2$4,
                              tl: {
                                hd: e3,
                                tl: /* [] */0
                              }
                            }
                          }
                        ],
                        ann: consumeContextStat$1(op3("", getPrint(e1$6), "[", getPrint(e2$4), "] = ", getPrint(e3), ""), context)
                      };
              }
              
            }
            
          }
          break;
      case /* VecLen */8 :
          if (es && !es.tl) {
            var e1$7 = Curry._1(es.hd, false);
            return {
                    it: [
                      /* VecLen */8,
                      {
                        hd: e1$7,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$1(op1("len(", getPrint(e1$7), ")"), context)
                  };
          }
          break;
      case /* Err */9 :
          if (es && !es.tl) {
            var e1$8 = Curry._1(es.hd, true);
            return {
                    it: [
                      /* Err */9,
                      {
                        hd: e1$8,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextWrap$1(op1("raise ", getPrint(e1$8), ""), context)
                  };
          }
          break;
      case /* Not */10 :
          if (es && !es.tl) {
            var e1$9 = Curry._1(es.hd, true);
            return {
                    it: [
                      /* Not */10,
                      {
                        hd: e1$9,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextWrap$1(op1("not ", getPrint(e1$9), ""), context)
                  };
          }
          break;
      case /* Print */11 :
          if (es && !es.tl) {
            var e1$10 = Curry._1(es.hd, false);
            return {
                    it: [
                      /* Print */11,
                      {
                        hd: e1$10,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextVoid$1(op1("print(", getPrint(e1$10), ")"), context)
                  };
          }
          break;
      case /* Next */12 :
          if (es && !es.tl) {
            var e1$11 = Curry._1(es.hd, false);
            return {
                    it: [
                      /* Next */12,
                      {
                        hd: e1$11,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextVoid$1(op1("next(", getPrint(e1$11), ")"), context)
                  };
          }
          break;
      case /* Cons */13 :
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "List is not supported by Python",
                Error: new Error()
              };
      
    }
  } else {
    if (p.TAG === /* Arith */0) {
      var o = p._0;
      var os;
      switch (o) {
        case /* Add */0 :
            os = "+";
            break;
        case /* Sub */1 :
            os = "-";
            break;
        case /* Mul */2 :
            os = "*";
            break;
        case /* Div */3 :
            os = "/";
            break;
        
      }
      var es$2 = Belt_List.map(es, (function (e) {
              return Curry._1(e, true);
            }));
      return {
              it: [
                {
                  TAG: /* Arith */0,
                  _0: o
                },
                es$2
              ],
              ann: consumeContextWrap$1({
                    it: concat(" " + os + " ", Belt_List.map(es$2, getPrint)),
                    ann: undefined
                  }, context)
            };
    }
    if (es) {
      var match$6 = es.tl;
      if (match$6 && !match$6.tl) {
        var o$1 = p._0;
        var os$1;
        switch (o$1) {
          case /* Lt */0 :
              os$1 = "<";
              break;
          case /* Eq */1 :
              os$1 = "==";
              break;
          case /* Gt */2 :
              os$1 = ">";
              break;
          case /* Le */3 :
              os$1 = "<=";
              break;
          case /* Ge */4 :
              os$1 = ">=";
              break;
          case /* Ne */5 :
              os$1 = "!=";
              break;
          
        }
        var e1$12 = Curry._1(es.hd, true);
        var e2$5 = Curry._1(match$6.hd, true);
        return {
                it: [
                  {
                    TAG: /* Cmp */1,
                    _0: o$1
                  },
                  {
                    hd: e1$12,
                    tl: {
                      hd: e2$5,
                      tl: /* [] */0
                    }
                  }
                ],
                ann: consumeContext$1(op2("", getPrint(e1$12), " " + os$1 + " ", getPrint(e2$5), ""), context)
              };
      }
      
    }
    
  }
  var err = "Python doesn't let you use " + toString$1(p) + " on " + String(Belt_List.length(es)) + " parameter(s).";
  throw {
        RE_EXN_ID: SMoLPrintError,
        _1: err,
        Error: new Error()
      };
}

function funLike$1(op, x, xs, e) {
  return op2("" + op + " ", exprAppToString$1(x, xs), ":", indentBlock(e, 4), "");
}

function defvarToString$1(x, e) {
  return op1("", defvarLike$2("", x, e), "");
}

function deffunToString$2(f, xs, b) {
  return funLike$1("def", f, xs, b);
}

function defgenToString$2(f, xs, b) {
  return funLike$1("def", f, xs, b);
}

function exprLamToString$2(xs, b) {
  return op2("lambda ", {
              it: concat(",", xs),
              ann: undefined
            }, ": ", b, "");
}

function exprBgnToString$2(es, e) {
  return op1("", {
              it: listToString$2(Belt_List.concatMany([
                        es,
                        {
                          hd: e,
                          tl: /* [] */0
                        }
                      ])),
              ann: undefined
            }, "[-1]");
}

function exprCndToString$2(ebs, ob) {
  var ebs$1 = ob !== undefined ? Belt_List.concatMany([
          ebs,
          {
            hd: [
              {
                it: {
                  TAG: /* Plain */0,
                  _0: "se:"
                },
                ann: undefined
              },
              ob
            ],
            tl: /* [] */0
          }
        ]) : ebs;
  var ebs$2 = Belt_List.map(ebs$1, (function (param) {
          return op2("if ", param[0], ":", indentBlock(param[1], 4), "\n");
        }));
  return concat(" el", ebs$2);
}

function exprIfToString$2(e_cnd, e_thn, e_els) {
  return op3("", e_thn, " if ", e_cnd, " else ", e_els, "");
}

function symbolToString$2(param) {
  var it = param.it;
  return {
          it: it,
          ann: {
            sourceLocation: param.ann,
            print: {
              TAG: /* Plain */0,
              _0: printName$2(it)
            }
          }
        };
}

function printExp$2(param, context, env) {
  var it = param.it;
  var e;
  switch (it.TAG | 0) {
    case /* Con */0 :
        var c = it._0;
        var it$1 = constantToString$2(c);
        e = {
          it: {
            TAG: /* Con */0,
            _0: c
          },
          ann: consumeContext$1({
                it: {
                  TAG: /* Plain */0,
                  _0: it$1
                },
                ann: undefined
              }, context)
        };
        break;
    case /* Ref */1 :
        var x = it._0;
        var it$2 = printName$2(x);
        e = {
          it: {
            TAG: /* Ref */1,
            _0: x
          },
          ann: consumeContext$1({
                it: {
                  TAG: /* Plain */0,
                  _0: it$2
                },
                ann: undefined
              }, context)
        };
        break;
    case /* Set */2 :
        var x$1 = it._0;
        refMut(env, x$1.it);
        var x$2 = symbolToString$2(x$1);
        var e$1 = printExp$2(it._1, {
              TAG: /* Expr */0,
              _0: false
            }, env);
        e = {
          it: {
            TAG: /* Set */2,
            _0: x$2,
            _1: e$1
          },
          ann: consumeContextStat$1(defvarLike$2("", getPrint(x$2), getPrint(e$1)), context)
        };
        break;
    case /* Lam */3 :
        var b = it._1;
        var e$2 = b.it;
        if (e$2.TAG === /* BRet */0) {
          var e_it = e$2._0;
          var e_ann = b.ann;
          var e$3 = {
            it: e_it,
            ann: e_ann
          };
          var xs = Belt_List.map(it._0, symbolToString$2);
          var match = extend(Belt_List.map(xs, (function (x) {
                      return x.it;
                    })), env);
          var e$4 = printExp$2(e$3, {
                TAG: /* Expr */0,
                _0: false
              }, match[1]);
          if (Belt_HashMapString.isEmpty(match[0])) {
            e = {
              it: {
                TAG: /* Lam */3,
                _0: xs,
                _1: mapAnn((function (e) {
                        return {
                                TAG: /* BRet */0,
                                _0: e
                              };
                      }), e$4)
              },
              ann: consumeContextWrap$1(exprLamToString$2(Belt_List.map(xs, getPrint), getPrint(e$4)), context)
            };
          } else {
            throw {
                  RE_EXN_ID: SMoLPrintError,
                  _1: "Can't mutate variable inside Python lambda",
                  Error: new Error()
                };
          }
        } else {
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "In Python, a lambda body must contains exactly one expression",
                Error: new Error()
              };
        }
        break;
    case /* Let */4 :
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "let-expressions are not supported by Python",
              Error: new Error()
            };
    case /* Letrec */5 :
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "letrec-expressions are not supported by Python",
              Error: new Error()
            };
    case /* AppPrm */6 :
        var es = Belt_List.map(it._1, (function (e, b) {
                return printExp$2(e, {
                            TAG: /* Expr */0,
                            _0: b
                          }, env);
              }));
        var match$1 = exprAppPrmToString$1(it._0, es, context);
        var match$2 = match$1.it;
        e = {
          it: {
            TAG: /* AppPrm */6,
            _0: match$2[0],
            _1: match$2[1]
          },
          ann: match$1.ann
        };
        break;
    case /* App */7 :
        var e$5 = printExp$2(it._0, {
              TAG: /* Expr */0,
              _0: true
            }, env);
        var es$1 = Belt_List.map(it._1, (function (e) {
                return printExp$2(e, {
                            TAG: /* Expr */0,
                            _0: false
                          }, env);
              }));
        e = {
          it: {
            TAG: /* App */7,
            _0: e$5,
            _1: es$1
          },
          ann: consumeContext$1(exprAppToString$1(getPrint(e$5), Belt_List.map(es$1, getPrint)), context)
        };
        break;
    case /* Bgn */8 :
        var es$2 = Belt_List.map(it._0, (function (e) {
                return printExp$2(e, {
                            TAG: /* Expr */0,
                            _0: false
                          }, env);
              }));
        var e$6 = printExp$2(it._1, {
              TAG: /* Expr */0,
              _0: false
            }, env);
        e = {
          it: {
            TAG: /* Bgn */8,
            _0: es$2,
            _1: e$6
          },
          ann: consumeContext$1(exprBgnToString$2(Belt_List.map(es$2, getPrint), getPrint(e$6)), context)
        };
        break;
    case /* If */9 :
        var e_cnd = printExp$2(it._0, {
              TAG: /* Expr */0,
              _0: true
            }, env);
        var e_thn = printExp$2(it._1, {
              TAG: /* Expr */0,
              _0: true
            }, env);
        var e_els = printExp$2(it._2, {
              TAG: /* Expr */0,
              _0: true
            }, env);
        e = {
          it: {
            TAG: /* If */9,
            _0: e_cnd,
            _1: e_thn,
            _2: e_els
          },
          ann: consumeContextWrap$1(exprIfToString$2(getPrint(e_cnd), getPrint(e_thn), getPrint(e_els)), context)
        };
        break;
    case /* Cnd */10 :
        if (context.TAG === /* Expr */0) {
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "Multi-armed conditionals in JavaScript is not supported by the translator yet.",
                Error: new Error()
              };
        }
        var context$1 = context._0;
        var ebs = Belt_List.map(it._0, (function (eb) {
                return [
                        printExp$2(eb[0], {
                              TAG: /* Expr */0,
                              _0: false
                            }, env),
                        printBlock$2(eb[1], context$1, env)
                      ];
              }));
        var ob = obToString$1(it._1, context$1, env);
        e = {
          it: {
            TAG: /* Cnd */10,
            _0: ebs,
            _1: ob
          },
          ann: exprCndToString$2(Belt_List.map(ebs, (function (param) {
                      return [
                              getPrint(param[0]),
                              getPrint(param[1])
                            ];
                    })), Belt_Option.map(ob, getPrint))
        };
        break;
    case /* GLam */11 :
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "In Python, lambdas can't be generators.",
              Error: new Error()
            };
    case /* Yield */12 :
        var e$7 = printExp$2(it._0, {
              TAG: /* Expr */0,
              _0: false
            }, env);
        e = {
          it: {
            TAG: /* Yield */12,
            _0: e$7
          },
          ann: consumeContextWrap$1(op1("yield ", getPrint(e$7), ""), context)
        };
        break;
    
  }
  return {
          it: e.it,
          ann: {
            sourceLocation: param.ann,
            print: e.ann
          }
        };
}

function defToString$1(param, env) {
  var d = param.it;
  var d$1;
  switch (d.TAG | 0) {
    case /* Var */0 :
        var x = symbolToString$2(d._0);
        var e = printExp$2(d._1, {
              TAG: /* Expr */0,
              _0: false
            }, env);
        d$1 = {
          it: {
            TAG: /* Var */0,
            _0: x,
            _1: e
          },
          ann: defvarToString$1(getPrint(x), getPrint(e))
        };
        break;
    case /* Fun */1 :
        var f = symbolToString$2(d._0);
        var xs = Belt_List.map(d._1, symbolToString$2);
        var b = printBody(d._2, /* Return */1, Belt_List.map(xs, (function (x) {
                    return x.it;
                  })), env);
        d$1 = {
          it: {
            TAG: /* Fun */1,
            _0: f,
            _1: xs,
            _2: b
          },
          ann: deffunToString$2(getPrint(f), Belt_List.map(xs, getPrint), getPrint(b))
        };
        break;
    case /* GFun */2 :
        var f$1 = symbolToString$2(d._0);
        var xs$1 = Belt_List.map(d._1, symbolToString$2);
        var b$1 = printBody(d._2, /* Return */1, Belt_List.map(xs$1, (function (x) {
                    return x.it;
                  })), env);
        d$1 = {
          it: {
            TAG: /* GFun */2,
            _0: f$1,
            _1: xs$1,
            _2: b$1
          },
          ann: defgenToString$2(getPrint(f$1), Belt_List.map(xs$1, getPrint), getPrint(b$1))
        };
        break;
    
  }
  return {
          it: d$1.it,
          ann: {
            sourceLocation: param.ann,
            print: d$1.ann.it
          }
        };
}

function obToString$1(ob, ctx, env) {
  return Belt_Option.map(ob, (function (b) {
                return printBlock$2(b, ctx, env);
              }));
}

function printBlock$2(b, context, env) {
  var xs = xsOfBlock(b);
  if (xs !== /* [] */0) {
    throw {
          RE_EXN_ID: SMoLPrintError,
          _1: "Python blocks can't declare local variables",
          Error: new Error()
        };
  }
  var printBlock$3 = function (param) {
    var sourceLocation = param.ann;
    var b = param.it;
    if (b.TAG === /* BRet */0) {
      return mapAnn((function (e) {
                    return {
                            TAG: /* BRet */0,
                            _0: e
                          };
                  }), printExp$2({
                      it: b._0,
                      ann: sourceLocation
                    }, {
                      TAG: /* Stat */1,
                      _0: context
                    }, env));
    }
    var t = printTerm$2(b._0, /* Step */0, env);
    var b$1 = printBlock$3(b._1);
    var print = {
      TAG: /* Group */1,
      _0: {
        hd: getPrint(t),
        tl: {
          hd: {
            it: {
              TAG: /* Plain */0,
              _0: "\n"
            },
            ann: undefined
          },
          tl: {
            hd: getPrint(b$1),
            tl: /* [] */0
          }
        }
      }
    };
    return {
            it: {
              TAG: /* BCons */1,
              _0: t,
              _1: b$1
            },
            ann: {
              sourceLocation: sourceLocation,
              print: print
            }
          };
  };
  return printBlock$3(b);
}

function printBody(b, context, args, env) {
  var match = extend(Belt_List.concat(Belt_List.map(xsOfBlock(b), (function (x) {
                  return x.it;
                })), args), env);
  var env$1 = match[1];
  var printBlock = function (param) {
    var sourceLocation = param.ann;
    var b = param.it;
    if (b.TAG === /* BRet */0) {
      return mapAnn((function (e) {
                    return {
                            TAG: /* BRet */0,
                            _0: e
                          };
                  }), printExp$2({
                      it: b._0,
                      ann: sourceLocation
                    }, {
                      TAG: /* Stat */1,
                      _0: context
                    }, env$1));
    }
    var t = printTerm$2(b._0, /* Step */0, env$1);
    var b$1 = printBlock(b._1);
    var print = {
      TAG: /* Group */1,
      _0: {
        hd: getPrint(t),
        tl: {
          hd: {
            it: {
              TAG: /* Plain */0,
              _0: "\n"
            },
            ann: undefined
          },
          tl: {
            hd: getPrint(b$1),
            tl: /* [] */0
          }
        }
      }
    };
    return {
            it: {
              TAG: /* BCons */1,
              _0: t,
              _1: b$1
            },
            ann: {
              sourceLocation: sourceLocation,
              print: print
            }
          };
  };
  var b$1 = printBlock(b);
  var print = concat("\n", Belt_List.concatMany([
            Belt_List.fromArray(Belt_HashMapString.toArray(match[0]).map(function (param) {
                      return {
                              it: {
                                TAG: /* Plain */0,
                                _0: "" + (
                                  param[1] ? "global" : "nonlocal"
                                ) + " " + param[0] + ""
                              },
                              ann: undefined
                            };
                    })),
            {
              hd: getPrint(b$1),
              tl: /* [] */0
            }
          ]));
  return {
          it: b$1.it,
          ann: {
            sourceLocation: b$1.ann.sourceLocation,
            print: print
          }
        };
}

function printTerm$2(param, ctx, env) {
  var sourceLocation = param.ann;
  var t = param.it;
  if (t.TAG === /* Def */0) {
    return mapAnn((function (v) {
                  return {
                          TAG: /* Def */0,
                          _0: v
                        };
                }), defToString$1({
                    it: t._0,
                    ann: sourceLocation
                  }, env));
  } else {
    return mapAnn((function (v) {
                  return {
                          TAG: /* Exp */1,
                          _0: v
                        };
                }), printExp$2({
                    it: t._0,
                    ann: sourceLocation
                  }, {
                    TAG: /* Stat */1,
                    _0: ctx
                  }, env));
  }
}

function printOutputlet$2(o) {
  var p = function (v) {
    switch (v.TAG | 0) {
      case /* Ref */0 :
          return "[...]";
      case /* Con */1 :
          return constantToString$2(v._0);
      case /* Struct */2 :
          var content = v._1;
          var i = "";
          var content$1;
          if (content.TAG === /* Lst */0) {
            throw {
                  RE_EXN_ID: SMoLPrintError,
                  _1: "Lists are not supported in Python.",
                  Error: new Error()
                };
          }
          content$1 = "[" + $$String.concat(", ", Belt_List.map(content._0, p)) + "]";
          return "" + i + "" + content$1 + "";
      
    }
  };
  if (o) {
    return p(o._0);
  } else {
    return "error";
  }
}

function printOutput$2(sepOpt, os) {
  var sep = sepOpt !== undefined ? sepOpt : " ";
  return $$String.concat(sep, Belt_List.map(os, printOutputlet$2));
}

function printProgramFull$2(insertPrintTopLevel, p) {
  printingTopLevel$1.contents = insertPrintTopLevel;
  var xs = xsOfProgram(p);
  var env = {
    TAG: /* G */0,
    _0: Belt_HashSetString.fromArray(Belt_List.toArray(Belt_List.map(xs, (function (x) {
                    return x.it;
                  }))))
  };
  var print = function (param) {
    var sourceLocation = param.ann;
    var it = param.it;
    if (!it) {
      return {
              it: /* PNil */0,
              ann: {
                sourceLocation: sourceLocation,
                print: {
                  TAG: /* Group */1,
                  _0: /* [] */0
                }
              }
            };
    }
    var p = it._1;
    var t = printTerm$2(it._0, /* TopLevel */2, env);
    if (!p.it) {
      return {
              it: /* PCons */{
                _0: t,
                _1: {
                  it: /* PNil */0,
                  ann: {
                    sourceLocation: {
                      begin: sourceLocation.end,
                      end: sourceLocation.end
                    },
                    print: {
                      TAG: /* Plain */0,
                      _0: ""
                    }
                  }
                }
              },
              ann: {
                sourceLocation: sourceLocation,
                print: getPrint(t).it
              }
            };
    }
    var p$1 = print(p);
    return {
            it: /* PCons */{
              _0: t,
              _1: p$1
            },
            ann: {
              sourceLocation: sourceLocation,
              print: concat2(getPrint(t), "\n", getPrint(p$1))
            }
          };
  };
  return print(p);
}

function printProgram$2(insertPrintTopLevel, p) {
  return toString(printProgramFull$2(insertPrintTopLevel, p).ann.print);
}

function printStandAloneTerm$2(param) {
  var ann = param.ann;
  var it = param.it;
  var globalEnv = {
    TAG: /* G */0,
    _0: Belt_HashSetString.fromArray([])
  };
  var tmp;
  tmp = it.TAG === /* Def */0 ? defToString$1({
          it: it._0,
          ann: ann
        }, globalEnv).ann.print : printExp$2({
          it: it._0,
          ann: ann
        }, {
          TAG: /* Stat */1,
          _0: /* Step */0
        }, globalEnv).ann.print;
  return toString(tmp);
}

var PYPrinter = {
  printName: printName$2,
  printOutputlet: printOutputlet$2,
  printOutput: printOutput$2,
  printStandAloneTerm: printStandAloneTerm$2,
  printProgram: printProgram$2,
  printProgramFull: printProgramFull$2
};

function printName$3(x) {
  var re = /-./g;
  var matchFn = function (matchPart, _offset, _wholeString) {
    return matchPart.substring(1).toUpperCase();
  };
  var x$1 = x.replace(re, matchFn);
  if (x$1 === "var") {
    return "$var";
  } else {
    return x$1;
  }
}

function constantToString$3(c) {
  if (typeof c === "number") {
    if (c === /* Uni */0) {
      return "null";
    } else {
      return "list[]";
    }
  }
  switch (c.TAG | 0) {
    case /* Num */0 :
        return String(c._0);
    case /* Lgc */1 :
        if (c._0) {
          return "true";
        } else {
          return "false";
        }
    case /* Str */2 :
        return "\"" + $$String.escaped(c._0) + "\"";
    case /* Sym */3 :
        return c._0;
    
  }
}

function listToString$3(es) {
  if (Belt_List.some(es, (function (e) {
            return containsNL(e.it);
          }))) {
    return {
            TAG: /* Group */1,
            _0: {
              hd: {
                it: {
                  TAG: /* Plain */0,
                  _0: "("
                },
                ann: undefined
              },
              tl: {
                hd: indentBlock({
                      it: concat(",\n", es),
                      ann: undefined
                    }, 2),
                tl: {
                  hd: {
                    it: {
                      TAG: /* Plain */0,
                      _0: ")"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          };
  } else {
    return {
            TAG: /* Group */1,
            _0: {
              hd: {
                it: {
                  TAG: /* Plain */0,
                  _0: "("
                },
                ann: undefined
              },
              tl: {
                hd: {
                  it: concat(", ", es),
                  ann: undefined
                },
                tl: {
                  hd: {
                    it: {
                      TAG: /* Plain */0,
                      _0: ")"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          };
  }
}

function defvarLike$3(op, x, e) {
  var ss_0 = {
    it: {
      TAG: /* Plain */0,
      _0: op
    },
    ann: undefined
  };
  var ss_1 = {
    hd: x,
    tl: {
      hd: {
        it: {
          TAG: /* Plain */0,
          _0: " = "
        },
        ann: undefined
      },
      tl: {
        hd: indent(e, 2),
        tl: /* [] */0
      }
    }
  };
  var ss = {
    hd: ss_0,
    tl: ss_1
  };
  return {
          it: {
            TAG: /* Group */1,
            _0: ss
          },
          ann: undefined
        };
}

function exprAppToString$2(e, es) {
  return group2(e, {
              it: listToString$3(es),
              ann: undefined
            });
}

var printingTopLevel$2 = {
  contents: false
};

function consumeContext$2(e, context) {
  if (context.TAG === /* Expr */0) {
    return surround("", e, "");
  }
  switch (context._0) {
    case /* Return */1 :
        return surround("return ", e, "");
    case /* Step */0 :
    case /* TopLevel */2 :
        return surround("", e, "");
    
  }
}

function consumeContextWrap$2(e, context) {
  if (context.TAG === /* Expr */0 && context._0) {
    return surround("(", e, ")");
  } else {
    return consumeContext$2(e, context);
  }
}

function consumeContextVoid$2(e, context) {
  if (context.TAG === /* Expr */0) {
    return consumeContext$2(e, context);
  }
  switch (context._0) {
    case /* Step */0 :
        return consumeContext$2(e, context);
    case /* Return */1 :
        return surround("", e, "\nreturn");
    case /* TopLevel */2 :
        return surround("", e, "");
    
  }
}

function exprAppPrmToString$2(p, es, context) {
  if (typeof p === "number") {
    switch (p) {
      case /* PairNew */0 :
          if (es) {
            var match = es.tl;
            if (match && !match.tl) {
              var e1 = Curry._1(es.hd, false);
              var e2 = Curry._1(match.hd, false);
              return {
                      it: [
                        /* PairNew */0,
                        {
                          hd: e1,
                          tl: {
                            hd: e2,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContext$2(op2("vec[", getPrint(e1), ", ", getPrint(e2), "]"), context)
                    };
            }
            
          }
          break;
      case /* PairRefLeft */1 :
          if (es && !es.tl) {
            var e1$1 = Curry._1(es.hd, true);
            return {
                    it: [
                      /* PairRefLeft */1,
                      {
                        hd: e1$1,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$2(op1("", getPrint(e1$1), "[0]"), context)
                  };
          }
          break;
      case /* PairRefRight */2 :
          if (es && !es.tl) {
            var e1$2 = Curry._1(es.hd, true);
            return {
                    it: [
                      /* PairRefRight */2,
                      {
                        hd: e1$2,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$2(op1("", getPrint(e1$2), "[1]"), context)
                  };
          }
          break;
      case /* PairSetLeft */3 :
          if (es) {
            var match$1 = es.tl;
            if (match$1 && !match$1.tl) {
              var e1$3 = Curry._1(es.hd, false);
              var e2$1 = Curry._1(match$1.hd, false);
              return {
                      it: [
                        /* PairSetLeft */3,
                        {
                          hd: e1$3,
                          tl: {
                            hd: e2$1,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContextVoid$2(op2("", getPrint(e1$3), "[0] = ", getPrint(e2$1), ""), context)
                    };
            }
            
          }
          break;
      case /* PairSetRight */4 :
          if (es) {
            var match$2 = es.tl;
            if (match$2 && !match$2.tl) {
              var e1$4 = Curry._1(es.hd, false);
              var e2$2 = Curry._1(match$2.hd, false);
              return {
                      it: [
                        /* PairSetRight */4,
                        {
                          hd: e1$4,
                          tl: {
                            hd: e2$2,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContextVoid$2(op2("", getPrint(e1$4), "[1] = ", getPrint(e2$2), ""), context)
                    };
            }
            
          }
          break;
      case /* VecNew */5 :
          var es$1 = Belt_List.map(es, (function (e) {
                  return Curry._1(e, false);
                }));
          return {
                  it: [
                    /* VecNew */5,
                    es$1
                  ],
                  ann: consumeContext$2(op1("vec[", {
                            it: concat(", ", Belt_List.map(es$1, getPrint)),
                            ann: undefined
                          }, "]"), context)
                };
      case /* VecRef */6 :
          if (es) {
            var match$3 = es.tl;
            if (match$3 && !match$3.tl) {
              var e1$5 = Curry._1(es.hd, true);
              var e2$3 = Curry._1(match$3.hd, false);
              return {
                      it: [
                        /* VecRef */6,
                        {
                          hd: e1$5,
                          tl: {
                            hd: e2$3,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContext$2(op2("", getPrint(e1$5), "[", getPrint(e2$3), "]"), context)
                    };
            }
            
          }
          break;
      case /* VecSet */7 :
          if (es) {
            var match$4 = es.tl;
            if (match$4) {
              var match$5 = match$4.tl;
              if (match$5 && !match$5.tl) {
                var e1$6 = Curry._1(es.hd, true);
                var e2$4 = Curry._1(match$4.hd, false);
                var e3 = Curry._1(match$5.hd, false);
                return {
                        it: [
                          /* VecSet */7,
                          {
                            hd: e1$6,
                            tl: {
                              hd: e2$4,
                              tl: {
                                hd: e3,
                                tl: /* [] */0
                              }
                            }
                          }
                        ],
                        ann: consumeContextVoid$2(op3("", getPrint(e1$6), "[", getPrint(e2$4), "] = ", getPrint(e3), ""), context)
                      };
              }
              
            }
            
          }
          break;
      case /* VecLen */8 :
          if (es && !es.tl) {
            var e1$7 = Curry._1(es.hd, false);
            return {
                    it: [
                      /* VecLen */8,
                      {
                        hd: e1$7,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$2(op1("", getPrint(e1$7), ".length"), context)
                  };
          }
          break;
      case /* Err */9 :
          if (es && !es.tl) {
            var e1$8 = Curry._1(es.hd, true);
            return {
                    it: [
                      /* Err */9,
                      {
                        hd: e1$8,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextWrap$2(op1("throw ", getPrint(e1$8), ""), context)
                  };
          }
          break;
      case /* Not */10 :
          if (es && !es.tl) {
            var e1$9 = Curry._1(es.hd, true);
            return {
                    it: [
                      /* Not */10,
                      {
                        hd: e1$9,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextWrap$2(op1("Â¬ ", getPrint(e1$9), ""), context)
                  };
          }
          break;
      case /* Print */11 :
          if (es && !es.tl) {
            var e1$10 = Curry._1(es.hd, false);
            return {
                    it: [
                      /* Print */11,
                      {
                        hd: e1$10,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextVoid$2(op1("print(", getPrint(e1$10), ")"), context)
                  };
          }
          break;
      case /* Next */12 :
          if (es && !es.tl) {
            var e1$11 = Curry._1(es.hd, false);
            return {
                    it: [
                      /* Next */12,
                      {
                        hd: e1$11,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextVoid$2(op1("next(", getPrint(e1$11), ")"), context)
                  };
          }
          break;
      case /* Cons */13 :
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "List is not supported by the pseudo-code syntax",
                Error: new Error()
              };
      
    }
  } else {
    if (p.TAG === /* Arith */0) {
      var o = p._0;
      var os;
      switch (o) {
        case /* Add */0 :
            os = "+";
            break;
        case /* Sub */1 :
            os = "-";
            break;
        case /* Mul */2 :
            os = "*";
            break;
        case /* Div */3 :
            os = "/";
            break;
        
      }
      var es$2 = Belt_List.map(es, (function (e) {
              return Curry._1(e, true);
            }));
      return {
              it: [
                {
                  TAG: /* Arith */0,
                  _0: o
                },
                es$2
              ],
              ann: consumeContextWrap$2({
                    it: concat(" " + os + " ", Belt_List.map(es$2, getPrint)),
                    ann: undefined
                  }, context)
            };
    }
    if (es) {
      var match$6 = es.tl;
      if (match$6 && !match$6.tl) {
        var o$1 = p._0;
        var os$1;
        switch (o$1) {
          case /* Lt */0 :
              os$1 = "<";
              break;
          case /* Eq */1 :
              os$1 = "==";
              break;
          case /* Gt */2 :
              os$1 = ">";
              break;
          case /* Le */3 :
              os$1 = "<=";
              break;
          case /* Ge */4 :
              os$1 = ">=";
              break;
          case /* Ne */5 :
              os$1 = "!=";
              break;
          
        }
        var e1$12 = Curry._1(es.hd, true);
        var e2$5 = Curry._1(match$6.hd, true);
        return {
                it: [
                  {
                    TAG: /* Cmp */1,
                    _0: o$1
                  },
                  {
                    hd: e1$12,
                    tl: {
                      hd: e2$5,
                      tl: /* [] */0
                    }
                  }
                ],
                ann: consumeContext$2(op2("", getPrint(e1$12), " " + os$1 + " ", getPrint(e2$5), ""), context)
              };
      }
      
    }
    
  }
  var err = "Our pseudo-code syntax doesn't let you use " + toString$1(p) + " on " + String(Belt_List.length(es)) + " parameter(s).";
  throw {
        RE_EXN_ID: SMoLPrintError,
        _1: err,
        Error: new Error()
      };
}

function funLike$2(op, x, xs, e) {
  return op2("" + op + " ", exprAppToString$2(x, xs), ":", indentBlock(e, 2), "\nend");
}

function defvarToString$2(x, e) {
  return op1("", defvarLike$3("let ", x, e), "");
}

function deffunToString$3(f, xs, b) {
  return funLike$2("fun", f, xs, b);
}

function defgenToString$3(f, xs, b) {
  return funLike$2("gen fun", f, xs, b);
}

function exprSetToString(x, e) {
  return op2("", x, " = ", e, "");
}

function exprLamToString$3(xs, b) {
  return funLike$2("lam", {
              it: {
                TAG: /* Plain */0,
                _0: ""
              },
              ann: undefined
            }, xs, b);
}

function exprGenToString$2(xs, b) {
  return funLike$2("gen lam", {
              it: {
                TAG: /* Plain */0,
                _0: ""
              },
              ann: undefined
            }, xs, b);
}

function exprBgnToString$3(es, e) {
  return {
          it: listToString$3(Belt_List.concatMany([
                    es,
                    {
                      hd: e,
                      tl: /* [] */0
                    }
                  ])),
          ann: undefined
        };
}

function exprCndToString$3(ebs, ob) {
  var ebs$1 = ob !== undefined ? Belt_List.concatMany([
          ebs,
          {
            hd: [
              {
                it: {
                  TAG: /* Plain */0,
                  _0: ""
                },
                ann: undefined
              },
              ob
            ],
            tl: /* [] */0
          }
        ]) : ebs;
  var ebs$2 = Belt_List.map(ebs$1, (function (param) {
          return op2("if ", param[0], ":", indentBlock(param[1], 2), "\nend");
        }));
  return concat(" else ", ebs$2);
}

function exprIfToString$3(e_cnd, e_thn, e_els) {
  return op3("if ", e_cnd, ": ", e_thn, " else: ", e_els, " end");
}

function symbolToString$3(param) {
  var it = param.it;
  return {
          it: it,
          ann: {
            sourceLocation: param.ann,
            print: {
              TAG: /* Plain */0,
              _0: printName$3(it)
            }
          }
        };
}

function printExp$3(param, context) {
  var it = param.it;
  var e;
  switch (it.TAG | 0) {
    case /* Con */0 :
        var c = it._0;
        var it$1 = constantToString$3(c);
        e = {
          it: {
            TAG: /* Con */0,
            _0: c
          },
          ann: consumeContext$2({
                it: {
                  TAG: /* Plain */0,
                  _0: it$1
                },
                ann: undefined
              }, context)
        };
        break;
    case /* Ref */1 :
        var x = it._0;
        var it$2 = printName$3(x);
        e = {
          it: {
            TAG: /* Ref */1,
            _0: x
          },
          ann: consumeContext$2({
                it: {
                  TAG: /* Plain */0,
                  _0: it$2
                },
                ann: undefined
              }, context)
        };
        break;
    case /* Set */2 :
        var x$1 = symbolToString$3(it._0);
        var e$1 = printExp$3(it._1, {
              TAG: /* Expr */0,
              _0: false
            });
        e = {
          it: {
            TAG: /* Set */2,
            _0: x$1,
            _1: e$1
          },
          ann: consumeContextWrap$2(exprSetToString(getPrint(x$1), getPrint(e$1)), context)
        };
        break;
    case /* Lam */3 :
        var xs = Belt_List.map(it._0, symbolToString$3);
        var b = printBlock$3(it._1, /* Return */1);
        e = {
          it: {
            TAG: /* Lam */3,
            _0: xs,
            _1: b
          },
          ann: consumeContextWrap$2(exprLamToString$3(Belt_List.map(xs, getPrint), getPrint(b)), context)
        };
        break;
    case /* Let */4 :
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "let-expressions are not supported by our pseudo-code syntax",
              Error: new Error()
            };
    case /* Letrec */5 :
        if (context.TAG === /* Expr */0) {
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "letrec-expressions are not supported by our pseudo-code syntax",
                Error: new Error()
              };
        }
        var xes = Belt_List.map(it._0, xeToString$2);
        var b$1 = printBlock$3(it._1, context._0);
        e = {
          it: {
            TAG: /* Letrec */5,
            _0: xes,
            _1: b$1
          },
          ann: {
            TAG: /* Group */1,
            _0: {
              hd: {
                it: {
                  TAG: /* Plain */0,
                  _0: "{\n"
                },
                ann: undefined
              },
              tl: {
                hd: indentBlock({
                      it: concat("\n", Belt_List.concatMany([
                                Belt_List.map(xes, getPrint),
                                {
                                  hd: getPrint(b$1),
                                  tl: /* [] */0
                                }
                              ])),
                      ann: undefined
                    }, 2),
                tl: {
                  hd: {
                    it: {
                      TAG: /* Plain */0,
                      _0: "\n}"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        };
        break;
    case /* AppPrm */6 :
        var es = Belt_List.map(it._1, (function (e, b) {
                return printExp$3(e, {
                            TAG: /* Expr */0,
                            _0: b
                          });
              }));
        var match = exprAppPrmToString$2(it._0, es, context);
        var match$1 = match.it;
        e = {
          it: {
            TAG: /* AppPrm */6,
            _0: match$1[0],
            _1: match$1[1]
          },
          ann: match.ann
        };
        break;
    case /* App */7 :
        var e$2 = printExp$3(it._0, {
              TAG: /* Expr */0,
              _0: true
            });
        var es$1 = Belt_List.map(it._1, (function (e) {
                return printExp$3(e, {
                            TAG: /* Expr */0,
                            _0: false
                          });
              }));
        e = {
          it: {
            TAG: /* App */7,
            _0: e$2,
            _1: es$1
          },
          ann: consumeContext$2(exprAppToString$2(getPrint(e$2), Belt_List.map(es$1, getPrint)), context)
        };
        break;
    case /* Bgn */8 :
        var es$2 = Belt_List.map(it._0, (function (e) {
                return printExp$3(e, {
                            TAG: /* Expr */0,
                            _0: false
                          });
              }));
        var e$3 = printExp$3(it._1, {
              TAG: /* Expr */0,
              _0: false
            });
        e = {
          it: {
            TAG: /* Bgn */8,
            _0: es$2,
            _1: e$3
          },
          ann: consumeContext$2(exprBgnToString$3(Belt_List.map(es$2, getPrint), getPrint(e$3)), context)
        };
        break;
    case /* If */9 :
        var e_cnd = printExp$3(it._0, {
              TAG: /* Expr */0,
              _0: true
            });
        var e_thn = printExp$3(it._1, {
              TAG: /* Expr */0,
              _0: true
            });
        var e_els = printExp$3(it._2, {
              TAG: /* Expr */0,
              _0: true
            });
        e = {
          it: {
            TAG: /* If */9,
            _0: e_cnd,
            _1: e_thn,
            _2: e_els
          },
          ann: consumeContextWrap$2(exprIfToString$3(getPrint(e_cnd), getPrint(e_thn), getPrint(e_els)), context)
        };
        break;
    case /* Cnd */10 :
        if (context.TAG === /* Expr */0) {
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "Multi-armed conditionals in our pseudo-code syntax is not supported by the translator yet.",
                Error: new Error()
              };
        }
        var context$1 = context._0;
        var ebs = Belt_List.map(it._0, (function (eb) {
                return [
                        printExp$3(eb[0], {
                              TAG: /* Expr */0,
                              _0: false
                            }),
                        printBlock$3(eb[1], context$1)
                      ];
              }));
        var ob = obToString$2(it._1, context$1);
        e = {
          it: {
            TAG: /* Cnd */10,
            _0: ebs,
            _1: ob
          },
          ann: exprCndToString$3(Belt_List.map(ebs, (function (param) {
                      return [
                              getPrint(param[0]),
                              getPrint(param[1])
                            ];
                    })), Belt_Option.map(ob, getPrint))
        };
        break;
    case /* GLam */11 :
        var xs$1 = Belt_List.map(it._0, symbolToString$3);
        var b$2 = printBlock$3(it._1, /* Return */1);
        e = {
          it: {
            TAG: /* Lam */3,
            _0: xs$1,
            _1: b$2
          },
          ann: consumeContextWrap$2(exprGenToString$2(Belt_List.map(xs$1, getPrint), getPrint(b$2)), context)
        };
        break;
    case /* Yield */12 :
        var e$4 = printExp$3(it._0, {
              TAG: /* Expr */0,
              _0: false
            });
        e = {
          it: {
            TAG: /* Yield */12,
            _0: e$4
          },
          ann: consumeContextWrap$2(op1("yield ", getPrint(e$4), ""), context)
        };
        break;
    
  }
  return {
          it: e.it,
          ann: {
            sourceLocation: param.ann,
            print: e.ann
          }
        };
}

function defToString$2(param) {
  var d = param.it;
  var d$1;
  switch (d.TAG | 0) {
    case /* Var */0 :
        var x = symbolToString$3(d._0);
        var e = printExp$3(d._1, {
              TAG: /* Expr */0,
              _0: false
            });
        d$1 = {
          it: {
            TAG: /* Var */0,
            _0: x,
            _1: e
          },
          ann: defvarToString$2(getPrint(x), getPrint(e))
        };
        break;
    case /* Fun */1 :
        var f = symbolToString$3(d._0);
        var xs = Belt_List.map(d._1, symbolToString$3);
        var b = printBlock$3(d._2, /* Return */1);
        d$1 = {
          it: {
            TAG: /* Fun */1,
            _0: f,
            _1: xs,
            _2: b
          },
          ann: deffunToString$3(getPrint(f), Belt_List.map(xs, getPrint), getPrint(b))
        };
        break;
    case /* GFun */2 :
        var f$1 = symbolToString$3(d._0);
        var xs$1 = Belt_List.map(d._1, symbolToString$3);
        var b$1 = printBlock$3(d._2, /* Return */1);
        d$1 = {
          it: {
            TAG: /* GFun */2,
            _0: f$1,
            _1: xs$1,
            _2: b$1
          },
          ann: defgenToString$3(getPrint(f$1), Belt_List.map(xs$1, getPrint), getPrint(b$1))
        };
        break;
    
  }
  return {
          it: d$1.it,
          ann: {
            sourceLocation: param.ann,
            print: d$1.ann.it
          }
        };
}

function xeToString$2(param) {
  var xe = param.it;
  var x = symbolToString$3(xe[0]);
  var e = printExp$3(xe[1], {
        TAG: /* Expr */0,
        _0: false
      });
  var print = defvarToString$2(getPrint(x), getPrint(e)).it;
  return {
          it: [
            x,
            e
          ],
          ann: {
            sourceLocation: param.ann,
            print: print
          }
        };
}

function obToString$2(ob, ctx) {
  return Belt_Option.map(ob, (function (b) {
                return printBlock$3(b, ctx);
              }));
}

function printBlock$3(param, context) {
  var sourceLocation = param.ann;
  var b = param.it;
  if (b.TAG === /* BRet */0) {
    return mapAnn((function (e) {
                  return {
                          TAG: /* BRet */0,
                          _0: e
                        };
                }), printExp$3({
                    it: b._0,
                    ann: sourceLocation
                  }, {
                    TAG: /* Stat */1,
                    _0: context
                  }));
  }
  var t = printTerm$3(b._0, /* Step */0);
  var b$1 = printBlock$3(b._1, context);
  var print = {
    TAG: /* Group */1,
    _0: {
      hd: getPrint(t),
      tl: {
        hd: {
          it: {
            TAG: /* Plain */0,
            _0: "\n"
          },
          ann: undefined
        },
        tl: {
          hd: getPrint(b$1),
          tl: /* [] */0
        }
      }
    }
  };
  return {
          it: {
            TAG: /* BCons */1,
            _0: t,
            _1: b$1
          },
          ann: {
            sourceLocation: sourceLocation,
            print: print
          }
        };
}

function printTerm$3(param, ctx) {
  var sourceLocation = param.ann;
  var t = param.it;
  if (t.TAG === /* Def */0) {
    return mapAnn((function (v) {
                  return {
                          TAG: /* Def */0,
                          _0: v
                        };
                }), defToString$2({
                    it: t._0,
                    ann: sourceLocation
                  }));
  } else {
    return mapAnn((function (v) {
                  return {
                          TAG: /* Exp */1,
                          _0: v
                        };
                }), printExp$3({
                    it: t._0,
                    ann: sourceLocation
                  }, {
                    TAG: /* Stat */1,
                    _0: ctx
                  }));
  }
}

function printOutputlet$3(o) {
  var p = function (v) {
    switch (v.TAG | 0) {
      case /* Ref */0 :
          return "#" + String(v._0) + "#";
      case /* Con */1 :
          return constantToString$3(v._0);
      case /* Struct */2 :
          var content = v._1;
          var i = v._0;
          var i$1 = i !== undefined ? "#" + String(i) + "=" : "";
          var content$1;
          content$1 = content.TAG === /* Lst */0 ? "list[" + $$String.concat(", ", Belt_List.map(content._0, p)) + "]" : "vec[" + $$String.concat(", ", Belt_List.map(content._0, p)) + "]";
          return "" + i$1 + "" + content$1 + "";
      
    }
  };
  if (o) {
    return p(o._0);
  } else {
    return "error";
  }
}

function printOutput$3(sepOpt, os) {
  var sep = sepOpt !== undefined ? sepOpt : " ";
  return $$String.concat(sep, Belt_List.map(os, printOutputlet$3));
}

function printProgramFull$3(insertPrintTopLevel, p) {
  printingTopLevel$2.contents = insertPrintTopLevel;
  var print = function (param) {
    var sourceLocation = param.ann;
    var it = param.it;
    if (!it) {
      return {
              it: /* PNil */0,
              ann: {
                sourceLocation: sourceLocation,
                print: {
                  TAG: /* Group */1,
                  _0: /* [] */0
                }
              }
            };
    }
    var p = it._1;
    var t = printTerm$3(it._0, /* TopLevel */2);
    if (!p.it) {
      return {
              it: /* PCons */{
                _0: t,
                _1: {
                  it: /* PNil */0,
                  ann: {
                    sourceLocation: {
                      begin: sourceLocation.end,
                      end: sourceLocation.end
                    },
                    print: {
                      TAG: /* Plain */0,
                      _0: ""
                    }
                  }
                }
              },
              ann: {
                sourceLocation: sourceLocation,
                print: getPrint(t).it
              }
            };
    }
    var p$1 = print(p);
    return {
            it: /* PCons */{
              _0: t,
              _1: p$1
            },
            ann: {
              sourceLocation: sourceLocation,
              print: concat2(getPrint(t), "\n", getPrint(p$1))
            }
          };
  };
  return print(p);
}

function printProgram$3(insertPrintTopLevel, p) {
  return toString(printProgramFull$3(insertPrintTopLevel, p).ann.print);
}

function printStandAloneTerm$3(param) {
  var ann = param.ann;
  var it = param.it;
  var tmp;
  tmp = it.TAG === /* Def */0 ? defToString$2({
          it: it._0,
          ann: ann
        }).ann.print : printExp$3({
          it: it._0,
          ann: ann
        }, {
          TAG: /* Stat */1,
          _0: /* Step */0
        }).ann.print;
  return toString(tmp);
}

var PCPrinter = {
  printName: printName$3,
  printOutputlet: printOutputlet$3,
  printOutput: printOutput$3,
  printStandAloneTerm: printStandAloneTerm$3,
  printProgram: printProgram$3,
  printProgramFull: printProgramFull$3
};

function printName$4(x) {
  var re = /-./g;
  var matchFn = function (matchPart, _offset, _wholeString) {
    return matchPart.substring(1).toUpperCase();
  };
  var x$1 = x.replace(re, matchFn);
  if (x$1 === "var") {
    return "$var";
  } else {
    return x$1;
  }
}

function constantToString$4(c) {
  if (typeof c === "number") {
    if (c === /* Uni */0) {
      return "null";
    }
    throw {
          RE_EXN_ID: SMoLPrintError,
          _1: "Lists are not supported in Scala.",
          Error: new Error()
        };
  } else {
    switch (c.TAG | 0) {
      case /* Num */0 :
          return String(c._0);
      case /* Lgc */1 :
          if (c._0) {
            return "true";
          } else {
            return "false";
          }
      case /* Str */2 :
          return "\"" + $$String.escaped(c._0) + "\"";
      case /* Sym */3 :
          return c._0;
      
    }
  }
}

function listToString$4(es) {
  if (Belt_List.some(es, (function (e) {
            return containsNL(e.it);
          }))) {
    return {
            TAG: /* Group */1,
            _0: {
              hd: {
                it: {
                  TAG: /* Plain */0,
                  _0: "("
                },
                ann: undefined
              },
              tl: {
                hd: indentBlock({
                      it: concat(",\n", es),
                      ann: undefined
                    }, 2),
                tl: {
                  hd: {
                    it: {
                      TAG: /* Plain */0,
                      _0: ")"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          };
  } else {
    return {
            TAG: /* Group */1,
            _0: {
              hd: {
                it: {
                  TAG: /* Plain */0,
                  _0: "("
                },
                ann: undefined
              },
              tl: {
                hd: {
                  it: concat(", ", es),
                  ann: undefined
                },
                tl: {
                  hd: {
                    it: {
                      TAG: /* Plain */0,
                      _0: ")"
                    },
                    ann: undefined
                  },
                  tl: /* [] */0
                }
              }
            }
          };
  }
}

function defvarLike$4(op, x, e) {
  var ss_0 = {
    it: {
      TAG: /* Plain */0,
      _0: op
    },
    ann: undefined
  };
  var ss_1 = {
    hd: x,
    tl: {
      hd: {
        it: {
          TAG: /* Plain */0,
          _0: " = "
        },
        ann: undefined
      },
      tl: {
        hd: indent(e, 2),
        tl: /* [] */0
      }
    }
  };
  var ss = {
    hd: ss_0,
    tl: ss_1
  };
  return {
          it: {
            TAG: /* Group */1,
            _0: ss
          },
          ann: undefined
        };
}

function exprAppToString$3(e, es) {
  return group2(e, es === /* [] */0 ? ({
                  it: {
                    TAG: /* Plain */0,
                    _0: ""
                  },
                  ann: undefined
                }) : ({
                  it: listToString$4(es),
                  ann: undefined
                }));
}

var printingTopLevel$3 = {
  contents: false
};

var containsVarMutation = {
  contents: false
};

var containsVecMutation = {
  contents: false
};

function consumeContext$3(e, context) {
  if (context.TAG === /* Expr */0) {
    return surround("", e, "");
  }
  switch (context._0) {
    case /* Step */0 :
    case /* Return */1 :
        return surround("", e, "");
    case /* TopLevel */2 :
        return surround("println(", e, ")");
    
  }
}

function consumeContextWrap$3(e, context) {
  if (context.TAG === /* Expr */0 && context._0) {
    return surround("(", e, ")");
  } else {
    return consumeContext$3(e, context);
  }
}

function consumeContextVoid$3(e, context) {
  if (context.TAG === /* Expr */0) {
    return consumeContext$3(e, context);
  }
  switch (context._0) {
    case /* Step */0 :
        return consumeContext$3(e, context);
    case /* Return */1 :
    case /* TopLevel */2 :
        return surround("", e, "");
    
  }
}

function exprAppPrmToString$3(p, es, context) {
  if (typeof p === "number") {
    switch (p) {
      case /* PairNew */0 :
          if (es) {
            var match = es.tl;
            if (match && !match.tl) {
              var e1 = Curry._1(es.hd, false);
              var e2 = Curry._1(match.hd, false);
              var vecKeyword = containsVecMutation.contents || containsVarMutation.contents ? "Buffer" : "";
              return {
                      it: [
                        /* PairNew */0,
                        {
                          hd: e1,
                          tl: {
                            hd: e2,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContext$3(op2("" + vecKeyword + "(", getPrint(e1), ", ", getPrint(e2), ")"), context)
                    };
            }
            
          }
          break;
      case /* PairRefLeft */1 :
          if (es && !es.tl) {
            var e1$1 = Curry._1(es.hd, true);
            return {
                    it: [
                      /* PairRefLeft */1,
                      {
                        hd: e1$1,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$3(op1("", getPrint(e1$1), "(0)"), context)
                  };
          }
          break;
      case /* PairRefRight */2 :
          if (es && !es.tl) {
            var e1$2 = Curry._1(es.hd, true);
            return {
                    it: [
                      /* PairRefRight */2,
                      {
                        hd: e1$2,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$3(op1("", getPrint(e1$2), "(1)"), context)
                  };
          }
          break;
      case /* PairSetLeft */3 :
          if (es) {
            var match$1 = es.tl;
            if (match$1 && !match$1.tl) {
              var e1$3 = Curry._1(es.hd, false);
              var e2$1 = Curry._1(match$1.hd, false);
              return {
                      it: [
                        /* PairSetLeft */3,
                        {
                          hd: e1$3,
                          tl: {
                            hd: e2$1,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContextVoid$3(op2("", getPrint(e1$3), "(0) = ", getPrint(e2$1), ""), context)
                    };
            }
            
          }
          break;
      case /* PairSetRight */4 :
          if (es) {
            var match$2 = es.tl;
            if (match$2 && !match$2.tl) {
              var e1$4 = Curry._1(es.hd, false);
              var e2$2 = Curry._1(match$2.hd, false);
              return {
                      it: [
                        /* PairSetRight */4,
                        {
                          hd: e1$4,
                          tl: {
                            hd: e2$2,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContextVoid$3(op2("", getPrint(e1$4), "(1) = ", getPrint(e2$2), ""), context)
                    };
            }
            
          }
          break;
      case /* VecNew */5 :
          var es$1 = Belt_List.map(es, (function (e) {
                  return Curry._1(e, false);
                }));
          var vecKeyword$1 = containsVecMutation.contents || containsVarMutation.contents ? "Buffer" : "";
          return {
                  it: [
                    /* VecNew */5,
                    es$1
                  ],
                  ann: consumeContext$3(op1("" + vecKeyword$1 + "(", {
                            it: concat(", ", Belt_List.map(es$1, getPrint)),
                            ann: undefined
                          }, ")"), context)
                };
      case /* VecRef */6 :
          if (es) {
            var match$3 = es.tl;
            if (match$3 && !match$3.tl) {
              var e1$5 = Curry._1(es.hd, true);
              var e2$3 = Curry._1(match$3.hd, false);
              return {
                      it: [
                        /* VecRef */6,
                        {
                          hd: e1$5,
                          tl: {
                            hd: e2$3,
                            tl: /* [] */0
                          }
                        }
                      ],
                      ann: consumeContext$3(op2("", getPrint(e1$5), "(", getPrint(e2$3), ")"), context)
                    };
            }
            
          }
          break;
      case /* VecSet */7 :
          if (es) {
            var match$4 = es.tl;
            if (match$4) {
              var match$5 = match$4.tl;
              if (match$5 && !match$5.tl) {
                var e1$6 = Curry._1(es.hd, true);
                var e2$4 = Curry._1(match$4.hd, false);
                var e3 = Curry._1(match$5.hd, false);
                return {
                        it: [
                          /* VecSet */7,
                          {
                            hd: e1$6,
                            tl: {
                              hd: e2$4,
                              tl: {
                                hd: e3,
                                tl: /* [] */0
                              }
                            }
                          }
                        ],
                        ann: consumeContextVoid$3(op3("", getPrint(e1$6), "(", getPrint(e2$4), ") = ", getPrint(e3), ""), context)
                      };
              }
              
            }
            
          }
          break;
      case /* VecLen */8 :
          if (es && !es.tl) {
            var e1$7 = Curry._1(es.hd, false);
            return {
                    it: [
                      /* VecLen */8,
                      {
                        hd: e1$7,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContext$3(op1("", getPrint(e1$7), ".length"), context)
                  };
          }
          break;
      case /* Err */9 :
          if (es && !es.tl) {
            var e1$8 = Curry._1(es.hd, true);
            return {
                    it: [
                      /* Err */9,
                      {
                        hd: e1$8,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextWrap$3(op1("throw ", getPrint(e1$8), ""), context)
                  };
          }
          break;
      case /* Not */10 :
          if (es && !es.tl) {
            var e1$9 = Curry._1(es.hd, true);
            return {
                    it: [
                      /* Not */10,
                      {
                        hd: e1$9,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextWrap$3(op1("Â¬ ", getPrint(e1$9), ""), context)
                  };
          }
          break;
      case /* Print */11 :
          if (es && !es.tl) {
            var e1$10 = Curry._1(es.hd, false);
            return {
                    it: [
                      /* Print */11,
                      {
                        hd: e1$10,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextVoid$3(op1("println(", getPrint(e1$10), ")"), context)
                  };
          }
          break;
      case /* Next */12 :
          if (es && !es.tl) {
            var e1$11 = Curry._1(es.hd, false);
            return {
                    it: [
                      /* Next */12,
                      {
                        hd: e1$11,
                        tl: /* [] */0
                      }
                    ],
                    ann: consumeContextVoid$3(op1("next(", getPrint(e1$11), ")"), context)
                  };
          }
          break;
      case /* Cons */13 :
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "List is not supported by JavaScript",
                Error: new Error()
              };
      
    }
  } else {
    if (p.TAG === /* Arith */0) {
      var o = p._0;
      var os;
      switch (o) {
        case /* Add */0 :
            os = "+";
            break;
        case /* Sub */1 :
            os = "-";
            break;
        case /* Mul */2 :
            os = "*";
            break;
        case /* Div */3 :
            os = "/";
            break;
        
      }
      var es$2 = Belt_List.map(es, (function (e) {
              return Curry._1(e, true);
            }));
      return {
              it: [
                {
                  TAG: /* Arith */0,
                  _0: o
                },
                es$2
              ],
              ann: consumeContextWrap$3({
                    it: concat(" " + os + " ", Belt_List.map(es$2, getPrint)),
                    ann: undefined
                  }, context)
            };
    }
    if (es) {
      var match$6 = es.tl;
      if (match$6 && !match$6.tl) {
        var o$1 = p._0;
        var os$1;
        switch (o$1) {
          case /* Lt */0 :
              os$1 = "<";
              break;
          case /* Eq */1 :
              os$1 = "==";
              break;
          case /* Gt */2 :
              os$1 = ">";
              break;
          case /* Le */3 :
              os$1 = "<=";
              break;
          case /* Ge */4 :
              os$1 = ">=";
              break;
          case /* Ne */5 :
              os$1 = "!=";
              break;
          
        }
        var e1$12 = Curry._1(es.hd, true);
        var e2$5 = Curry._1(match$6.hd, true);
        return {
                it: [
                  {
                    TAG: /* Cmp */1,
                    _0: o$1
                  },
                  {
                    hd: e1$12,
                    tl: {
                      hd: e2$5,
                      tl: /* [] */0
                    }
                  }
                ],
                ann: consumeContext$3(op2("", getPrint(e1$12), " " + os$1 + " ", getPrint(e2$5), ""), context)
              };
      }
      
    }
    
  }
  var err = "Our pseudo-code syntax doesn't let you use " + toString$1(p) + " on " + String(Belt_List.length(es)) + " parameter(s).";
  throw {
        RE_EXN_ID: SMoLPrintError,
        _1: err,
        Error: new Error()
      };
}

function funLike$3(op, x, xs, e) {
  return op2("" + op + " ", exprAppToString$3(x, xs), " =", indentBlock(e, 2), "");
}

function defvarToString$3(x, e) {
  var keyword = containsVarMutation.contents ? "var" : "val";
  return op1("", defvarLike$4("" + keyword + " ", x, e), "");
}

function deffunToString$4(f, xs, b) {
  return funLike$3("def", f, Belt_List.map(xs, (function (x) {
                    return group2(x, {
                                it: {
                                  TAG: /* Plain */0,
                                  _0: " : Int"
                                },
                                ann: undefined
                              });
                  })), b);
}

function defgenToString$4(f, xs, b) {
  return funLike$3("gen def", f, Belt_List.map(xs, (function (x) {
                    return group2(x, {
                                it: {
                                  TAG: /* Plain */0,
                                  _0: " : Int"
                                },
                                ann: undefined
                              });
                  })), b);
}

function exprSetToString$1(x, e) {
  return op2("", x, " = ", e, "");
}

function exprLamToString$4(xs, b) {
  return op2("(", {
              it: concat(", ", Belt_List.map(xs, (function (x) {
                          return group2(x, {
                                      it: {
                                        TAG: /* Plain */0,
                                        _0: " : Int"
                                      },
                                      ann: undefined
                                    });
                        }))),
              ann: undefined
            }, ") =>", indentBlock(b, 2), "");
}

function exprBgnToString$4(es, e) {
  return {
          it: listToString$4(Belt_List.concatMany([
                    es,
                    {
                      hd: e,
                      tl: /* [] */0
                    }
                  ])),
          ann: undefined
        };
}

function exprCndToString$4(ebs, ob) {
  var ebs$1 = ob !== undefined ? Belt_List.concatMany([
          ebs,
          {
            hd: [
              {
                it: {
                  TAG: /* Plain */0,
                  _0: ""
                },
                ann: undefined
              },
              ob
            ],
            tl: /* [] */0
          }
        ]) : ebs;
  var ebs$2 = Belt_List.map(ebs$1, (function (param) {
          return op2("if ", param[0], ":", indentBlock(param[1], 2), "\nend");
        }));
  return concat(" else ", ebs$2);
}

function exprIfToString$4(e_cnd, e_thn, e_els) {
  return op3("if ", e_cnd, " then ", e_thn, " else ", e_els, "");
}

function symbolToString$4(param) {
  var it = param.it;
  return {
          it: it,
          ann: {
            sourceLocation: param.ann,
            print: {
              TAG: /* Plain */0,
              _0: printName$4(it)
            }
          }
        };
}

function printExp$4(param, context) {
  var it = param.it;
  var e;
  switch (it.TAG | 0) {
    case /* Con */0 :
        var c = it._0;
        var it$1 = constantToString$4(c);
        e = {
          it: {
            TAG: /* Con */0,
            _0: c
          },
          ann: consumeContext$3({
                it: {
                  TAG: /* Plain */0,
                  _0: it$1
                },
                ann: undefined
              }, context)
        };
        break;
    case /* Ref */1 :
        var x = it._0;
        var it$2 = printName$4(x);
        e = {
          it: {
            TAG: /* Ref */1,
            _0: x
          },
          ann: consumeContext$3({
                it: {
                  TAG: /* Plain */0,
                  _0: it$2
                },
                ann: undefined
              }, context)
        };
        break;
    case /* Set */2 :
        var x$1 = symbolToString$4(it._0);
        var e$1 = printExp$4(it._1, {
              TAG: /* Expr */0,
              _0: false
            });
        e = {
          it: {
            TAG: /* Set */2,
            _0: x$1,
            _1: e$1
          },
          ann: consumeContextVoid$3(exprSetToString$1(getPrint(x$1), getPrint(e$1)), context)
        };
        break;
    case /* Lam */3 :
        var xs = Belt_List.map(it._0, symbolToString$4);
        var b = printBlock$4(it._1, /* Return */1);
        e = {
          it: {
            TAG: /* Lam */3,
            _0: xs,
            _1: b
          },
          ann: consumeContextWrap$3(exprLamToString$4(Belt_List.map(xs, getPrint), getPrint(b)), context)
        };
        break;
    case /* Let */4 :
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "let-expressions are not supported by our pseudo-code syntax",
              Error: new Error()
            };
    case /* Letrec */5 :
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "letrec-expressions are not supported by our pseudo-code syntax",
              Error: new Error()
            };
    case /* AppPrm */6 :
        var es = Belt_List.map(it._1, (function (e, b) {
                return printExp$4(e, {
                            TAG: /* Expr */0,
                            _0: b
                          });
              }));
        var match = exprAppPrmToString$3(it._0, es, context);
        var match$1 = match.it;
        e = {
          it: {
            TAG: /* AppPrm */6,
            _0: match$1[0],
            _1: match$1[1]
          },
          ann: match.ann
        };
        break;
    case /* App */7 :
        var e$2 = printExp$4(it._0, {
              TAG: /* Expr */0,
              _0: true
            });
        var es$1 = Belt_List.map(it._1, (function (e) {
                return printExp$4(e, {
                            TAG: /* Expr */0,
                            _0: false
                          });
              }));
        e = {
          it: {
            TAG: /* App */7,
            _0: e$2,
            _1: es$1
          },
          ann: consumeContext$3(exprAppToString$3(getPrint(e$2), Belt_List.map(es$1, getPrint)), context)
        };
        break;
    case /* Bgn */8 :
        var es$2 = Belt_List.map(it._0, (function (e) {
                return printExp$4(e, {
                            TAG: /* Expr */0,
                            _0: false
                          });
              }));
        var e$3 = printExp$4(it._1, {
              TAG: /* Expr */0,
              _0: false
            });
        e = {
          it: {
            TAG: /* Bgn */8,
            _0: es$2,
            _1: e$3
          },
          ann: consumeContext$3(exprBgnToString$4(Belt_List.map(es$2, getPrint), getPrint(e$3)), context)
        };
        break;
    case /* If */9 :
        var e_cnd = printExp$4(it._0, {
              TAG: /* Expr */0,
              _0: true
            });
        var e_thn = printExp$4(it._1, {
              TAG: /* Expr */0,
              _0: true
            });
        var e_els = printExp$4(it._2, {
              TAG: /* Expr */0,
              _0: true
            });
        e = {
          it: {
            TAG: /* If */9,
            _0: e_cnd,
            _1: e_thn,
            _2: e_els
          },
          ann: consumeContextWrap$3(exprIfToString$4(getPrint(e_cnd), getPrint(e_thn), getPrint(e_els)), context)
        };
        break;
    case /* Cnd */10 :
        if (context.TAG === /* Expr */0) {
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "Multi-armed conditionals in our pseudo-code syntax is not supported by the translator yet.",
                Error: new Error()
              };
        }
        var context$1 = context._0;
        var ebs = Belt_List.map(it._0, (function (eb) {
                return [
                        printExp$4(eb[0], {
                              TAG: /* Expr */0,
                              _0: false
                            }),
                        printBlock$4(eb[1], context$1)
                      ];
              }));
        var ob = obToString$3(it._1, context$1);
        e = {
          it: {
            TAG: /* Cnd */10,
            _0: ebs,
            _1: ob
          },
          ann: exprCndToString$4(Belt_List.map(ebs, (function (param) {
                      return [
                              getPrint(param[0]),
                              getPrint(param[1])
                            ];
                    })), Belt_Option.map(ob, getPrint))
        };
        break;
    case /* GLam */11 :
        var xs$1 = Belt_List.map(it._0, symbolToString$4);
        var b$1 = printBlock$4(it._1, /* Return */1);
        Belt_List.map(xs$1, getPrint);
        getPrint(b$1);
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "generators are not supported yet in Scala translation.",
              Error: new Error()
            };
        e = {
          it: {
            TAG: /* Lam */3,
            _0: xs$1,
            _1: b$1
          },
          ann: consumeContextWrap$3(undefined, context)
        };
        break;
    case /* Yield */12 :
        var e$4 = printExp$4(it._0, {
              TAG: /* Expr */0,
              _0: false
            });
        e = {
          it: {
            TAG: /* Yield */12,
            _0: e$4
          },
          ann: consumeContextWrap$3(op1("yield ", getPrint(e$4), ""), context)
        };
        break;
    
  }
  return {
          it: e.it,
          ann: {
            sourceLocation: param.ann,
            print: e.ann
          }
        };
}

function defToString$3(param) {
  var d = param.it;
  var d$1;
  switch (d.TAG | 0) {
    case /* Var */0 :
        var x = symbolToString$4(d._0);
        var e = printExp$4(d._1, {
              TAG: /* Expr */0,
              _0: false
            });
        d$1 = {
          it: {
            TAG: /* Var */0,
            _0: x,
            _1: e
          },
          ann: defvarToString$3(getPrint(x), getPrint(e))
        };
        break;
    case /* Fun */1 :
        var f = symbolToString$4(d._0);
        var xs = Belt_List.map(d._1, symbolToString$4);
        var b = printBlock$4(d._2, /* Return */1);
        d$1 = {
          it: {
            TAG: /* Fun */1,
            _0: f,
            _1: xs,
            _2: b
          },
          ann: deffunToString$4(getPrint(f), Belt_List.map(xs, getPrint), getPrint(b))
        };
        break;
    case /* GFun */2 :
        var f$1 = symbolToString$4(d._0);
        var xs$1 = Belt_List.map(d._1, symbolToString$4);
        var b$1 = printBlock$4(d._2, /* Return */1);
        d$1 = {
          it: {
            TAG: /* GFun */2,
            _0: f$1,
            _1: xs$1,
            _2: b$1
          },
          ann: defgenToString$4(getPrint(f$1), Belt_List.map(xs$1, getPrint), getPrint(b$1))
        };
        break;
    
  }
  return {
          it: d$1.it,
          ann: {
            sourceLocation: param.ann,
            print: d$1.ann.it
          }
        };
}

function obToString$3(ob, ctx) {
  return Belt_Option.map(ob, (function (b) {
                return printBlock$4(b, ctx);
              }));
}

function printBlock$4(param, context) {
  var sourceLocation = param.ann;
  var b = param.it;
  if (b.TAG === /* BRet */0) {
    return mapAnn((function (e) {
                  return {
                          TAG: /* BRet */0,
                          _0: e
                        };
                }), printExp$4({
                    it: b._0,
                    ann: sourceLocation
                  }, {
                    TAG: /* Stat */1,
                    _0: context
                  }));
  }
  var t = printTerm$4(b._0, /* Step */0);
  var b$1 = printBlock$4(b._1, context);
  var print = {
    TAG: /* Group */1,
    _0: {
      hd: getPrint(t),
      tl: {
        hd: {
          it: {
            TAG: /* Plain */0,
            _0: "\n"
          },
          ann: undefined
        },
        tl: {
          hd: getPrint(b$1),
          tl: /* [] */0
        }
      }
    }
  };
  return {
          it: {
            TAG: /* BCons */1,
            _0: t,
            _1: b$1
          },
          ann: {
            sourceLocation: sourceLocation,
            print: print
          }
        };
}

function printTerm$4(param, ctx) {
  var sourceLocation = param.ann;
  var t = param.it;
  if (t.TAG === /* Def */0) {
    return mapAnn((function (v) {
                  return {
                          TAG: /* Def */0,
                          _0: v
                        };
                }), defToString$3({
                    it: t._0,
                    ann: sourceLocation
                  }));
  } else {
    return mapAnn((function (v) {
                  return {
                          TAG: /* Exp */1,
                          _0: v
                        };
                }), printExp$4({
                    it: t._0,
                    ann: sourceLocation
                  }, {
                    TAG: /* Stat */1,
                    _0: ctx
                  }));
  }
}

function printOutputlet$4(o) {
  var p = function (v) {
    switch (v.TAG | 0) {
      case /* Ref */0 :
          throw {
                RE_EXN_ID: SMoLPrintError,
                _1: "Can't print circular data structure in Scala",
                Error: new Error()
              };
      case /* Con */1 :
          return constantToString$4(v._0);
      case /* Struct */2 :
          var content = v._1;
          var i;
          if (v._0 !== undefined) {
            throw {
                  RE_EXN_ID: SMoLPrintError,
                  _1: "Can't print circular data structure in Scala",
                  Error: new Error()
                };
          }
          i = "";
          var content$1;
          if (content.TAG === /* Lst */0) {
            throw {
                  RE_EXN_ID: SMoLPrintError,
                  _1: "Lists are not supported in Scala.",
                  Error: new Error()
                };
          }
          content$1 = "Buffer(" + $$String.concat(", ", Belt_List.map(content._0, p)) + ")";
          return "" + i + "" + content$1 + "";
      
    }
  };
  if (o) {
    return p(o._0);
  } else {
    return "error";
  }
}

function printOutput$4(sepOpt, os) {
  var sep = sepOpt !== undefined ? sepOpt : " ";
  return $$String.concat(sep, Belt_List.map(os, printOutputlet$4));
}

function printProgramFull$4(insertPrintTopLevel, p) {
  printingTopLevel$3.contents = insertPrintTopLevel;
  var s = printProgram(insertPrintTopLevel, p);
  containsVarMutation.contents = Js_string.includes("(set!", s);
  containsVecMutation.contents = Js_string.includes("vec-set!", s) || Js_string.includes("set-left!", s) || Js_string.includes("set-right!", s);
  var print = function (param) {
    var sourceLocation = param.ann;
    var it = param.it;
    if (!it) {
      return {
              it: /* PNil */0,
              ann: {
                sourceLocation: sourceLocation,
                print: {
                  TAG: /* Group */1,
                  _0: /* [] */0
                }
              }
            };
    }
    var p = it._1;
    var t = printTerm$4(it._0, /* TopLevel */2);
    if (!p.it) {
      return {
              it: /* PCons */{
                _0: t,
                _1: {
                  it: /* PNil */0,
                  ann: {
                    sourceLocation: {
                      begin: sourceLocation.end,
                      end: sourceLocation.end
                    },
                    print: {
                      TAG: /* Plain */0,
                      _0: ""
                    }
                  }
                }
              },
              ann: {
                sourceLocation: sourceLocation,
                print: getPrint(t).it
              }
            };
    }
    var p$1 = print(p);
    return {
            it: /* PCons */{
              _0: t,
              _1: p$1
            },
            ann: {
              sourceLocation: sourceLocation,
              print: concat2(getPrint(t), "\n", getPrint(p$1))
            }
          };
  };
  return print(p);
}

function printProgram$4(insertPrintTopLevel, p) {
  return toString(printProgramFull$4(insertPrintTopLevel, p).ann.print);
}

function printStandAloneTerm$4(param) {
  var ann = param.ann;
  var it = param.it;
  var tmp;
  tmp = it.TAG === /* Def */0 ? defToString$3({
          it: it._0,
          ann: ann
        }).ann.print : printExp$4({
          it: it._0,
          ann: ann
        }, {
          TAG: /* Stat */1,
          _0: /* Step */0
        }).ann.print;
  return toString(tmp);
}

var SCPrinter = {
  printName: printName$4,
  printOutputlet: printOutputlet$4,
  printOutput: printOutput$4,
  printStandAloneTerm: printStandAloneTerm$4,
  printProgram: printProgram$4,
  printProgramFull: printProgramFull$4
};

function toString$6(t) {
  switch (t.TAG | 0) {
    case /* ParseError */0 :
        return toString$5(t._0);
    case /* PrintError */1 :
    case /* KindError */2 :
        return t._0;
    
  }
}

var TranslateError = {
  toString: toString$6
};

var SMoLTranslateError = /* @__PURE__ */Caml_exceptions.create("SMoL.SMoLTranslateError");

function programAsTerm(p) {
  var match = p.it;
  if (match) {
    if (match._1.it) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* KindError */2,
              _0: "Expecting a term, given a program"
            },
            Error: new Error()
          };
    }
    return match._0;
  }
  throw {
        RE_EXN_ID: SMoLTranslateError,
        _1: {
          TAG: /* KindError */2,
          _0: "Expecting a term, given a program"
        },
        Error: new Error()
      };
}

function translateOutput(src) {
  var output;
  try {
    output = parseOutput(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printOutput(undefined, output);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateStandAloneTerm(src) {
  var p;
  try {
    p = makeProgram(parseTerms(src));
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printStandAloneTerm(programAsTerm(p));
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgram(printTopLevel, src) {
  var p;
  try {
    p = makeProgram(parseTerms(src));
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgram(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgramFull(printTopLevel, src) {
  var p;
  try {
    p = makeProgram(parseTerms(src));
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgramFull(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

var SMoLTranslator = {
  translateName: printName,
  translateOutput: translateOutput,
  translateStandAloneTerm: translateStandAloneTerm,
  translateProgram: translateProgram,
  translateProgramFull: translateProgramFull
};

function translateOutput$1(src) {
  var output;
  try {
    output = parseOutput(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printOutput$1(undefined, output);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateStandAloneTerm$1(src) {
  var p;
  try {
    p = makeProgram(parseTerms(src));
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printStandAloneTerm$1(programAsTerm(p));
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgram$1(printTopLevel, src) {
  var p;
  try {
    p = makeProgram(parseTerms(src));
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgram$1(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgramFull$1(printTopLevel, src) {
  var p;
  try {
    p = makeProgram(parseTerms(src));
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgramFull$1(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

var JSTranslator = {
  translateName: printName$1,
  translateOutput: translateOutput$1,
  translateStandAloneTerm: translateStandAloneTerm$1,
  translateProgram: translateProgram$1,
  translateProgramFull: translateProgramFull$1
};

function translateOutput$2(src) {
  var output;
  try {
    output = parseOutput(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printOutput$2(undefined, output);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateStandAloneTerm$2(src) {
  var p;
  try {
    p = makeProgram(parseTerms(src));
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printStandAloneTerm$2(programAsTerm(p));
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgram$2(printTopLevel, src) {
  var p;
  try {
    p = makeProgram(parseTerms(src));
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgram$2(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgramFull$2(printTopLevel, src) {
  var p;
  try {
    p = makeProgram(parseTerms(src));
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgramFull$2(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

var PYTranslator = {
  translateName: printName$2,
  translateOutput: translateOutput$2,
  translateStandAloneTerm: translateStandAloneTerm$2,
  translateProgram: translateProgram$2,
  translateProgramFull: translateProgramFull$2
};

function translateOutput$3(src) {
  var output;
  try {
    output = parseOutput(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printOutput$3(undefined, output);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateStandAloneTerm$3(src) {
  var p;
  try {
    p = makeProgram(parseTerms(src));
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printStandAloneTerm$3(programAsTerm(p));
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgram$3(printTopLevel, src) {
  var p;
  try {
    p = makeProgram(parseTerms(src));
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgram$3(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgramFull$3(printTopLevel, src) {
  var p;
  try {
    p = makeProgram(parseTerms(src));
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgramFull$3(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

var PCTranslator = {
  translateName: printName$3,
  translateOutput: translateOutput$3,
  translateStandAloneTerm: translateStandAloneTerm$3,
  translateProgram: translateProgram$3,
  translateProgramFull: translateProgramFull$3
};

function translateOutput$4(src) {
  var output;
  try {
    output = parseOutput(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printOutput$4(undefined, output);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateStandAloneTerm$4(src) {
  var p;
  try {
    p = makeProgram(parseTerms(src));
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printStandAloneTerm$4(programAsTerm(p));
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgram$4(printTopLevel, src) {
  var p;
  try {
    p = makeProgram(parseTerms(src));
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgram$4(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgramFull$4(printTopLevel, src) {
  var p;
  try {
    p = makeProgram(parseTerms(src));
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgramFull$4(printTopLevel, p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

var SCTranslator = {
  translateName: printName$4,
  translateOutput: translateOutput$4,
  translateStandAloneTerm: translateStandAloneTerm$4,
  translateProgram: translateProgram$4,
  translateProgramFull: translateProgramFull$4
};

var Print = {
  toString: toString,
  toSourceMap: toSourceMap,
  map: map,
  concat2: concat2,
  concat: concat,
  pad: pad,
  dummyAnn: dummyAnn
};

var Parser = {
  parseOutput: parseOutput,
  parseProgram: parseProgram
};

var SMoLPrinter = {
  printName: printName,
  printOutputlet: printOutputlet,
  printOutput: printOutput,
  printStandAloneTerm: printStandAloneTerm,
  printProgram: printProgram,
  printProgramFull: printProgramFull
};

export {
  Print ,
  Primitive ,
  xsOfBlock ,
  xsOfProgram ,
  SExprKind ,
  Arity ,
  TermKind ,
  ParseError ,
  SMoLParseError ,
  Parser ,
  SMoLPrintError ,
  getPrint ,
  SMoLPrinter ,
  JSPrinter ,
  PYPrinter ,
  PCPrinter ,
  SCPrinter ,
  TranslateError ,
  SMoLTranslateError ,
  SMoLTranslator ,
  JSTranslator ,
  PYTranslator ,
  PCTranslator ,
  SCTranslator ,
}
/* No side effect */
