// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$String from "rescript/lib/es6/string.js";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_array from "rescript/lib/es6/js_array.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Js_string from "rescript/lib/es6/js_string.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Float from "rescript/lib/es6/belt_Float.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as SExpression from "@lukuangchen/s-expression/src/SExpression.bs.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var all_primitives = [
  /* Add */0,
  /* Sub */1,
  /* Mul */2,
  /* Div */3,
  /* Lt */4,
  /* Eq */5,
  /* Gt */6,
  /* Le */7,
  /* Ge */8,
  /* Ne */9,
  /* PairNew */10,
  /* PairRefRight */11,
  /* PairRefLeft */12,
  /* PairSetRight */13,
  /* PairSetLeft */14,
  /* VecNew */15,
  /* VecRef */16,
  /* VecSet */17,
  /* VecLen */18,
  /* Eqv */19,
  /* Err */20,
  /* Not */21
];

var SMoLPrintError = /* @__PURE__ */Caml_exceptions.create("SMoL.SMoLPrintError");

function unannotate(x) {
  return x.it;
}

function indent(s, i) {
  var pad = Js_string.repeat(i, " ");
  return Js_string.replaceByRe(/\n/g, "\n" + pad, s);
}

function indentBlock(s, i) {
  return indent("\n" + s, i);
}

function hcat(s1, s2) {
  return "" + s1 + "" + indent(s2, s1.length) + "";
}

function primitiveToString(o) {
  switch (o) {
    case /* Add */0 :
        return "+";
    case /* Sub */1 :
        return "-";
    case /* Mul */2 :
        return "*";
    case /* Div */3 :
        return "/";
    case /* Lt */4 :
        return "<";
    case /* Eq */5 :
        return "=";
    case /* Gt */6 :
        return ">";
    case /* Le */7 :
        return "<=";
    case /* Ge */8 :
        return ">=";
    case /* Ne */9 :
        return "!=";
    case /* PairNew */10 :
        return "pair";
    case /* PairRefRight */11 :
        return "right";
    case /* PairRefLeft */12 :
        return "left";
    case /* PairSetRight */13 :
        return "set-right!";
    case /* PairSetLeft */14 :
        return "set-left!";
    case /* VecNew */15 :
        return "vec";
    case /* VecRef */16 :
        return "vec-ref";
    case /* VecSet */17 :
        return "vec-set!";
    case /* VecLen */18 :
        return "vec-len";
    case /* Eqv */19 :
        return "eq?";
    case /* Err */20 :
        return "error";
    case /* Not */21 :
        return "not";
    
  }
}

function listToString(ss) {
  return "(" + $$String.concat(" ", ss) + ")";
}

function defvarLike(op, x, e) {
  if ($$String.contains(e, /* '\n' */10)) {
    return hcat("(" + op + " " + x + " ", "" + e + ")");
  } else {
    return listToString({
                hd: op,
                tl: {
                  hd: x,
                  tl: {
                    hd: e,
                    tl: /* [] */0
                  }
                }
              });
  }
}

function beginLike(op, ts) {
  return "(" + op + "" + indentBlock($$String.concat("\n", ts), 2) + ")";
}

function letLike(op, xes, b) {
  var xes$1 = Belt_List.map(xes, (function (param) {
          var x = param[0].it;
          return hcat("[" + x + " ", "" + param[1] + "]");
        }));
  var xes$2 = $$String.concat("\n", xes$1);
  var xes$3 = "(" + indent(xes$2, 1) + ")";
  return hcat("(" + op + " ", "" + xes$3 + "") + ("" + indentBlock(b, 2) + ")");
}

function expToString(e) {
  switch (e.TAG | 0) {
    case /* Con */0 :
        var c = e._0;
        if (typeof c === "number") {
          return "#<void>";
        }
        switch (c.TAG | 0) {
          case /* Num */0 :
              return String(c._0);
          case /* Lgc */1 :
              if (c._0) {
                return "#t";
              } else {
                return "#f";
              }
          case /* Str */2 :
              return "\"" + $$String.escaped(c._0) + "\"";
          
        }
    case /* Ref */1 :
        return e._0.it;
    case /* Set */2 :
        return defvarLike("set!", e._0.it, expToString(e._1.it));
    case /* Lam */3 :
        var xs = Belt_List.map(e._0, unannotate);
        var b = printBlock(e._1);
        return defvarLike("lambda", listToString(xs), b);
    case /* Let */4 :
        return letLike("let", Belt_List.map(e._0, xeToString), printBlock(e._1));
    case /* Letrec */5 :
        return letLike("letrec", Belt_List.map(e._0, xeToString), printBlock(e._1));
    case /* AppPrm */6 :
        var es = expsToString(e._1);
        var e$1 = primitiveToString(e._0);
        return listToString({
                    hd: e$1,
                    tl: es
                  });
    case /* App */7 :
        var es$1 = expsToString(e._1);
        var e$2 = expToString(e._0.it);
        return listToString({
                    hd: e$2,
                    tl: es$1
                  });
    case /* Bgn */8 :
        var es$2 = expsToString(e._0);
        var e$3 = expToString(e._1.it);
        return beginLike("begin", Belt_List.concatMany([
                        es$2,
                        {
                          hd: e$3,
                          tl: /* [] */0
                        }
                      ]));
    case /* If */9 :
        var e_cnd = expToString(e._0.it);
        var e_thn = expToString(e._1.it);
        var e_els = expToString(e._2.it);
        return "(if " + indent(e_cnd, 4) + "" + indentBlock(e_thn, 4) + "" + indentBlock(e_els, 4) + ")";
    case /* Cnd */10 :
        var ebs = Belt_List.map(e._0, ebToString);
        var ob = Belt_Option.map(e._1, printBlock);
        var ebs$1 = ob !== undefined ? Belt_List.concatMany([
                ebs,
                {
                  hd: [
                    "else",
                    ob
                  ],
                  tl: /* [] */0
                }
              ]) : ebs;
        var ebs$2 = Belt_List.map(ebs$1, (function (param) {
                return "[" + param[0] + "" + indentBlock(param[1], 1) + "]";
              }));
        return beginLike("cond", ebs$2);
    
  }
}

function expsToString(es) {
  return Belt_List.map(Belt_List.map(es, unannotate), expToString);
}

function xeToString(xe) {
  return [
          xe[0],
          expToString(xe[1].it)
        ];
}

function ebToString(eb) {
  return [
          expToString(eb[0].it),
          printBlock(eb[1])
        ];
}

function printBlock(b) {
  return $$String.concat("\n", Belt_List.concatMany([
                  Belt_List.map(b[0], printTerm),
                  {
                    hd: expToString(b[1].it),
                    tl: /* [] */0
                  }
                ]));
}

function printTerm(t) {
  if (t.TAG === /* Def */0) {
    var d = t._0.it;
    if (d.TAG === /* Var */0) {
      return defvarLike("defvar", d._0.it, expToString(d._1.it));
    } else {
      var f = d._0.it;
      var xs = Belt_List.map(d._1, unannotate);
      var b = printBlock(d._2);
      return defvarLike("deffun", listToString({
                      hd: f,
                      tl: xs
                    }), b);
    }
  } else {
    return expToString(t._0.it);
  }
}

function termsToString(ts) {
  return $$String.concat("\n", Belt_List.map(ts, printTerm));
}

function toString(t) {
  if (t) {
    return "list";
  } else {
    return "atom";
  }
}

var SExprKind = {
  toString: toString
};

function toString$1(t) {
  switch (t) {
    case /* ExactlyOne */0 :
        return "exactly one";
    case /* ExactlyTwo */1 :
        return "exactly two";
    case /* ExactlyThree */2 :
        return "exactly three";
    case /* OneThenMany */3 :
        return "one followed by many";
    case /* ManyThenOne */4 :
        return "many followed by one";
    case /* OneThenManyThenOne */5 :
        return "one followed by several followed by one";
    
  }
}

var Arity = {
  toString: toString$1
};

function toString$2(t) {
  if (t) {
    return "expression";
  } else {
    return "definition";
  }
}

var TermKind = {
  toString: toString$2
};

function toString$3(t) {
  switch (t.TAG | 0) {
    case /* SExprParseError */0 :
        return "expecting a (valid) s-expression, but the input is not: " + t._0 + "";
    case /* SExprKindError */1 :
        return "expecting a " + t._1 + ", given " + SExpression.toString(t._2) + "";
    case /* SExprArityError */2 :
        return "expecting " + t._1 + ", given " + $$String.concat(" ", Belt_List.map(t._2, SExpression.toString)) + "";
    case /* LiteralSymbolError */3 :
        return "expecting a literal value, given a symbol " + t._0 + "";
    case /* LiteralListError */4 :
        return "expecting a constant or a vector, given " + SExpression.toString(t._0) + "";
    case /* TermKindError */5 :
        return "expecting " + t._1 + ", given " + printTerm(t._2) + "";
    
  }
}

var ParseError = {
  toString: toString$3
};

var SMoLParseError = /* @__PURE__ */Caml_exceptions.create("SMoL.SMoLParseError");

function constant_of_atom(_ann, atom) {
  if (atom.TAG === /* Str */0) {
    return {
            TAG: /* Con */0,
            _0: {
              TAG: /* Str */2,
              _0: atom._0
            }
          };
  }
  var x = atom._0;
  switch (x) {
    case "#f" :
        return {
                TAG: /* Con */0,
                _0: {
                  TAG: /* Lgc */1,
                  _0: false
                }
              };
    case "#t" :
        return {
                TAG: /* Con */0,
                _0: {
                  TAG: /* Lgc */1,
                  _0: true
                }
              };
    default:
      var tryNum = Belt_Option.map(Belt_Float.fromString(x), (function (n) {
              return {
                      TAG: /* Con */0,
                      _0: {
                        TAG: /* Num */0,
                        _0: n
                      }
                    };
            }));
      if (tryNum !== undefined) {
        return tryNum;
      }
      throw {
            RE_EXN_ID: SMoLParseError,
            _1: {
              TAG: /* LiteralSymbolError */3,
              _0: x
            },
            Error: new Error()
          };
  }
}

function value_of_sexpr(e) {
  var ann = e.ann;
  var atom = e.it;
  if (atom.TAG === /* Atom */0) {
    return {
            it: constant_of_atom(ann, atom._0),
            ann: ann
          };
  }
  if (atom._0) {
    var es = Belt_List.map(atom._2, value_of_sexpr);
    return {
            it: {
              TAG: /* AppPrm */6,
              _0: /* VecNew */15,
              _1: es
            },
            ann: ann
          };
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* LiteralListError */4,
          _0: e
        },
        Error: new Error()
      };
}

function as_id(context, e) {
  var match = e.it;
  if (match.TAG === /* Atom */0) {
    var x = match._0;
    if (x.TAG !== /* Str */0) {
      return {
              it: x._0,
              ann: e.ann
            };
    }
    throw {
          RE_EXN_ID: SMoLParseError,
          _1: {
            TAG: /* SExprKindError */1,
            _0: /* Atom */0,
            _1: context,
            _2: e
          },
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprKindError */1,
          _0: /* Atom */0,
          _1: context,
          _2: e
        },
        Error: new Error()
      };
}

function as_list(context, e) {
  var match = e.it;
  if (match.TAG === /* Atom */0) {
    throw {
          RE_EXN_ID: SMoLParseError,
          _1: {
            TAG: /* SExprKindError */1,
            _0: /* List */1,
            _1: context,
            _2: e
          },
          Error: new Error()
        };
  }
  if (match._0) {
    throw {
          RE_EXN_ID: SMoLParseError,
          _1: {
            TAG: /* SExprKindError */1,
            _0: /* List */1,
            _1: context,
            _2: e
          },
          Error: new Error()
        };
  }
  return match._2;
}

function as_one_then_many(context, es) {
  if (es) {
    return [
            es.hd,
            es.tl
          ];
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* OneThenMany */3,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_many_then_one(context, es) {
  if (es) {
    var e1 = es.hd;
    var match = Belt_List.reverse(es.tl);
    if (match) {
      return [
              {
                hd: e1,
                tl: Belt_List.reverse(match.tl)
              },
              match.hd
            ];
    } else {
      return [
              /* [] */0,
              e1
            ];
    }
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* ManyThenOne */4,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_one(context, es) {
  if (es) {
    if (es.tl) {
      throw {
            RE_EXN_ID: SMoLParseError,
            _1: {
              TAG: /* SExprArityError */2,
              _0: /* ExactlyOne */0,
              _1: context,
              _2: es
            },
            Error: new Error()
          };
    }
    return es.hd;
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* ExactlyOne */0,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_two(context, es) {
  if (es) {
    var match = es.tl;
    if (match && !match.tl) {
      return [
              es.hd,
              match.hd
            ];
    }
    
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* ExactlyTwo */1,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_three(context, es) {
  if (es) {
    var match = es.tl;
    if (match) {
      var match$1 = match.tl;
      if (match$1 && !match$1.tl) {
        return [
                es.hd,
                match.hd,
                match$1.hd
              ];
      }
      
    }
    
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* ExactlyThree */2,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_one_then_many_then_one(context, es) {
  if (es) {
    var match = es.tl;
    if (match) {
      var e2 = match.hd;
      var e1 = es.hd;
      var match$1 = Belt_List.reverse(match.tl);
      if (match$1) {
        return [
                e1,
                {
                  hd: e2,
                  tl: Belt_List.reverse(match$1.tl)
                },
                match$1.hd
              ];
      } else {
        return [
                e1,
                /* [] */0,
                e2
              ];
      }
    }
    throw {
          RE_EXN_ID: SMoLParseError,
          _1: {
            TAG: /* SExprArityError */2,
            _0: /* OneThenManyThenOne */5,
            _1: context,
            _2: es
          },
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* OneThenManyThenOne */5,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_expr(context, e) {
  if (e.TAG !== /* Def */0) {
    return e._0;
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* TermKindError */5,
          _0: /* Expression */1,
          _1: context,
          _2: e
        },
        Error: new Error()
      };
}

function expr_of_atom(ann, atom) {
  if (atom.TAG === /* Str */0) {
    return {
            TAG: /* Con */0,
            _0: {
              TAG: /* Str */2,
              _0: atom._0
            }
          };
  }
  var x = atom._0;
  switch (x) {
    case "#f" :
        return {
                TAG: /* Con */0,
                _0: {
                  TAG: /* Lgc */1,
                  _0: false
                }
              };
    case "#t" :
        return {
                TAG: /* Con */0,
                _0: {
                  TAG: /* Lgc */1,
                  _0: true
                }
              };
    default:
      var tryNum = Belt_Option.map(Belt_Float.fromString(x), (function (n) {
              return {
                      TAG: /* Con */0,
                      _0: {
                        TAG: /* Num */0,
                        _0: n
                      }
                    };
            }));
      return Belt_Option.getWithDefault(tryNum, {
                  TAG: /* Ref */1,
                  _0: {
                    it: x,
                    ann: ann
                  }
                });
  }
}

function letstar(ann, xes, body) {
  if (!xes) {
    if (body[0]) {
      return {
              it: {
                TAG: /* Let */4,
                _0: /* [] */0,
                _1: body
              },
              ann: ann
            };
    } else {
      return body[1];
    }
  }
  var xes$1 = xes.tl;
  var match = xes.hd;
  var e = match[1];
  var x = match[0];
  if (xes$1) {
    return {
            it: {
              TAG: /* Let */4,
              _0: {
                hd: [
                  x,
                  e
                ],
                tl: /* [] */0
              },
              _1: [
                /* [] */0,
                letstar(ann, xes$1, body)
              ]
            },
            ann: ann
          };
  } else {
    return {
            it: {
              TAG: /* Let */4,
              _0: {
                hd: [
                  x,
                  e
                ],
                tl: /* [] */0
              },
              _1: body
            },
            ann: ann
          };
  }
}

function termOfSExpr(e) {
  var ann = e.ann;
  var atom = e.it;
  if (atom.TAG === /* Atom */0) {
    return {
            TAG: /* Exp */1,
            _0: {
              it: expr_of_atom(ann, atom._0),
              ann: ann
            }
          };
  }
  if (atom._0) {
    var es = Belt_List.map(atom._2, value_of_sexpr);
    return {
            TAG: /* Exp */1,
            _0: {
              it: {
                TAG: /* AppPrm */6,
                _0: /* VecNew */15,
                _1: es
              },
              ann: ann
            }
          };
  }
  var es$1 = atom._2;
  if (es$1) {
    var match = es$1.hd.it;
    if (match.TAG === /* Atom */0) {
      var match$1 = match._0;
      if (match$1.TAG !== /* Str */0) {
        var exit = 0;
        switch (match$1._0) {
          case "!=" :
              return app_prm(ann, /* Ne */9, es$1.tl);
          case "*" :
              return app_prm(ann, /* Mul */2, es$1.tl);
          case "+" :
              return app_prm(ann, /* Add */0, es$1.tl);
          case "-" :
              return app_prm(ann, /* Sub */1, es$1.tl);
          case "/" :
              return app_prm(ann, /* Div */3, es$1.tl);
          case "<" :
              return app_prm(ann, /* Lt */4, es$1.tl);
          case "<=" :
              return app_prm(ann, /* Le */7, es$1.tl);
          case "=" :
              return app_prm(ann, /* Eq */5, es$1.tl);
          case ">" :
              return app_prm(ann, /* Gt */6, es$1.tl);
          case ">=" :
              return app_prm(ann, /* Ge */8, es$1.tl);
          case "begin" :
              var match$2 = as_many_then_one("one or more expressions", es$1.tl);
              var terms = Belt_List.map(Belt_List.map(match$2[0], termOfSExpr), (function (param) {
                      return as_expr("an expression", param);
                    }));
              var result = as_expr("an expression", termOfSExpr(match$2[1]));
              return {
                      TAG: /* Exp */1,
                      _0: {
                        it: {
                          TAG: /* Bgn */8,
                          _0: terms,
                          _1: result
                        },
                        ann: ann
                      }
                    };
          case "cond" :
              var branches = Belt_List.map(Belt_List.map(es$1.tl, (function (param) {
                          return as_list("a `cond` branch", param);
                        })), (function (param) {
                      return as_one_then_many_then_one("the condition followed by the branch", param);
                    }));
              var _parsed = /* [] */0;
              var _branches = branches;
              while(true) {
                var branches$1 = _branches;
                var parsed = _parsed;
                if (!branches$1) {
                  return {
                          TAG: /* Exp */1,
                          _0: {
                            it: {
                              TAG: /* Cnd */10,
                              _0: Belt_List.reverse(parsed),
                              _1: undefined
                            },
                            ann: ann
                          }
                        };
                }
                var match$3 = branches$1.hd;
                var $$case = match$3[0];
                var match$4 = $$case.it;
                if (match$4.TAG === /* Atom */0) {
                  var match$5 = match$4._0;
                  if (match$5.TAG !== /* Str */0 && match$5._0 === "else" && !branches$1.tl) {
                    var terms$1 = Belt_List.map(match$3[1], termOfSExpr);
                    var result$1 = as_expr("an expression", termOfSExpr(match$3[2]));
                    return {
                            TAG: /* Exp */1,
                            _0: {
                              it: {
                                TAG: /* Cnd */10,
                                _0: Belt_List.reverse(parsed),
                                _1: [
                                  terms$1,
                                  result$1
                                ]
                              },
                              ann: ann
                            }
                          };
                  }
                  
                }
                var $$case$1 = as_expr("a (conditional) expression", termOfSExpr($$case));
                var terms$2 = Belt_List.map(match$3[1], termOfSExpr);
                var result$2 = as_expr("an expression", termOfSExpr(match$3[2]));
                _branches = branches$1.tl;
                _parsed = {
                  hd: [
                    $$case$1,
                    [
                      terms$2,
                      result$2
                    ]
                  ],
                  tl: parsed
                };
                continue ;
              };
          case "deffun" :
              var match$6 = as_one_then_many_then_one("a function header and a body", es$1.tl);
              var match$7 = as_one_then_many("function name followed by parameters", as_list("function name and parameters", match$6[0]));
              var fun = as_id("a function name", match$7[0]);
              var args = Belt_List.map(match$7[1], (function (param) {
                      return as_id("a parameter", param);
                    }));
              var terms$3 = Belt_List.map(match$6[1], termOfSExpr);
              var result$3 = as_expr("an expression to be returned", termOfSExpr(match$6[2]));
              return {
                      TAG: /* Def */0,
                      _0: {
                        it: {
                          TAG: /* Fun */1,
                          _0: fun,
                          _1: args,
                          _2: [
                            terms$3,
                            result$3
                          ]
                        },
                        ann: ann
                      }
                    };
          case "defvar" :
              var match$8 = as_two("a variable and an expression", es$1.tl);
              var x = as_id("a variable name", match$8[0]);
              var e$1 = as_expr("an expression", termOfSExpr(match$8[1]));
              return {
                      TAG: /* Def */0,
                      _0: {
                        it: {
                          TAG: /* Var */0,
                          _0: x,
                          _1: e$1
                        },
                        ann: ann
                      }
                    };
          case "eq?" :
          case "equal?" :
          case "eqv?" :
              exit = 2;
              break;
          case "error" :
              return app_prm(ann, /* Err */20, es$1.tl);
          case "if" :
              var match$9 = as_three("three expressions (i.e., a condition, the \"then\" branch, and the \"else\" branch)", es$1.tl);
              var e_cnd = as_expr("a (conditional) expression", termOfSExpr(match$9[0]));
              var e_thn = as_expr("an expression", termOfSExpr(match$9[1]));
              var e_els = as_expr("an expression", termOfSExpr(match$9[2]));
              return {
                      TAG: /* Exp */1,
                      _0: {
                        it: {
                          TAG: /* If */9,
                          _0: e_cnd,
                          _1: e_thn,
                          _2: e_els
                        },
                        ann: ann
                      }
                    };
          case "lambda" :
              var match$10 = as_one_then_many_then_one("the function signature followed by the function body", es$1.tl);
              var args$1 = Belt_List.map(as_list("function parameters", match$10[0]), (function (param) {
                      return as_id("a parameter", param);
                    }));
              var terms$4 = Belt_List.map(match$10[1], termOfSExpr);
              var result$4 = as_expr("an expression to be returned", termOfSExpr(match$10[2]));
              return {
                      TAG: /* Exp */1,
                      _0: {
                        it: {
                          TAG: /* Lam */3,
                          _0: args$1,
                          _1: [
                            terms$4,
                            result$4
                          ]
                        },
                        ann: ann
                      }
                    };
          case "left" :
              return app_prm(ann, /* PairRefLeft */12, es$1.tl);
          case "let" :
              var match$11 = as_one_then_many_then_one("the bindings followed by the body", es$1.tl);
              var xes = Belt_List.map(Belt_List.map(as_list("variable-expression pairs", match$11[0]), (function (param) {
                          return as_list("a variable and an expression", param);
                        })), (function (param) {
                      return as_two("a variable and an expression", param);
                    }));
              var xes$1 = Belt_List.map(xes, (function (param) {
                      var x = as_id("a variable to be bound", param[0]);
                      var e = as_expr("an expression", termOfSExpr(param[1]));
                      return [
                              x,
                              e
                            ];
                    }));
              var ts = Belt_List.map(match$11[1], termOfSExpr);
              var result$5 = as_expr("an expression to be return", termOfSExpr(match$11[2]));
              return {
                      TAG: /* Exp */1,
                      _0: {
                        it: {
                          TAG: /* Let */4,
                          _0: xes$1,
                          _1: [
                            ts,
                            result$5
                          ]
                        },
                        ann: ann
                      }
                    };
          case "let*" :
              var match$12 = as_one_then_many_then_one("the bindings followed by the body", es$1.tl);
              var xes$2 = Belt_List.map(Belt_List.map(as_list("variable-expression pairs", match$12[0]), (function (param) {
                          return as_list("a variable and an expression", param);
                        })), (function (param) {
                      return as_two("a variable and an expression", param);
                    }));
              var xes$3 = Belt_List.map(xes$2, (function (param) {
                      var x = as_id("a variable to be bound", param[0]);
                      var e = as_expr("an expression", termOfSExpr(param[1]));
                      return [
                              x,
                              e
                            ];
                    }));
              var ts$1 = Belt_List.map(match$12[1], termOfSExpr);
              var result$6 = as_expr("an expression to be return", termOfSExpr(match$12[2]));
              return {
                      TAG: /* Exp */1,
                      _0: letstar(ann, xes$3, [
                            ts$1,
                            result$6
                          ])
                    };
          case "letrec" :
              var match$13 = as_one_then_many_then_one("the bindings followed by the body", es$1.tl);
              var xes$4 = Belt_List.map(Belt_List.map(as_list("variable-expression pairs", match$13[0]), (function (param) {
                          return as_list("a variable and an expression", param);
                        })), (function (param) {
                      return as_two("a variable and an expression", param);
                    }));
              var xes$5 = Belt_List.map(xes$4, (function (param) {
                      var x = as_id("a variable to be bound", param[0]);
                      var e = as_expr("an expression", termOfSExpr(param[1]));
                      return [
                              x,
                              e
                            ];
                    }));
              var ts$2 = Belt_List.map(match$13[1], termOfSExpr);
              var result$7 = as_expr("an expression to be return", termOfSExpr(match$13[2]));
              return {
                      TAG: /* Exp */1,
                      _0: {
                        it: {
                          TAG: /* Letrec */5,
                          _0: xes$5,
                          _1: [
                            ts$2,
                            result$7
                          ]
                        },
                        ann: ann
                      }
                    };
          case "not" :
              return app_prm(ann, /* Not */21, es$1.tl);
          case "mpair" :
          case "pair" :
              return app_prm(ann, /* PairNew */10, es$1.tl);
          case "quote" :
              var e$2 = as_one("a quoted value", es$1.tl);
              return {
                      TAG: /* Exp */1,
                      _0: value_of_sexpr(e$2)
                    };
          case "right" :
              return app_prm(ann, /* PairRefRight */11, es$1.tl);
          case "set!" :
              var match$14 = as_two("a variable and an expression", es$1.tl);
              var x$1 = as_id("a variable to be set", match$14[0]);
              var e$3 = as_expr("an expression", termOfSExpr(match$14[1]));
              return {
                      TAG: /* Exp */1,
                      _0: {
                        it: {
                          TAG: /* Set */2,
                          _0: x$1,
                          _1: e$3
                        },
                        ann: ann
                      }
                    };
          case "set-left!" :
              return app_prm(ann, /* PairSetLeft */14, es$1.tl);
          case "set-right!" :
              return app_prm(ann, /* PairSetRight */13, es$1.tl);
          case "mvec" :
          case "vec" :
              return app_prm(ann, /* VecNew */15, es$1.tl);
          case "vec-len" :
          case "vlen" :
              return app_prm(ann, /* VecLen */18, es$1.tl);
          case "vec-ref" :
          case "vref" :
              return app_prm(ann, /* VecRef */16, es$1.tl);
          case "vec-set!" :
          case "vset!" :
              return app_prm(ann, /* VecSet */17, es$1.tl);
          case "λ" :
              var match$15 = as_one_then_many_then_one("the function signature followed by the function body", es$1.tl);
              var args$2 = Belt_List.map(as_list("function parameters", match$15[0]), (function (param) {
                      return as_id("a parameter", param);
                    }));
              var terms$5 = Belt_List.map(match$15[1], termOfSExpr);
              var result$8 = as_expr("an expression to be returned", termOfSExpr(match$15[2]));
              return {
                      TAG: /* Exp */1,
                      _0: {
                        it: {
                          TAG: /* Lam */3,
                          _0: args$2,
                          _1: [
                            terms$5,
                            result$8
                          ]
                        },
                        ann: ann
                      }
                    };
          default:
            
        }
        if (exit === 2) {
          return app_prm(ann, /* Eqv */19, es$1.tl);
        }
        
      }
      
    }
    
  }
  var match$16 = as_one_then_many("a function call/application, which includes a function and then zero or more arguments", es$1);
  var e$4 = as_expr("a function", termOfSExpr(match$16[0]));
  var es$2 = Belt_List.map(Belt_List.map(match$16[1], termOfSExpr), (function (param) {
          return as_expr("an argument", param);
        }));
  return {
          TAG: /* Exp */1,
          _0: {
            it: {
              TAG: /* App */7,
              _0: e$4,
              _1: es$2
            },
            ann: ann
          }
        };
}

function app_prm(ann, p, es) {
  var es$1 = Belt_List.map(Belt_List.map(es, termOfSExpr), (function (param) {
          return as_expr("an argument", param);
        }));
  return {
          TAG: /* Exp */1,
          _0: {
            it: {
              TAG: /* AppPrm */6,
              _0: p,
              _1: es$1
            },
            ann: ann
          }
        };
}

function parseTerms(src) {
  try {
    return Belt_List.map(SExpression.fromString(src), termOfSExpr);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SExpression.SExpressionError) {
      var err$1 = {
        TAG: /* SExprParseError */0,
        _0: SExpression.$$Error.toString(err._1)
      };
      throw {
            RE_EXN_ID: SMoLParseError,
            _1: err$1,
            Error: new Error()
          };
    }
    throw err;
  }
}

function consider_context(e, ctx) {
  if (typeof ctx !== "number") {
    return "" + e + "";
  }
  switch (ctx) {
    case /* Stat */0 :
        return "" + e + ";";
    case /* Return */1 :
        return "return " + e + ";";
    case /* TopLevel */2 :
        return "console.log(" + e + ");";
    
  }
}

function constantToString(c) {
  if (typeof c === "number") {
    return "null";
  }
  switch (c.TAG | 0) {
    case /* Num */0 :
        return String(c._0);
    case /* Lgc */1 :
        if (c._0) {
          return "true";
        } else {
          return "false";
        }
    case /* Str */2 :
        return "\"" + $$String.escaped(c._0) + "\"";
    
  }
}

function listToString$1(ss) {
  return "(" + $$String.concat(", ", ss) + ")";
}

function xToString(x) {
  var re = /-./g;
  var matchFn = function (matchPart, _offset, _wholeString) {
    return matchPart.substring(1).toUpperCase();
  };
  var x$1 = x.replace(re, matchFn);
  if (x$1 === "var") {
    return "$var";
  } else if (x$1 === "+") {
    return "(function(x, y) { return x + y; })";
  } else if (x$1 === "-") {
    return "(function(x, y) { return x - y; })";
  } else if (x$1 === "*") {
    return "(function(x, y) { return x * y; })";
  } else if (x$1 === "/") {
    return "(function(x, y) { return x / y; })";
  } else {
    return x$1;
  }
}

function defvarToString(x, e) {
  return "let " + xToString(x) + " = " + e + ";";
}

function exprLamToString(xs, b) {
  return "function " + listToString$1(xs) + " {\n  " + indent(b, 2) + "\n}";
}

function infix_consider_context(e, ctx) {
  if (typeof ctx === "number" || !ctx._0) {
    return consider_context(e, ctx);
  } else {
    return "(" + e + ")";
  }
}

function assign_consider_context(e, ctx) {
  if (typeof ctx !== "number") {
    if (ctx._0) {
      return "(" + e + ")";
    } else {
      return consider_context(e, ctx);
    }
  }
  switch (ctx) {
    case /* Stat */0 :
        return consider_context(e, ctx);
    case /* Return */1 :
        return "" + e + ";\nreturn;";
    case /* TopLevel */2 :
        return "" + e + ";";
    
  }
}

function exprAppToString(e, es) {
  return "" + e + "" + listToString$1(es) + "";
}

function exprBgnToString(es, e) {
  return "(" + $$String.concat(", ", Belt_List.concatMany([
                  es,
                  {
                    hd: e,
                    tl: /* [] */0
                  }
                ])) + ")";
}

function exprIfToString(e_cnd, e_thn, e_els) {
  return "(" + e_cnd + " ? " + e_thn + " : " + e_els + ")";
}

function exprLetToString(xes, b) {
  return "((" + $$String.concat(", ", Belt_List.map(xes, (function (param) {
                    return param[0];
                  }))) + ")=>{" + b + "})(" + $$String.concat(", ", Belt_List.map(xes, (function (param) {
                    return param[1];
                  }))) + ")";
}

function exprLetrecToString(xes, b) {
  var b$1 = $$String.concat(";\n", Belt_List.concatMany([
            Belt_List.map(xes, (function (param) {
                    return defvarToString(param[0], param[1]);
                  })),
            {
              hd: b,
              tl: /* [] */0
            }
          ]));
  return "()=>{" + b$1 + "})()";
}

function expToString$1(ctx, e) {
  var c = e.it;
  switch (c.TAG | 0) {
    case /* Con */0 :
        return consider_context(constantToString(c._0), ctx);
    case /* Ref */1 :
        return consider_context(xToString(c._0.it), ctx);
    case /* Set */2 :
        var x = xToString(c._0.it);
        var e$1 = expToString$1(/* Expr */{
              _0: false
            }, c._1);
        return assign_consider_context("" + x + " = " + e$1 + "", ctx);
    case /* Lam */3 :
        return consider_context(exprLamToString(Belt_List.map(Belt_List.map(c._0, unannotate), xToString), printBlock$1(/* Return */1, c._1)), ctx);
    case /* Let */4 :
        return consider_context(exprLetToString(Belt_List.map(c._0, xeToString$1), printBlock$1(/* Return */1, c._1)), ctx);
    case /* Letrec */5 :
        return consider_context(exprLetrecToString(Belt_List.map(c._0, xeToString$1), printBlock$1(/* Return */1, c._1)), ctx);
    case /* AppPrm */6 :
        var partial_arg = /* Expr */{
          _0: true
        };
        var p = c._0;
        var es = Belt_List.map(c._1, (function (param) {
                return expToString$1(partial_arg, param);
              }));
        switch (p) {
          case /* Add */0 :
              return infix_consider_context("" + $$String.concat(" + ", es) + "", ctx);
          case /* Sub */1 :
              return infix_consider_context("" + $$String.concat(" - ", es) + "", ctx);
          case /* Mul */2 :
              return infix_consider_context("" + $$String.concat(" * ", es) + "", ctx);
          case /* Div */3 :
              return infix_consider_context("" + $$String.concat(" / ", es) + "", ctx);
          case /* Lt */4 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match = es.tl;
              if (match && !match.tl) {
                return infix_consider_context("" + es.hd + " < " + match.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* Eq */5 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$1 = es.tl;
              if (match$1 && !match$1.tl) {
                return infix_consider_context("" + es.hd + " === " + match$1.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* Gt */6 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$2 = es.tl;
              if (match$2 && !match$2.tl) {
                return infix_consider_context("" + es.hd + " > " + match$2.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* Le */7 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$3 = es.tl;
              if (match$3 && !match$3.tl) {
                return infix_consider_context("" + es.hd + " <= " + match$3.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* Ge */8 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$4 = es.tl;
              if (match$4 && !match$4.tl) {
                return infix_consider_context("" + es.hd + " >= " + match$4.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* Ne */9 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$5 = es.tl;
              if (match$5 && !match$5.tl) {
                return infix_consider_context("" + es.hd + " != " + match$5.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* PairNew */10 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$6 = es.tl;
              if (match$6 && !match$6.tl) {
                return consider_context("[ " + es.hd + ", " + match$6.hd + " ]", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* PairRefRight */11 :
              if (es && !es.tl) {
                return consider_context("" + es.hd + "[1]", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* PairRefLeft */12 :
              if (es && !es.tl) {
                return consider_context("" + es.hd + "[0]", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* PairSetRight */13 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$7 = es.tl;
              if (match$7 && !match$7.tl) {
                return assign_consider_context("" + es.hd + "[1] = " + match$7.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* PairSetLeft */14 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$8 = es.tl;
              if (match$8 && !match$8.tl) {
                return assign_consider_context("" + es.hd + "[0] = " + match$8.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* VecNew */15 :
              return consider_context("[ " + $$String.concat(", ", es) + " ]", ctx);
          case /* VecRef */16 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$9 = es.tl;
              if (match$9 && !match$9.tl) {
                return consider_context("" + es.hd + "[" + match$9.hd + "]", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* VecSet */17 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$10 = es.tl;
              if (!match$10) {
                return "/* a primitive operation not supported yet */";
              }
              var match$11 = match$10.tl;
              if (match$11 && !match$11.tl) {
                return assign_consider_context("" + es.hd + "[" + match$10.hd + "] = " + match$11.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* VecLen */18 :
              if (es && !es.tl) {
                return consider_context("" + es.hd + ".length", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* Eqv */19 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$12 = es.tl;
              if (match$12 && !match$12.tl) {
                return infix_consider_context("" + es.hd + " === " + match$12.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* Err */20 :
              if (es && !es.tl) {
                return "throw " + es.hd + "";
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* Not */21 :
              if (es && !es.tl) {
                return infix_consider_context("! " + es.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          
        }
    case /* App */7 :
        var partial_arg$1 = /* Expr */{
          _0: false
        };
        return consider_context(exprAppToString(expToString$1(/* Expr */{
                            _0: false
                          }, c._0), Belt_List.map(c._1, (function (param) {
                              return expToString$1(partial_arg$1, param);
                            }))), ctx);
    case /* Bgn */8 :
        var partial_arg$2 = /* Expr */{
          _0: false
        };
        return consider_context(exprBgnToString(Belt_List.map(c._0, (function (param) {
                              return expToString$1(partial_arg$2, param);
                            })), expToString$1(/* Expr */{
                            _0: false
                          }, c._1)), ctx);
    case /* If */9 :
        return consider_context(exprIfToString(expToString$1(/* Expr */{
                            _0: true
                          }, c._0), expToString$1(/* Expr */{
                            _0: true
                          }, c._1), expToString$1(/* Expr */{
                            _0: true
                          }, c._2)), ctx);
    case /* Cnd */10 :
        var ebs = Belt_List.map(c._0, (function (param) {
                return ebToString$1(ctx, param);
              }));
        var ob = Belt_Option.map(c._1, (function (param) {
                return printBlock$1(ctx, param);
              }));
        var ob$1 = ob !== undefined ? " else {\n  " + indent(ob, 2) + "\n}" : "";
        var ebs$1 = Belt_List.map(ebs, (function (param) {
                return "if (" + param[0] + ") {\n  " + indent(param[1], 2) + "\n}";
              }));
        var ebs$2 = $$String.concat(" else ", ebs$1);
        return ebs$2 + ob$1;
    
  }
}

function printBlock$1(ctx, b) {
  return $$String.concat("\n", Belt_List.concatMany([
                  Belt_List.map(b[0], termAsStat),
                  {
                    hd: expToString$1(ctx, b[1]),
                    tl: /* [] */0
                  }
                ]));
}

function defToString(d) {
  var match = d.it;
  if (match.TAG === /* Var */0) {
    return defvarToString(match._0.it, expToString$1(/* Expr */{
                    _0: false
                  }, match._1));
  } else {
    var f = xToString(match._0.it);
    var xs = Belt_List.map(Belt_List.map(match._1, unannotate), xToString);
    var b = printBlock$1(/* Return */1, match._2);
    return "function " + f + "" + listToString$1(xs) + " {" + indentBlock(b, 2) + "\n}";
  }
}

function termAsStat(t) {
  if (t.TAG === /* Def */0) {
    return defToString(t._0);
  } else {
    return expToString$1(/* Stat */0, t._0);
  }
}

function ebToString$1(ctx, eb) {
  return [
          expToString$1(/* Expr */{
                _0: false
              }, eb[0]),
          printBlock$1(ctx, eb[1])
        ];
}

function xeToString$1(xe) {
  return [
          xToString(xe[0].it),
          expToString$1(/* Expr */{
                _0: false
              }, xe[1])
        ];
}

function printTerm$1(t) {
  if (t.TAG === /* Def */0) {
    return defToString(t._0);
  } else {
    return expToString$1(/* Expr */{
                _0: false
              }, t._0);
  }
}

function printProgram(p) {
  var tts = function (t) {
    if (t.TAG === /* Def */0) {
      return defToString(t._0);
    } else {
      return expToString$1(/* TopLevel */2, t._0);
    }
  };
  return $$String.concat("\n", Belt_List.map(p, tts));
}

function printBlock$2(param) {
  return $$String.concat("\n", Belt_List.concatMany([
                  Belt_List.map(param[0], termAsStat),
                  {
                    hd: expToString$1(/* Return */1, param[1]),
                    tl: /* [] */0
                  }
                ]));
}

var mutating = {
  contents: false
};

function consider_context$1(e, ctx) {
  if (typeof ctx !== "number") {
    return "" + e + "";
  }
  switch (ctx) {
    case /* Stat */0 :
    case /* Return */1 :
        return "" + e + "";
    case /* TopLevel */2 :
        return "println(" + e + ")";
    
  }
}

function constantToString$1(c) {
  if (typeof c === "number") {
    return "null";
  }
  switch (c.TAG | 0) {
    case /* Num */0 :
        return String(c._0);
    case /* Lgc */1 :
        if (c._0) {
          return "true";
        } else {
          return "false";
        }
    case /* Str */2 :
        return "\"" + $$String.escaped(c._0) + "\"";
    
  }
}

function listToString$2(ss) {
  return "(" + $$String.concat(", ", ss) + ")";
}

function xToString$1(x) {
  var re = /-./g;
  var matchFn = function (matchPart, _offset, _wholeString) {
    return matchPart.substring(1).toUpperCase();
  };
  var x$1 = x.replace(re, matchFn);
  if (x$1 === "var") {
    return "$var";
  } else if (x$1 === "+") {
    return "(x, y) => (x + y)";
  } else if (x$1 === "-") {
    return "(x, y) => (x - y)";
  } else if (x$1 === "*") {
    return "(x, y) => (x * y)";
  } else if (x$1 === "/") {
    return "(x, y) => (x / y)";
  } else {
    return x$1;
  }
}

function parameterToString(x) {
  return "" + xToString$1(x) + " : Int";
}

function defvarToString$1(x, e) {
  return "" + (
          mutating.contents ? "var" : "val"
        ) + " " + parameterToString(x) + " = " + e + "";
}

function exprLamToString$1(xs, b) {
  return "" + listToString$2(xs) + " =>" + indentBlock(b, 2) + "";
}

function infix_consider_context$1(e, ctx) {
  if (typeof ctx === "number" || !ctx._0) {
    return consider_context$1(e, ctx);
  } else {
    return "(" + e + ")";
  }
}

function assign_consider_context$1(e, ctx) {
  if (typeof ctx !== "number") {
    if (ctx._0) {
      return "(" + e + ")";
    } else {
      return consider_context$1(e, ctx);
    }
  }
  switch (ctx) {
    case /* Stat */0 :
        return consider_context$1(e, ctx);
    case /* Return */1 :
    case /* TopLevel */2 :
        return "" + e + "";
    
  }
}

function exprAppToString$1(e, es) {
  return "" + e + "" + listToString$2(es) + "";
}

function exprBgnToString$1(es, e) {
  return "(" + $$String.concat(", ", Belt_List.concatMany([
                  es,
                  {
                    hd: e,
                    tl: /* [] */0
                  }
                ])) + ")";
}

function exprIfToString$1(e_cnd, e_thn, e_els) {
  return "(" + e_cnd + " ? " + e_thn + " : " + e_els + ")";
}

function exprLetToString$1(xes, b) {
  return "((" + $$String.concat(", ", Belt_List.map(xes, (function (param) {
                    return param[0];
                  }))) + ")=>{" + b + "})(" + $$String.concat(", ", Belt_List.map(xes, (function (param) {
                    return param[1];
                  }))) + ")";
}

function exprLetrecToString$1(xes, b) {
  var b$1 = $$String.concat("\n", Belt_List.concatMany([
            Belt_List.map(xes, (function (param) {
                    return defvarToString$1(param[0], param[1]);
                  })),
            {
              hd: b,
              tl: /* [] */0
            }
          ]));
  return "()=>{" + b$1 + "})()";
}

function expToString$2(ctx, e) {
  var c = e.it;
  switch (c.TAG | 0) {
    case /* Con */0 :
        return consider_context$1(constantToString$1(c._0), ctx);
    case /* Ref */1 :
        return consider_context$1(xToString$1(c._0.it), ctx);
    case /* Set */2 :
        var x = xToString$1(c._0.it);
        var e$1 = expToString$2(/* Expr */{
              _0: false
            }, c._1);
        return assign_consider_context$1("" + x + " = " + e$1 + "", ctx);
    case /* Lam */3 :
        return consider_context$1(exprLamToString$1(Belt_List.map(Belt_List.map(c._0, unannotate), parameterToString), printBlock$3(/* Return */1, c._1)), ctx);
    case /* Let */4 :
        return consider_context$1(exprLetToString$1(Belt_List.map(c._0, xeToString$2), printBlock$3(/* Return */1, c._1)), ctx);
    case /* Letrec */5 :
        return consider_context$1(exprLetrecToString$1(Belt_List.map(c._0, xeToString$2), printBlock$3(/* Return */1, c._1)), ctx);
    case /* AppPrm */6 :
        var partial_arg = /* Expr */{
          _0: true
        };
        var p = c._0;
        var es = Belt_List.map(c._1, (function (param) {
                return expToString$2(partial_arg, param);
              }));
        switch (p) {
          case /* Add */0 :
              return infix_consider_context$1("" + $$String.concat(" + ", es) + "", ctx);
          case /* Sub */1 :
              return infix_consider_context$1("" + $$String.concat(" - ", es) + "", ctx);
          case /* Mul */2 :
              return infix_consider_context$1("" + $$String.concat(" * ", es) + "", ctx);
          case /* Div */3 :
              return infix_consider_context$1("" + $$String.concat(" / ", es) + "", ctx);
          case /* Lt */4 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match = es.tl;
              if (match && !match.tl) {
                return infix_consider_context$1("" + es.hd + " < " + match.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* Eq */5 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$1 = es.tl;
              if (match$1 && !match$1.tl) {
                return infix_consider_context$1("" + es.hd + " === " + match$1.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* Gt */6 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$2 = es.tl;
              if (match$2 && !match$2.tl) {
                return infix_consider_context$1("" + es.hd + " > " + match$2.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* Le */7 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$3 = es.tl;
              if (match$3 && !match$3.tl) {
                return infix_consider_context$1("" + es.hd + " <= " + match$3.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* Ge */8 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$4 = es.tl;
              if (match$4 && !match$4.tl) {
                return infix_consider_context$1("" + es.hd + " >= " + match$4.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* Ne */9 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$5 = es.tl;
              if (match$5 && !match$5.tl) {
                return infix_consider_context$1("" + es.hd + " != " + match$5.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* PairNew */10 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$6 = es.tl;
              if (match$6 && !match$6.tl) {
                return consider_context$1("[ " + es.hd + ", " + match$6.hd + " ]", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* PairRefRight */11 :
              if (es && !es.tl) {
                return consider_context$1("" + es.hd + "[1]", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* PairRefLeft */12 :
              if (es && !es.tl) {
                return consider_context$1("" + es.hd + "[0]", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* PairSetRight */13 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$7 = es.tl;
              if (match$7 && !match$7.tl) {
                return assign_consider_context$1("" + es.hd + "[1] = " + match$7.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* PairSetLeft */14 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$8 = es.tl;
              if (match$8 && !match$8.tl) {
                return assign_consider_context$1("" + es.hd + "[0] = " + match$8.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* VecNew */15 :
              return consider_context$1("[ " + $$String.concat(", ", es) + " ]", ctx);
          case /* VecRef */16 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$9 = es.tl;
              if (match$9 && !match$9.tl) {
                return consider_context$1("" + es.hd + "[" + match$9.hd + "]", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* VecSet */17 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$10 = es.tl;
              if (!match$10) {
                return "/* a primitive operation not supported yet */";
              }
              var match$11 = match$10.tl;
              if (match$11 && !match$11.tl) {
                return assign_consider_context$1("" + es.hd + "[" + match$10.hd + "] = " + match$11.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* VecLen */18 :
              if (es && !es.tl) {
                return consider_context$1("" + es.hd + ".length", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* Eqv */19 :
              if (!es) {
                return "/* a primitive operation not supported yet */";
              }
              var match$12 = es.tl;
              if (match$12 && !match$12.tl) {
                return infix_consider_context$1("" + es.hd + " === " + match$12.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* Err */20 :
              if (es && !es.tl) {
                return "throw " + es.hd + "";
              } else {
                return "/* a primitive operation not supported yet */";
              }
          case /* Not */21 :
              if (es && !es.tl) {
                return infix_consider_context$1("! " + es.hd + "", ctx);
              } else {
                return "/* a primitive operation not supported yet */";
              }
          
        }
    case /* App */7 :
        var partial_arg$1 = /* Expr */{
          _0: false
        };
        return consider_context$1(exprAppToString$1(expToString$2(/* Expr */{
                            _0: false
                          }, c._0), Belt_List.map(c._1, (function (param) {
                              return expToString$2(partial_arg$1, param);
                            }))), ctx);
    case /* Bgn */8 :
        var partial_arg$2 = /* Expr */{
          _0: false
        };
        return consider_context$1(exprBgnToString$1(Belt_List.map(c._0, (function (param) {
                              return expToString$2(partial_arg$2, param);
                            })), expToString$2(/* Expr */{
                            _0: false
                          }, c._1)), ctx);
    case /* If */9 :
        return consider_context$1(exprIfToString$1(expToString$2(/* Expr */{
                            _0: true
                          }, c._0), expToString$2(/* Expr */{
                            _0: true
                          }, c._1), expToString$2(/* Expr */{
                            _0: true
                          }, c._2)), ctx);
    case /* Cnd */10 :
        var ebs = Belt_List.map(c._0, (function (param) {
                return ebToString$2(ctx, param);
              }));
        var ob = Belt_Option.map(c._1, (function (param) {
                return printBlock$3(ctx, param);
              }));
        var ob$1 = ob !== undefined ? " else {\n  " + indent(ob, 2) + "\n}" : "";
        var ebs$1 = Belt_List.map(ebs, (function (param) {
                return "if (" + param[0] + ")" + indentBlock(param[1], 2) + "\n";
              }));
        var ebs$2 = $$String.concat(" else ", ebs$1);
        return ebs$2 + ob$1;
    
  }
}

function printBlock$3(ctx, b) {
  return $$String.concat("\n", Belt_List.concatMany([
                  Belt_List.map(b[0], termAsStat$1),
                  {
                    hd: expToString$2(ctx, b[1]),
                    tl: /* [] */0
                  }
                ]));
}

function termAsStat$1(t) {
  if (t.TAG === /* Def */0) {
    return defToString$1(t._0);
  } else {
    return expToString$2(/* Stat */0, t._0);
  }
}

function defToString$1(d) {
  var match = d.it;
  if (match.TAG === /* Var */0) {
    return defvarToString$1(match._0.it, expToString$2(/* Expr */{
                    _0: false
                  }, match._1));
  } else {
    var f = xToString$1(match._0.it);
    var xs = Belt_List.map(Belt_List.map(match._1, unannotate), parameterToString);
    var b = printBlock$3(/* Return */1, match._2);
    return "def " + f + "" + listToString$2(xs) + " =" + indentBlock(b, 2) + "";
  }
}

function xeToString$2(xe) {
  return [
          xToString$1(xe[0].it),
          expToString$2(/* Expr */{
                _0: false
              }, xe[1])
        ];
}

function ebToString$2(ctx, eb) {
  return [
          expToString$2(/* Expr */{
                _0: false
              }, eb[0]),
          printBlock$3(ctx, eb[1])
        ];
}

function printTerm$2(t) {
  if (t.TAG === /* Def */0) {
    return defToString$1(t._0);
  } else {
    return expToString$2(/* Expr */{
                _0: false
              }, t._0);
  }
}

function printProgram$1(p) {
  mutating.contents = $$String.contains(termsToString(p), /* '!' */33);
  var tts = function (t) {
    if (t.TAG === /* Def */0) {
      return defToString$1(t._0);
    } else {
      return expToString$2(/* TopLevel */2, t._0);
    }
  };
  return $$String.concat("\n", Belt_List.map(p, tts));
}

function printBlock$4(param) {
  return $$String.concat("\n", Belt_List.concatMany([
                  Belt_List.map(param[0], termAsStat$1),
                  {
                    hd: expToString$2(/* Return */1, param[1]),
                    tl: /* [] */0
                  }
                ]));
}

var Impossible = /* @__PURE__ */Caml_exceptions.create("SMoL.Impossible");

var base_env = Js_dict.fromArray(Belt_Array.map(all_primitives, (function (p) {
            return [
                    primitiveToString(p),
                    /* BuiltIn */0
                  ];
          })));

function make_global_env(xs) {
  var env = Js_dict.entries(base_env);
  return Js_dict.fromArray(Belt_Array.concat(env, Belt_List.toArray(Belt_List.map(xs, (function (x) {
                            return [
                                    x,
                                    /* Global */1
                                  ];
                          })))));
}

function make_local_env(env, xs) {
  var env$1 = Js_dict.entries(env);
  var env$2 = Belt_Array.map(env$1, (function (param) {
          var p = param[1];
          var p$1 = p >= 3 ? /* NonLocal */2 : p;
          return [
                  param[0],
                  p$1
                ];
        }));
  return Js_dict.fromArray(Belt_Array.concat(env$2, Belt_List.toArray(Belt_List.map(xs, (function (x) {
                            return [
                                    x,
                                    /* Local */3
                                  ];
                          })))));
}

function constantToString$2(c) {
  if (typeof c === "number") {
    return "None";
  }
  switch (c.TAG | 0) {
    case /* Num */0 :
        return String(c._0);
    case /* Lgc */1 :
        if (c._0) {
          return "True";
        } else {
          return "False";
        }
    case /* Str */2 :
        return "\"" + $$String.escaped(c._0) + "\"";
    
  }
}

function listToString$3(ss) {
  return "(" + $$String.concat(", ", ss) + ")";
}

function xToString$2(x) {
  if (x === "-") {
    return x;
  }
  var re = /-/g;
  var matchFn = function (_matchPart, _offset, _wholeString) {
    return "_";
  };
  return x.replace(re, matchFn);
}

function exprLamToString$2(xs, b) {
  if (xs === /* [] */0) {
    return "lambda: " + b + "";
  } else {
    return "lambda " + $$String.concat(",", xs) + ": " + b + "";
  }
}

function ret(ctx, code) {
  var match = ctx.node;
  if (typeof match !== "number") {
    return code;
  }
  switch (match) {
    case /* Stat */0 :
        return code;
    case /* Return */1 :
        return "return " + code + "";
    case /* TopLevel */2 :
        return "print(" + code + ")";
    
  }
}

function wrap(ctx, code) {
  var match = ctx.node;
  if (typeof match === "number" || !match._0) {
    return ret(ctx, code);
  } else {
    return "(" + code + ")";
  }
}

function exprApp_prmToString(ctx, p, es) {
  switch (p) {
    case /* Add */0 :
        return wrap(ctx, "" + $$String.concat(" + ", es) + "");
    case /* Sub */1 :
        return wrap(ctx, "" + $$String.concat(" - ", es) + "");
    case /* Mul */2 :
        return wrap(ctx, "" + $$String.concat(" * ", es) + "");
    case /* Div */3 :
        return wrap(ctx, "" + $$String.concat(" / ", es) + "");
    case /* Lt */4 :
        if (es) {
          var match = es.tl;
          if (match && !match.tl) {
            return wrap(ctx, "" + es.hd + " < " + match.hd + "");
          }
          
        }
        break;
    case /* Eq */5 :
        if (es) {
          var match$1 = es.tl;
          if (match$1 && !match$1.tl) {
            return wrap(ctx, "" + es.hd + " == " + match$1.hd + "");
          }
          
        }
        break;
    case /* Gt */6 :
        if (es) {
          var match$2 = es.tl;
          if (match$2 && !match$2.tl) {
            return wrap(ctx, "" + es.hd + " > " + match$2.hd + "");
          }
          
        }
        break;
    case /* Le */7 :
        if (es) {
          var match$3 = es.tl;
          if (match$3 && !match$3.tl) {
            return wrap(ctx, "" + es.hd + " <= " + match$3.hd + "");
          }
          
        }
        break;
    case /* Ge */8 :
        if (es) {
          var match$4 = es.tl;
          if (match$4 && !match$4.tl) {
            return wrap(ctx, "" + es.hd + " >= " + match$4.hd + "");
          }
          
        }
        break;
    case /* Ne */9 :
        if (es) {
          var match$5 = es.tl;
          if (match$5 && !match$5.tl) {
            return wrap(ctx, "" + es.hd + " != " + match$5.hd + "");
          }
          
        }
        break;
    case /* PairNew */10 :
        if (es) {
          var match$6 = es.tl;
          if (match$6 && !match$6.tl) {
            return ret(ctx, "[ " + es.hd + ", " + match$6.hd + " ]");
          }
          
        }
        break;
    case /* PairRefRight */11 :
        if (es && !es.tl) {
          return wrap(ctx, "" + es.hd + "[1]");
        }
        break;
    case /* PairRefLeft */12 :
        if (es && !es.tl) {
          return wrap(ctx, "" + es.hd + "[0]");
        }
        break;
    case /* PairSetRight */13 :
        if (es) {
          var match$7 = es.tl;
          if (match$7 && !match$7.tl) {
            var e2 = match$7.hd;
            var e1 = es.hd;
            var match$8 = ctx.node;
            if (typeof match$8 !== "number") {
              if (match$8._0) {
                return "" + e1 + ".__setitem__(1, " + e2 + ")";
              } else {
                return "" + e1 + ".__setitem__(1, " + e2 + ")";
              }
            }
            switch (match$8) {
              case /* Return */1 :
                  return "return " + e1 + ".__setitem__(1, " + e2 + ")";
              case /* Stat */0 :
              case /* TopLevel */2 :
                  return "" + e1 + "[1] = " + e2 + "";
              
            }
          }
          
        }
        break;
    case /* PairSetLeft */14 :
        if (es) {
          var match$9 = es.tl;
          if (match$9 && !match$9.tl) {
            var e2$1 = match$9.hd;
            var e1$1 = es.hd;
            var match$10 = ctx.node;
            if (typeof match$10 !== "number") {
              if (match$10._0) {
                return "" + e1$1 + ".__setitem__(0, " + e2$1 + ")";
              } else {
                return "" + e1$1 + ".__setitem__(0, " + e2$1 + ")";
              }
            }
            switch (match$10) {
              case /* Return */1 :
                  return "return " + e1$1 + ".__setitem__(0, " + e2$1 + ")";
              case /* Stat */0 :
              case /* TopLevel */2 :
                  return "" + e1$1 + "[0] = " + e2$1 + "";
              
            }
          }
          
        }
        break;
    case /* VecNew */15 :
        return ret(ctx, "[" + $$String.concat(", ", es) + "]");
    case /* VecRef */16 :
        if (es) {
          var match$11 = es.tl;
          if (match$11 && !match$11.tl) {
            return ret(ctx, "" + es.hd + "[" + match$11.hd + "]");
          }
          
        }
        break;
    case /* VecSet */17 :
        if (es) {
          var match$12 = es.tl;
          if (match$12) {
            var match$13 = match$12.tl;
            if (match$13 && !match$13.tl) {
              var e3 = match$13.hd;
              var e2$2 = match$12.hd;
              var e1$2 = es.hd;
              var match$14 = ctx.node;
              if (typeof match$14 !== "number") {
                if (match$14._0) {
                  return "" + e1$2 + ".__setitem__(" + e2$2 + ", " + e3 + ")";
                } else {
                  return "" + e1$2 + ".__setitem__(" + e2$2 + ", " + e3 + ")";
                }
              }
              switch (match$14) {
                case /* Return */1 :
                    return "return " + e1$2 + ".__setitem__(" + e2$2 + ", " + e3 + ")";
                case /* Stat */0 :
                case /* TopLevel */2 :
                    return "" + e1$2 + "[" + e2$2 + "] = " + e3 + "";
                
              }
            }
            
          }
          
        }
        break;
    case /* VecLen */18 :
        if (es && !es.tl) {
          return ret(ctx, "len(" + es.hd + ")");
        }
        break;
    case /* Eqv */19 :
        if (es) {
          var match$15 = es.tl;
          if (match$15 && !match$15.tl) {
            return wrap(ctx, "" + es.hd + " == " + match$15.hd + "");
          }
          
        }
        break;
    case /* Err */20 :
        if (es && !es.tl) {
          return "raise " + es.hd + "";
        }
        break;
    case /* Not */21 :
        if (es && !es.tl) {
          return wrap(ctx, "not " + es.hd + "");
        }
        break;
    
  }
  throw {
        RE_EXN_ID: SMoLPrintError,
        _1: "found a primitive operation (" + primitiveToString(p) + ") not supported yet.",
        Error: new Error()
      };
}

function exprAppToString$2(e, es) {
  return "" + e + "" + listToString$3(es) + "";
}

function exprLetToString$2(xes, b) {
  return exprAppToString$2(exprLamToString$2(Belt_List.map(xes, (function (param) {
                        return "" + param[0] + "=" + param[1] + "";
                      })), b), /* [] */0);
}

function consider_context$2(code, ctx) {
  var match = ctx.node;
  if (typeof match !== "number") {
    return code;
  }
  switch (match) {
    case /* Stat */0 :
        return code;
    case /* Return */1 :
        return "return " + code + "";
    case /* TopLevel */2 :
        return "print(" + code + ")";
    
  }
}

function expToString$3(ctx, e) {
  var c = e.it;
  switch (c.TAG | 0) {
    case /* Con */0 :
        return consider_context$2(constantToString$2(c._0), ctx);
    case /* Ref */1 :
        return consider_context$2(xToString$2(c._0.it), ctx);
    case /* Set */2 :
        var x = c._0;
        Js_array.unshift(x.it, ctx.refs);
        var x$1 = xToString$2(x.it);
        var e$1 = expToString$3({
              node: /* Expr */{
                _0: false
              },
              block: ctx.block,
              refs: ctx.refs,
              env: ctx.env
            }, c._1);
        var match = ctx.node;
        if (typeof match !== "number") {
          if (match._0) {
            return "(" + x$1 + " := " + e$1 + ")";
          } else {
            return "" + x$1 + " := " + e$1 + "";
          }
        }
        switch (match) {
          case /* Return */1 :
              return "return (" + x$1 + " := " + e$1 + ")";
          case /* Stat */0 :
          case /* TopLevel */2 :
              return "" + x$1 + " = " + e$1 + "";
          
        }
    case /* Lam */3 :
        var xs = c._0;
        return consider_context$2(exprLamToString$2(Belt_List.map(Belt_List.map(xs, unannotate), xToString$2), printBlock$5({
                            node: /* Expr */{
                              _0: false
                            },
                            block: ctx.block,
                            refs: ctx.refs,
                            env: ctx.env
                          }, xs, c._1)), ctx);
    case /* Let */4 :
        var xes = c._0;
        return consider_context$2(exprLetToString$2(Belt_List.map(xes, (function (param) {
                              return xeToString$3(ctx, param);
                            })), printBlock$5({
                            node: /* Expr */{
                              _0: false
                            },
                            block: ctx.block,
                            refs: ctx.refs,
                            env: ctx.env
                          }, Belt_List.map(xes, (function (param) {
                                  return param[0];
                                })), c._1)), ctx);
    case /* Letrec */5 :
        var xes$1 = c._0;
        printBlock$5({
              node: /* Expr */{
                _0: false
              },
              block: ctx.block,
              refs: ctx.refs,
              env: ctx.env
            }, Belt_List.map(xes$1, (function (param) {
                    return param[0];
                  })), c._1);
        Belt_List.map(xes$1, (function (param) {
                return xeToString$3(ctx, param);
              }));
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "Python translation does not support letrec-expression.",
              Error: new Error()
            };
        return consider_context$2(undefined, ctx);
    case /* AppPrm */6 :
        var p = c._0;
        if (p !== 17) {
          var partial_arg_node = /* Expr */{
            _0: true
          };
          var partial_arg_block = ctx.block;
          var partial_arg_refs = ctx.refs;
          var partial_arg_env = ctx.env;
          var partial_arg = {
            node: partial_arg_node,
            block: partial_arg_block,
            refs: partial_arg_refs,
            env: partial_arg_env
          };
          return exprApp_prmToString(ctx, p, Belt_List.map(c._1, (function (param) {
                            return expToString$3(partial_arg, param);
                          })));
        }
        var partial_arg_node$1 = /* Expr */{
          _0: false
        };
        var partial_arg_block$1 = ctx.block;
        var partial_arg_refs$1 = ctx.refs;
        var partial_arg_env$1 = ctx.env;
        var partial_arg$1 = {
          node: partial_arg_node$1,
          block: partial_arg_block$1,
          refs: partial_arg_refs$1,
          env: partial_arg_env$1
        };
        return exprApp_prmToString(ctx, /* VecSet */17, Belt_List.map(c._1, (function (param) {
                          return expToString$3(partial_arg$1, param);
                        })));
    case /* App */7 :
        var partial_arg_node$2 = /* Expr */{
          _0: false
        };
        var partial_arg_block$2 = ctx.block;
        var partial_arg_refs$2 = ctx.refs;
        var partial_arg_env$2 = ctx.env;
        var partial_arg$2 = {
          node: partial_arg_node$2,
          block: partial_arg_block$2,
          refs: partial_arg_refs$2,
          env: partial_arg_env$2
        };
        return consider_context$2(exprAppToString$2(expToString$3({
                            node: /* Expr */{
                              _0: false
                            },
                            block: ctx.block,
                            refs: ctx.refs,
                            env: ctx.env
                          }, c._0), Belt_List.map(c._1, (function (param) {
                              return expToString$3(partial_arg$2, param);
                            }))), ctx);
    case /* Bgn */8 :
        var es = c._0;
        var e$2 = c._1;
        var match$1 = ctx.node;
        if (typeof match$1 === "number") {
          var partial_arg_block$3 = ctx.block;
          var partial_arg_refs$3 = ctx.refs;
          var partial_arg_env$3 = ctx.env;
          var partial_arg$3 = {
            node: /* Stat */0,
            block: partial_arg_block$3,
            refs: partial_arg_refs$3,
            env: partial_arg_env$3
          };
          var es$1 = Belt_List.map(es, (function (param) {
                  return expToString$3(partial_arg$3, param);
                }));
          var e$3 = expToString$3(ctx, e$2);
          return $$String.concat("\n", Belt_List.concatMany([
                          es$1,
                          {
                            hd: e$3,
                            tl: /* [] */0
                          }
                        ]));
        }
        var ese = Belt_List.concatMany([
              es,
              {
                hd: e$2,
                tl: /* [] */0
              }
            ]);
        var partial_arg_node$3 = /* Expr */{
          _0: false
        };
        var partial_arg_block$4 = ctx.block;
        var partial_arg_refs$4 = ctx.refs;
        var partial_arg_env$4 = ctx.env;
        var partial_arg$4 = {
          node: partial_arg_node$3,
          block: partial_arg_block$4,
          refs: partial_arg_refs$4,
          env: partial_arg_env$4
        };
        var ese$1 = Belt_List.map(ese, (function (param) {
                return expToString$3(partial_arg$4, param);
              }));
        return "[" + $$String.concat(", ", ese$1) + "][-1]";
    case /* If */9 :
        var e_cnd = expToString$3({
              node: /* Expr */{
                _0: false
              },
              block: ctx.block,
              refs: ctx.refs,
              env: ctx.env
            }, c._0);
        var e_thn = expToString$3(ctx, c._1);
        var e_els = expToString$3(ctx, c._2);
        var match$2 = ctx.node;
        if (typeof match$2 === "number") {
          return "if " + e_cnd + ":" + indentBlock(e_thn, 4) + "\nelse:" + indentBlock(e_els, 4) + "";
        } else {
          return "" + e_thn + " if " + e_cnd + " else " + e_els + "";
        }
    case /* Cnd */10 :
        var match$3 = ctx.node;
        if (typeof match$3 === "number") {
          var ebs = Belt_List.map(c._0, (function (param) {
                  return ebToString$3(ctx, param);
                }));
          var ob = obToString(ctx, c._1);
          var ob$1 = ob !== undefined ? "else:" + indentBlock(ob, 4) + "" : "";
          var ebs$1 = Belt_List.map(ebs, (function (param) {
                  return "if " + param[0] + ":" + indentBlock(param[1], 4) + "\n";
                }));
          var ebs$2 = $$String.concat("el", ebs$1);
          return ebs$2 + ob$1;
        }
        throw {
              RE_EXN_ID: SMoLPrintError,
              _1: "Python translation does not fully support `cond` yet.",
              Error: new Error()
            };
    
  }
}

function xeToString$3(ctx, xe) {
  return [
          xToString$2(xe[0].it),
          expToString$3({
                node: /* Expr */{
                  _0: false
                },
                block: ctx.block,
                refs: ctx.refs,
                env: ctx.env
              }, xe[1])
        ];
}

function ebToString$3(ctx, eb) {
  return [
          expToString$3({
                node: /* Expr */{
                  _0: false
                },
                block: ctx.block,
                refs: ctx.refs,
                env: ctx.env
              }, eb[0]),
          printBlock$5(ctx, /* [] */0, eb[1])
        ];
}

function obToString(ctx, ob) {
  return Belt_Option.map(ob, (function (param) {
                return printBlock$5(ctx, /* [] */0, param);
              }));
}

function identifier_of_term(t) {
  if (t.TAG !== /* Def */0) {
    return ;
  }
  var match = t._0.it;
  return match._0;
}

function xs_of_ts(ts) {
  return Belt_List.map(Belt_List.keepMap(ts, identifier_of_term), unannotate);
}

function printBlock$5(ctx, xs, b) {
  var e = b[1];
  var ts = b[0];
  var refs = [];
  var ys = xs_of_ts(ts);
  var ctx_node = ctx.node;
  var ctx_block = ctx.block;
  var ctx_refs = ctx.refs;
  var ctx_env = make_local_env(ctx.env, Belt_List.concatMany([
            Belt_List.map(xs, unannotate),
            ys
          ]));
  var ctx_node$1 = ctx_node;
  var ctx_refs$1 = ctx_refs;
  var ctx_env$1 = ctx_env;
  var ctx_node$2 = ctx_node$1;
  var ctx_env$2 = ctx_env$1;
  var ctx$1 = {
    node: ctx_node$2,
    block: /* Local */3,
    refs: refs,
    env: ctx_env$2
  };
  var match = ctx_node$2;
  if (typeof match === "number") {
    var partial_arg_env = ctx_env$2;
    var partial_arg = {
      node: /* Stat */0,
      block: /* Local */3,
      refs: refs,
      env: partial_arg_env
    };
    var result = $$String.concat("\n", Belt_List.concatMany([
              Belt_List.map(ts, (function (param) {
                      return termToString(partial_arg, param);
                    })),
              {
                hd: expToString$3(ctx$1, e),
                tl: /* [] */0
              }
            ]));
    var refs$1 = Js_array.filter((function (x) {
            var match = Belt_Option.getWithDefault(Js_dict.get(ctx_env$2, x), /* NonLocal */2);
            return match === 2 || match === 1;
          }), refs);
    var globals = Js_array.filter((function (x) {
            var match = Belt_Option.getWithDefault(Js_dict.get(ctx_env$2, x), /* NonLocal */2);
            return match === 1;
          }), refs$1);
    var nonlocals = Js_array.filter((function (x) {
            var match = Belt_Option.getWithDefault(Js_dict.get(ctx_env$2, x), /* NonLocal */2);
            return match === 2;
          }), refs$1);
    var decl_globals = globals.length === 0 ? "" : "global " + $$String.concat(", ", Belt_List.fromArray(globals)) + "\n";
    var decl_nonlocals = nonlocals.length === 0 ? "" : "nonlocal " + $$String.concat(", ", Belt_List.fromArray(nonlocals)) + "\n";
    return "" + decl_globals + "" + decl_nonlocals + "" + result + "";
  }
  var block_as_expr = function (ctx, ts, e) {
    if (!ts) {
      return expToString$3(ctx, e);
    }
    var is_exp = function (t) {
      if (t.TAG === /* Def */0) {
        return false;
      } else {
        return true;
      }
    };
    var as_exp = function (t) {
      if (t.TAG !== /* Def */0) {
        return t._0;
      }
      throw {
            RE_EXN_ID: Impossible,
            _1: "We have checked!",
            Error: new Error()
          };
    };
    if (Belt_List.every(ts, is_exp)) {
      var es = Belt_List.concatMany([
            Belt_List.map(ts, as_exp),
            {
              hd: e,
              tl: /* [] */0
            }
          ]);
      var partial_arg_node = /* Expr */{
        _0: false
      };
      var partial_arg_block = ctx.block;
      var partial_arg_refs = ctx.refs;
      var partial_arg_env = ctx.env;
      var partial_arg = {
        node: partial_arg_node,
        block: partial_arg_block,
        refs: partial_arg_refs,
        env: partial_arg_env
      };
      var es$1 = Belt_List.map(es, (function (param) {
              return expToString$3(partial_arg, param);
            }));
      return "(" + $$String.concat(", ", es$1) + ")[-1]";
    }
    throw {
          RE_EXN_ID: SMoLPrintError,
          _1: "Python translator can't translate block that contains definitions and appears in an expression context.",
          Error: new Error()
        };
  };
  var result$1 = block_as_expr(ctx$1, ts, e);
  var refs$2 = Js_array.filter((function (x) {
          var match = Belt_Option.getWithDefault(Js_dict.get(ctx_env$2, x), /* NonLocal */2);
          return match === 2 || match === 1;
        }), refs);
  if (refs$2.length === 0) {
    return result$1;
  } else {
    return "(\"WARNING: the translation might be inaccurate\", " + result$1 + ")[-1]";
  }
}

function termToString(ctx, t) {
  if (t.TAG === /* Def */0) {
    var d = t._0;
    var match = d.it;
    if (match.TAG === /* Var */0) {
      var x = match._0.it;
      var e = expToString$3({
            node: /* Expr */{
              _0: false
            },
            block: ctx.block,
            refs: ctx.refs,
            env: ctx.env
          }, match._1);
      return "" + xToString$2(x) + " = " + e + "";
    }
    var xs = match._1;
    var f = xToString$2(match._0.it);
    var xs$1 = Belt_List.map(Belt_List.map(xs, unannotate), xToString$2);
    var b = printBlock$5({
          node: /* Return */1,
          block: ctx.block,
          refs: ctx.refs,
          env: ctx.env
        }, xs, match._2);
    return "def " + f + "" + listToString$3(xs$1) + ":\n    " + indent(b, 4) + "";
  } else {
    return expToString$3(ctx, t._0);
  }
}

function printTerm$3(t) {
  var ctx_refs = [];
  var ctx_env = make_global_env(xs_of_ts({
            hd: t,
            tl: /* [] */0
          }));
  var ctx = {
    node: /* Stat */0,
    block: /* Global */1,
    refs: ctx_refs,
    env: ctx_env
  };
  return termToString(ctx, t);
}

function printProgram$2(ts) {
  var ctx_refs = [];
  var ctx_env = make_global_env(xs_of_ts(ts));
  var ctx = {
    node: /* TopLevel */2,
    block: /* Global */1,
    refs: ctx_refs,
    env: ctx_env
  };
  return $$String.concat("\n", Belt_List.map(ts, (function (param) {
                    return termToString(ctx, param);
                  })));
}

function printBlock$6(param) {
  var ctx_refs = [];
  var ctx_env = {};
  var ctx = {
    node: /* Return */1,
    block: /* Local */3,
    refs: ctx_refs,
    env: ctx_env
  };
  return printBlock$5(ctx, /* [] */0, [
              param[0],
              param[1]
            ]);
}

function toString$4(t) {
  if (t.TAG === /* ParseError */0) {
    return toString$3(t._0);
  } else {
    return t._0;
  }
}

var TranslateError = {
  toString: toString$4
};

var SMoLTranslateError = /* @__PURE__ */Caml_exceptions.create("SMoL.SMoLTranslateError");

function translateTerms(src) {
  var ts;
  try {
    ts = parseTerms(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return $$String.concat(" ", Belt_List.map(ts, printTerm$3));
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgram(src) {
  var p;
  try {
    p = parseTerms(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgram$2(p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

var PYTranslator = {
  translateTerms: translateTerms,
  translateProgram: translateProgram
};

function translateTerms$1(src) {
  var ts;
  try {
    ts = parseTerms(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return $$String.concat(" ", Belt_List.map(ts, printTerm$1));
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgram$1(src) {
  var p;
  try {
    p = parseTerms(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgram(p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

var JSTranslator = {
  translateTerms: translateTerms$1,
  translateProgram: translateProgram$1
};

function translateTerms$2(src) {
  var ts;
  try {
    ts = parseTerms(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return $$String.concat(" ", Belt_List.map(ts, printTerm$2));
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

function translateProgram$2(src) {
  var p;
  try {
    p = parseTerms(src);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SMoLParseError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* ParseError */0,
              _0: err._1
            },
            Error: new Error()
          };
    }
    throw err;
  }
  try {
    return printProgram$1(p);
  }
  catch (raw_err$1){
    var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
    if (err$1.RE_EXN_ID === SMoLPrintError) {
      throw {
            RE_EXN_ID: SMoLTranslateError,
            _1: {
              TAG: /* PrintError */1,
              _0: err$1._1
            },
            Error: new Error()
          };
    }
    throw err$1;
  }
}

var ScalaTranslator = {
  translateTerms: translateTerms$2,
  translateProgram: translateProgram$2
};

var SMoLPrinter = {
  printProgram: termsToString,
  printBlock: printBlock,
  printTerm: printTerm
};

var JSPrinter = {
  printProgram: printProgram,
  printBlock: printBlock$2,
  printTerm: printTerm$1
};

var PYPrinter = {
  printProgram: printProgram$2,
  printBlock: printBlock$6,
  printTerm: printTerm$3
};

var ScalaPrinter = {
  printProgram: printProgram$1,
  printBlock: printBlock$4,
  printTerm: printTerm$2
};

var Parser = {
  parseTerms: parseTerms,
  parseProgram: parseTerms
};

export {
  SMoLPrintError ,
  SMoLPrinter ,
  JSPrinter ,
  PYPrinter ,
  ScalaPrinter ,
  SExprKind ,
  Arity ,
  TermKind ,
  ParseError ,
  SMoLParseError ,
  Parser ,
  TranslateError ,
  SMoLTranslateError ,
  PYTranslator ,
  JSTranslator ,
  ScalaTranslator ,
}
/* base_env Not a pure module */
