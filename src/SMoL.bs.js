// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as $$String from "rescript/lib/es6/string.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Float from "rescript/lib/es6/belt_Float.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as SExpression from "@lukuangchen/s-expression/src/SExpression.bs.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function toString(t) {
  switch (t) {
    case /* Add */0 :
        return "+";
    case /* Sub */1 :
        return "-";
    case /* Mul */2 :
        return "*";
    case /* Div */3 :
        return "/";
    case /* Lt */4 :
        return "<";
    case /* Eq */5 :
        return "eq?";
    case /* Gt */6 :
        return ">";
    case /* Le */7 :
        return "<=";
    case /* Ge */8 :
        return ">=";
    case /* Ne */9 :
        return "!=";
    case /* PairNew */10 :
        return "mpair";
    case /* PairRefRight */11 :
        return "right";
    case /* PairRefLeft */12 :
        return "left";
    case /* PairSetRight */13 :
        return "set-right!";
    case /* PairSetLeft */14 :
        return "set-left!";
    case /* VecNew */15 :
        return "mvec";
    case /* VecRef */16 :
        return "vec-ref";
    case /* VecSet */17 :
        return "vec-set!";
    case /* VecLen */18 :
        return "vec-len";
    case /* Err */19 :
        return "error";
    case /* Not */20 :
        return "not";
    case /* Print */21 :
        return "print";
    case /* Next */22 :
        return "next";
    case /* Cons */23 :
        return "cons";
    
  }
}

var Primitive = {
  toString: toString
};

function mapAnn(param, f) {
  return {
          it: Curry._1(f, param.it),
          ann: param.ann
        };
}

function toString$1(t) {
  if (t) {
    return "list";
  } else {
    return "atom";
  }
}

var SExprKind = {
  toString: toString$1
};

function toString$2(t) {
  switch (t) {
    case /* ExactlyOne */0 :
        return "exactly one";
    case /* ExactlyTwo */1 :
        return "exactly two";
    case /* ExactlyThree */2 :
        return "exactly three";
    case /* OneThenMany */3 :
        return "one followed by many";
    case /* ManyThenOne */4 :
        return "many followed by one";
    case /* OneThenManyThenOne */5 :
        return "one followed by several followed by one";
    
  }
}

var Arity = {
  toString: toString$2
};

function toString$3(t) {
  if (t) {
    return "expression";
  } else {
    return "definition";
  }
}

var TermKind = {
  toString: toString$3
};

function toString$4(t) {
  switch (t.TAG | 0) {
    case /* SExprParseError */0 :
        return "expecting a (valid) s-expression, but the input is not: " + t._0 + "";
    case /* SExprKindError */1 :
        return "expecting a " + t._1 + ", given " + SExpression.toString(t._2) + "";
    case /* SExprArityError */2 :
        return "expecting " + t._1 + ", given " + $$String.concat(" ", Belt_List.map(t._2, SExpression.toString)) + "";
    case /* LiteralSymbolError */3 :
        return "expecting a literal value, given a symbol " + t._0 + "";
    case /* LiteralListError */4 :
        return "expecting a constant or a vector, given " + SExpression.toString(t._0) + "";
    case /* TermKindError */5 :
        var term = t._2;
        return "expecting " + t._1 + ", given something else at " + SExpression.SrcLoc.toString(term.ann.begin) + "-" + SExpression.SrcLoc.toString(term.ann.end) + "";
    
  }
}

var ParseError = {
  toString: toString$4
};

var SMoLParseError = /* @__PURE__ */Caml_exceptions.create("SMoL.SMoLParseError");

function constant_of_atom(atom) {
  if (atom.TAG === /* Str */0) {
    return {
            TAG: /* Str */2,
            _0: atom._0
          };
  }
  var x = atom._0;
  switch (x) {
    case "#f" :
        return {
                TAG: /* Lgc */1,
                _0: false
              };
    case "#t" :
        return {
                TAG: /* Lgc */1,
                _0: true
              };
    default:
      var tryNum = Belt_Float.fromString(x);
      if (tryNum !== undefined) {
        return {
                TAG: /* Num */0,
                _0: tryNum
              };
      }
      throw {
            RE_EXN_ID: SMoLParseError,
            _1: {
              TAG: /* LiteralSymbolError */3,
              _0: x
            },
            Error: new Error()
          };
  }
}

function outputletOfSExpr(e) {
  var it = e.it;
  if (it.TAG === /* Atom */0) {
    var match = it._0;
    if (match.TAG !== /* Str */0 && match._0 === "error") {
      return /* OErr */0;
    }
    
  }
  var p = function (e) {
    var atom = e.it;
    if (atom.TAG === /* Atom */0) {
      return {
              TAG: /* Con */0,
              _0: constant_of_atom(atom._0)
            };
    } else if (atom._0) {
      return {
              TAG: /* Vec */2,
              _0: Belt_List.map(atom._2, p)
            };
    } else {
      return {
              TAG: /* Lst */1,
              _0: Belt_List.map(atom._2, p)
            };
    }
  };
  return /* OVal */{
          _0: p(e)
        };
}

function value_of_sexpr(e) {
  var ann = e.ann;
  var it = e.it;
  if (it.TAG === /* Atom */0) {
    return {
            it: {
              TAG: /* Con */0,
              _0: constant_of_atom(it._0)
            },
            ann: ann
          };
  }
  if (it._0) {
    var es = Belt_List.map(it._2, value_of_sexpr);
    return {
            it: {
              TAG: /* AppPrm */6,
              _0: /* VecNew */15,
              _1: es
            },
            ann: ann
          };
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* LiteralListError */4,
          _0: e
        },
        Error: new Error()
      };
}

function as_id(context, e) {
  var match = e.it;
  if (match.TAG === /* Atom */0) {
    var x = match._0;
    if (x.TAG !== /* Str */0) {
      return {
              it: x._0,
              ann: e.ann
            };
    }
    throw {
          RE_EXN_ID: SMoLParseError,
          _1: {
            TAG: /* SExprKindError */1,
            _0: /* Atom */0,
            _1: context,
            _2: e
          },
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprKindError */1,
          _0: /* Atom */0,
          _1: context,
          _2: e
        },
        Error: new Error()
      };
}

function as_list(context, e) {
  var it = e.it;
  if (it.TAG === /* Atom */0) {
    throw {
          RE_EXN_ID: SMoLParseError,
          _1: {
            TAG: /* SExprKindError */1,
            _0: /* List */1,
            _1: context,
            _2: e
          },
          Error: new Error()
        };
  }
  if (it._0) {
    throw {
          RE_EXN_ID: SMoLParseError,
          _1: {
            TAG: /* SExprKindError */1,
            _0: /* List */1,
            _1: context,
            _2: e
          },
          Error: new Error()
        };
  }
  return {
          it: it._2,
          ann: e.ann
        };
}

function as_one_then_many(context, es) {
  if (es) {
    return [
            es.hd,
            es.tl
          ];
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* OneThenMany */3,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_many_then_one(context, es) {
  if (es) {
    var e1 = es.hd;
    var match = Belt_List.reverse(es.tl);
    if (match) {
      return [
              {
                hd: e1,
                tl: Belt_List.reverse(match.tl)
              },
              match.hd
            ];
    } else {
      return [
              /* [] */0,
              e1
            ];
    }
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* ManyThenOne */4,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_one(context, es) {
  if (es) {
    if (es.tl) {
      throw {
            RE_EXN_ID: SMoLParseError,
            _1: {
              TAG: /* SExprArityError */2,
              _0: /* ExactlyOne */0,
              _1: context,
              _2: es
            },
            Error: new Error()
          };
    }
    return es.hd;
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* ExactlyOne */0,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_two(context, es) {
  if (es) {
    var match = es.tl;
    if (match && !match.tl) {
      return [
              es.hd,
              match.hd
            ];
    }
    
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* ExactlyTwo */1,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_three(context, es) {
  if (es) {
    var match = es.tl;
    if (match) {
      var match$1 = match.tl;
      if (match$1 && !match$1.tl) {
        return [
                es.hd,
                match.hd,
                match$1.hd
              ];
      }
      
    }
    
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* ExactlyThree */2,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_one_then_many_then_one(context, es) {
  if (es) {
    var match = es.tl;
    if (match) {
      var e2 = match.hd;
      var e1 = es.hd;
      var match$1 = Belt_List.reverse(match.tl);
      if (match$1) {
        return [
                e1,
                {
                  hd: e2,
                  tl: Belt_List.reverse(match$1.tl)
                },
                match$1.hd
              ];
      } else {
        return [
                e1,
                /* [] */0,
                e2
              ];
      }
    }
    throw {
          RE_EXN_ID: SMoLParseError,
          _1: {
            TAG: /* SExprArityError */2,
            _0: /* OneThenManyThenOne */5,
            _1: context,
            _2: es
          },
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* SExprArityError */2,
          _0: /* OneThenManyThenOne */5,
          _1: context,
          _2: es
        },
        Error: new Error()
      };
}

function as_expr(context, e) {
  var it = e.it;
  if (it.TAG !== /* Def */0) {
    return {
            it: it._0,
            ann: e.ann
          };
  }
  throw {
        RE_EXN_ID: SMoLParseError,
        _1: {
          TAG: /* TermKindError */5,
          _0: /* Expression */1,
          _1: context,
          _2: e
        },
        Error: new Error()
      };
}

function expr_of_atom(ann, atom) {
  if (atom.TAG === /* Str */0) {
    return {
            TAG: /* Con */0,
            _0: {
              TAG: /* Str */2,
              _0: atom._0
            }
          };
  }
  var x = atom._0;
  switch (x) {
    case "#f" :
        return {
                TAG: /* Con */0,
                _0: {
                  TAG: /* Lgc */1,
                  _0: false
                }
              };
    case "#t" :
        return {
                TAG: /* Con */0,
                _0: {
                  TAG: /* Lgc */1,
                  _0: true
                }
              };
    default:
      var tryNum = Belt_Option.map(Belt_Float.fromString(x), (function (n) {
              return {
                      TAG: /* Con */0,
                      _0: {
                        TAG: /* Num */0,
                        _0: n
                      }
                    };
            }));
      return Belt_Option.getWithDefault(tryNum, {
                  TAG: /* Ref */1,
                  _0: {
                    it: x,
                    ann: ann
                  }
                });
  }
}

function expr_as_block(e) {
  return {
          it: [
            /* [] */0,
            e
          ],
          ann: e.ann
        };
}

function letstar(ann, xes, body) {
  if (xes) {
    var xes$1 = xes.tl;
    var match = xes.hd.it;
    var e = match[1];
    var x = match[0];
    if (xes$1) {
      return {
              it: {
                TAG: /* Let */4,
                _0: {
                  hd: [
                    x,
                    e
                  ],
                  tl: /* [] */0
                },
                _1: expr_as_block(letstar({
                          begin: Belt_Option.getWithDefault(Belt_Option.map(Belt_List.head(xes$1), (function (xe) {
                                      return xe.ann.begin;
                                    })), body.ann.begin),
                          end: body.ann.end
                        }, xes$1, body))
              },
              ann: ann
            };
    } else {
      return {
              it: {
                TAG: /* Let */4,
                _0: {
                  hd: [
                    x,
                    e
                  ],
                  tl: /* [] */0
                },
                _1: body
              },
              ann: ann
            };
    }
  }
  var match$1 = body.it;
  if (match$1[0]) {
    return {
            it: {
              TAG: /* Let */4,
              _0: /* [] */0,
              _1: body
            },
            ann: ann
          };
  } else {
    return match$1[1];
  }
}

function makeBlock(ts, e) {
  return {
          it: [
            ts,
            e
          ],
          ann: {
            begin: Belt_Option.getWithDefault(Belt_Option.map(Belt_List.head(ts), (function (t) {
                        return t.ann.begin;
                      })), e.ann.begin),
            end: e.ann.end
          }
        };
}

function termOfSExpr(e) {
  var ann = e.ann;
  var atom = e.it;
  if (atom.TAG === /* Atom */0) {
    return {
            it: {
              TAG: /* Exp */1,
              _0: expr_of_atom(ann, atom._0)
            },
            ann: ann
          };
  }
  if (atom._0) {
    var es = Belt_List.map(atom._2, value_of_sexpr);
    return {
            it: {
              TAG: /* Exp */1,
              _0: {
                TAG: /* AppPrm */6,
                _0: /* VecNew */15,
                _1: es
              }
            },
            ann: ann
          };
  }
  var es$1 = atom._2;
  if (es$1) {
    var match = es$1.hd.it;
    if (match.TAG === /* Atom */0) {
      var match$1 = match._0;
      if (match$1.TAG !== /* Str */0) {
        switch (match$1._0) {
          case "!=" :
              return app_prm(ann, /* Ne */9, es$1.tl);
          case "*" :
              return app_prm(ann, /* Mul */2, es$1.tl);
          case "+" :
              return app_prm(ann, /* Add */0, es$1.tl);
          case "-" :
              return app_prm(ann, /* Sub */1, es$1.tl);
          case "/" :
              return app_prm(ann, /* Div */3, es$1.tl);
          case "<" :
              return app_prm(ann, /* Lt */4, es$1.tl);
          case "<=" :
              return app_prm(ann, /* Le */7, es$1.tl);
          case ">" :
              return app_prm(ann, /* Gt */6, es$1.tl);
          case ">=" :
              return app_prm(ann, /* Ge */8, es$1.tl);
          case "begin" :
              var match$2 = as_many_then_one("one or more expressions", es$1.tl);
              var terms = Belt_List.map(Belt_List.map(match$2[0], termOfSExpr), (function (param) {
                      return as_expr("an expression", param);
                    }));
              var result = as_expr("an expression", termOfSExpr(match$2[1]));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* Bgn */8,
                          _0: terms,
                          _1: result
                        }
                      },
                      ann: ann
                    };
          case "cond" :
              var branches = Belt_List.map(Belt_List.map(es$1.tl, (function (v) {
                          return as_list("a `cond` branch", v).it;
                        })), (function (param) {
                      return as_one_then_many_then_one("the condition followed by the branch", param);
                    }));
              var _parsed = /* [] */0;
              var _branches = branches;
              while(true) {
                var branches$1 = _branches;
                var parsed = _parsed;
                if (!branches$1) {
                  return {
                          it: {
                            TAG: /* Exp */1,
                            _0: {
                              TAG: /* Cnd */10,
                              _0: Belt_List.reverse(parsed),
                              _1: undefined
                            }
                          },
                          ann: ann
                        };
                }
                var match$3 = branches$1.hd;
                var $$case = match$3[0];
                var match$4 = $$case.it;
                if (match$4.TAG === /* Atom */0) {
                  var match$5 = match$4._0;
                  if (match$5.TAG !== /* Str */0 && match$5._0 === "else" && !branches$1.tl) {
                    var terms$1 = Belt_List.map(match$3[1], termOfSExpr);
                    var result$1 = as_expr("an expression", termOfSExpr(match$3[2]));
                    return {
                            it: {
                              TAG: /* Exp */1,
                              _0: {
                                TAG: /* Cnd */10,
                                _0: Belt_List.reverse(parsed),
                                _1: makeBlock(terms$1, result$1)
                              }
                            },
                            ann: ann
                          };
                  }
                  
                }
                var $$case$1 = as_expr("a (conditional) expression", termOfSExpr($$case));
                var terms$2 = Belt_List.map(match$3[1], termOfSExpr);
                var result$2 = as_expr("an expression", termOfSExpr(match$3[2]));
                _branches = branches$1.tl;
                _parsed = {
                  hd: [
                    $$case$1,
                    makeBlock(terms$2, result$2)
                  ],
                  tl: parsed
                };
                continue ;
              };
          case "deffun" :
              var match$6 = as_one_then_many_then_one("a function header and a body", es$1.tl);
              var match$7 = as_one_then_many("function name followed by parameters", as_list("function name and parameters", match$6[0]).it);
              var fun = as_id("a function name", match$7[0]);
              var args = Belt_List.map(match$7[1], (function (param) {
                      return as_id("a parameter", param);
                    }));
              var terms$3 = Belt_List.map(match$6[1], termOfSExpr);
              var result$3 = as_expr("an expression to be returned", termOfSExpr(match$6[2]));
              return {
                      it: {
                        TAG: /* Def */0,
                        _0: {
                          TAG: /* Fun */1,
                          _0: fun,
                          _1: args,
                          _2: makeBlock(terms$3, result$3)
                        }
                      },
                      ann: ann
                    };
          case "defgen" :
              var match$8 = as_one_then_many_then_one("a generator header and a body", es$1.tl);
              var match$9 = as_one_then_many("generator name followed by parameters", as_list("generator name and parameters", match$8[0]).it);
              var fun$1 = as_id("a generator name", match$9[0]);
              var args$1 = Belt_List.map(match$9[1], (function (param) {
                      return as_id("a parameter", param);
                    }));
              var terms$4 = Belt_List.map(match$8[1], termOfSExpr);
              var result$4 = as_expr("an expression to be returned", termOfSExpr(match$8[2]));
              return {
                      it: {
                        TAG: /* Def */0,
                        _0: {
                          TAG: /* GFun */2,
                          _0: fun$1,
                          _1: args$1,
                          _2: makeBlock(terms$4, result$4)
                        }
                      },
                      ann: ann
                    };
          case "defvar" :
              var match$10 = as_two("a variable and an expression", es$1.tl);
              var x = as_id("a variable name", match$10[0]);
              var e$1 = as_expr("an expression", termOfSExpr(match$10[1]));
              return {
                      it: {
                        TAG: /* Def */0,
                        _0: {
                          TAG: /* Var */0,
                          _0: x,
                          _1: e$1
                        }
                      },
                      ann: ann
                    };
          case "=" :
          case "eq?" :
              return app_prm(ann, /* Eq */5, es$1.tl);
          case "error" :
              return app_prm(ann, /* Err */19, es$1.tl);
          case "generator" :
              var match$11 = as_one_then_many_then_one("the generator signature followed by the function body", es$1.tl);
              var args$2 = Belt_List.map(as_list("generator parameters", match$11[0]).it, (function (param) {
                      return as_id("a parameter", param);
                    }));
              var terms$5 = Belt_List.map(match$11[1], termOfSExpr);
              var result$5 = as_expr("an expression to be returned", termOfSExpr(match$11[2]));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* GLam */11,
                          _0: args$2,
                          _1: makeBlock(terms$5, result$5)
                        }
                      },
                      ann: ann
                    };
          case "if" :
              var match$12 = as_three("three expressions (i.e., a condition, the \"then\" branch, and the \"else\" branch)", es$1.tl);
              var e_cnd = as_expr("a (conditional) expression", termOfSExpr(match$12[0]));
              var e_thn = as_expr("an expression", termOfSExpr(match$12[1]));
              var e_els = as_expr("an expression", termOfSExpr(match$12[2]));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* If */9,
                          _0: e_cnd,
                          _1: e_thn,
                          _2: e_els
                        }
                      },
                      ann: ann
                    };
          case "lambda" :
              var match$13 = as_one_then_many_then_one("the function signature followed by the function body", es$1.tl);
              var args$3 = Belt_List.map(as_list("function parameters", match$13[0]).it, (function (param) {
                      return as_id("a parameter", param);
                    }));
              var terms$6 = Belt_List.map(match$13[1], termOfSExpr);
              var result$6 = as_expr("an expression to be returned", termOfSExpr(match$13[2]));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* Lam */3,
                          _0: args$3,
                          _1: makeBlock(terms$6, result$6)
                        }
                      },
                      ann: ann
                    };
          case "left" :
              return app_prm(ann, /* PairRefLeft */12, es$1.tl);
          case "let" :
              var match$14 = as_one_then_many_then_one("the bindings followed by the body", es$1.tl);
              var xes = Belt_List.map(Belt_List.map(Belt_List.map(as_list("variable-expression pairs", match$14[0]).it, (function (param) {
                              return as_list("a variable and an expression", param);
                            })), (function (v) {
                          return v.it;
                        })), (function (param) {
                      return as_two("a variable and an expression", param);
                    }));
              var xes$1 = Belt_List.map(xes, (function (param) {
                      var x = as_id("a variable to be bound", param[0]);
                      var e = as_expr("an expression", termOfSExpr(param[1]));
                      return [
                              x,
                              e
                            ];
                    }));
              var ts = Belt_List.map(match$14[1], termOfSExpr);
              var result$7 = as_expr("an expression to be return", termOfSExpr(match$14[2]));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* Let */4,
                          _0: xes$1,
                          _1: makeBlock(ts, result$7)
                        }
                      },
                      ann: ann
                    };
          case "let*" :
              var match$15 = as_one_then_many_then_one("the bindings followed by the body", es$1.tl);
              var xes$2 = Belt_List.map(Belt_List.map(as_list("variable-expression pairs", match$15[0]).it, (function (param) {
                          return as_list("a variable and an expression", param);
                        })), (function (v) {
                      return mapAnn(v, (function (param) {
                                    return as_two("a variable and an expression", param);
                                  }));
                    }));
              var xes$3 = Belt_List.map(xes$2, (function (v) {
                      return mapAnn(v, (function (param) {
                                    var x = as_id("a variable to be bound", param[0]);
                                    var e = as_expr("an expression", termOfSExpr(param[1]));
                                    return [
                                            x,
                                            e
                                          ];
                                  }));
                    }));
              var ts$1 = Belt_List.map(match$15[1], termOfSExpr);
              var result$8 = as_expr("an expression to be return", termOfSExpr(match$15[2]));
              return mapAnn(letstar(ann, xes$3, makeBlock(ts$1, result$8)), (function (v) {
                            return {
                                    TAG: /* Exp */1,
                                    _0: v
                                  };
                          }));
          case "letrec" :
              var match$16 = as_one_then_many_then_one("the bindings followed by the body", es$1.tl);
              var xes$4 = Belt_List.map(Belt_List.map(Belt_List.map(as_list("variable-expression pairs", match$16[0]).it, (function (param) {
                              return as_list("a variable and an expression", param);
                            })), (function (v) {
                          return v.it;
                        })), (function (param) {
                      return as_two("a variable and an expression", param);
                    }));
              var xes$5 = Belt_List.map(xes$4, (function (param) {
                      var x = as_id("a variable to be bound", param[0]);
                      var e = as_expr("an expression", termOfSExpr(param[1]));
                      return [
                              x,
                              e
                            ];
                    }));
              var ts$2 = Belt_List.map(match$16[1], termOfSExpr);
              var result$9 = as_expr("an expression to be return", termOfSExpr(match$16[2]));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* Letrec */5,
                          _0: xes$5,
                          _1: makeBlock(ts$2, result$9)
                        }
                      },
                      ann: ann
                    };
          case "mvec" :
              return app_prm(ann, /* VecNew */15, es$1.tl);
          case "next" :
              return app_prm(ann, /* Next */22, es$1.tl);
          case "not" :
              return app_prm(ann, /* Not */20, es$1.tl);
          case "mpair" :
          case "pair" :
              return app_prm(ann, /* PairNew */10, es$1.tl);
          case "print" :
              return app_prm(ann, /* Print */21, es$1.tl);
          case "quote" :
              var e$2 = as_one("a quoted value", es$1.tl);
              return mapAnn(value_of_sexpr(e$2), (function (v) {
                            return {
                                    TAG: /* Exp */1,
                                    _0: v
                                  };
                          }));
          case "right" :
              return app_prm(ann, /* PairRefRight */11, es$1.tl);
          case "set!" :
              var match$17 = as_two("a variable and an expression", es$1.tl);
              var x$1 = as_id("a variable to be set", match$17[0]);
              var e$3 = as_expr("an expression", termOfSExpr(match$17[1]));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* Set */2,
                          _0: x$1,
                          _1: e$3
                        }
                      },
                      ann: ann
                    };
          case "set-left!" :
              return app_prm(ann, /* PairSetLeft */14, es$1.tl);
          case "set-right!" :
              return app_prm(ann, /* PairSetRight */13, es$1.tl);
          case "vec-len" :
          case "vlen" :
              return app_prm(ann, /* VecLen */18, es$1.tl);
          case "vec-ref" :
          case "vref" :
              return app_prm(ann, /* VecRef */16, es$1.tl);
          case "vec-set!" :
          case "vset!" :
              return app_prm(ann, /* VecSet */17, es$1.tl);
          case "yield" :
              var e$4 = as_one("an expression", es$1.tl);
              var e$5 = as_expr("an expression", termOfSExpr(e$4));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* Yield */12,
                          _0: e$5
                        }
                      },
                      ann: ann
                    };
          case "λ" :
              var match$18 = as_one_then_many_then_one("the function signature followed by the function body", es$1.tl);
              var args$4 = Belt_List.map(as_list("function parameters", match$18[0]).it, (function (param) {
                      return as_id("a parameter", param);
                    }));
              var terms$7 = Belt_List.map(match$18[1], termOfSExpr);
              var result$10 = as_expr("an expression to be returned", termOfSExpr(match$18[2]));
              return {
                      it: {
                        TAG: /* Exp */1,
                        _0: {
                          TAG: /* Lam */3,
                          _0: args$4,
                          _1: makeBlock(terms$7, result$10)
                        }
                      },
                      ann: ann
                    };
          default:
            
        }
      }
      
    }
    
  }
  var match$19 = as_one_then_many("a function call/application, which includes a function and then zero or more arguments", es$1);
  var e$6 = as_expr("a function", termOfSExpr(match$19[0]));
  var es$2 = Belt_List.map(Belt_List.map(match$19[1], termOfSExpr), (function (param) {
          return as_expr("an argument", param);
        }));
  return {
          it: {
            TAG: /* Exp */1,
            _0: {
              TAG: /* App */7,
              _0: e$6,
              _1: es$2
            }
          },
          ann: ann
        };
}

function app_prm(ann, p, es) {
  var es$1 = Belt_List.map(Belt_List.map(es, termOfSExpr), (function (param) {
          return as_expr("an argument", param);
        }));
  return {
          it: {
            TAG: /* Exp */1,
            _0: {
              TAG: /* AppPrm */6,
              _0: p,
              _1: es$1
            }
          },
          ann: ann
        };
}

function parseTerms(src) {
  try {
    return Belt_List.map(SExpression.fromString(src), termOfSExpr);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SExpression.SExpressionError) {
      var err$1 = {
        TAG: /* SExprParseError */0,
        _0: SExpression.$$Error.toString(err._1)
      };
      throw {
            RE_EXN_ID: SMoLParseError,
            _1: err$1,
            Error: new Error()
          };
    }
    throw err;
  }
}

function parseProgram(src) {
  var it = parseTerms(src);
  var begin = Belt_Option.getWithDefault(Belt_Option.map(Belt_List.head(it), (function (v) {
              return v.ann.begin;
            })), {
        ln: 0,
        ch: 0
      });
  var end = Belt_Option.getWithDefault(Belt_Option.map(Belt_List.head(Belt_List.reverse(it)), (function (v) {
              return v.ann.end;
            })), {
        ln: 0,
        ch: 0
      });
  return {
          it: it,
          ann: {
            begin: begin,
            end: end
          }
        };
}

function parseOutput(src) {
  try {
    return Belt_List.map(SExpression.fromString(src), outputletOfSExpr);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err.RE_EXN_ID === SExpression.SExpressionError) {
      var err$1 = {
        TAG: /* SExprParseError */0,
        _0: SExpression.$$Error.toString(err._1)
      };
      throw {
            RE_EXN_ID: SMoLParseError,
            _1: err$1,
            Error: new Error()
          };
    }
    throw err;
  }
}

var Parser = {
  parseOutput: parseOutput,
  parseProgram: parseProgram
};

export {
  Primitive ,
  SExprKind ,
  Arity ,
  TermKind ,
  ParseError ,
  SMoLParseError ,
  Parser ,
}
/* No side effect */
